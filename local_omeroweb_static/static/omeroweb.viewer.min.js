(function() {
/*
 * Copyright (c) 2008-2013 University of Dundee. & Open Microscopy Environment.
 * All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Aleksandra Tarkowska <A(dot)Tarkowska(at)dundee(dot)ac(dot)uk>, 2008.
 */

/*global OME:true */
if (typeof OME === "undefined") {
    OME = {};
}

// Use userAgent to detect mobile devices
// from http://stackoverflow.com/questions/3514784/what-is-the-best-way-to-detect-a-handheld-device-in-jquery
OME.isMobileDevice = function() {
    return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|PlayBook|IEMobile|Opera Mini|Mobile Safari|Silk/i).test(navigator.userAgent);
};

OME.rgbToHex = function rgbToHex(rgb) {
    if (rgb.substring(0,1) == '#') {
        return rgb.substring(1);
    }
    var rgbvals = /rgb\((.+),(.+),(.+)\)/i.exec(rgb);
    if (!rgbvals) return rgb;
    var rval = parseInt(rgbvals[1], 10).toString(16);
    var gval = parseInt(rgbvals[2], 10).toString(16);
    var bval = parseInt(rgbvals[3], 10).toString(16);
    if (rval.length == 1) rval = '0' + rval;
    if (gval.length == 1) gval = '0' + gval;
    if (bval.length == 1) bval = '0' + bval;
    return (
        rval +
        gval +
        bval
    ).toUpperCase();
};

OME.hexToRgb = function hexToRgb(hex) {
    hex = OME.rgbToHex(hex);    // in case 'hex' is actually rgb!

    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
};

// Calculate value, saturation and hue as in org.openmicroscopy.shoola.util.ui.colour.HSV
OME.isDark = function(color) {
    if (color.endsWith('.lut')) {
        return false;
    }
    var c = OME.hexToRgb(color);

    var min, max, delta;
    var v, s, h;

    min = Math.min(c.r, c.g, c.b);
    max = Math.max(c.r, c.g, c.b);

    v = max;
    delta = max-min;

    if (max !== 0) {
        s = delta/max;
    }
    else {
        v = 0;
        s = 0;
        h = 0;
    }

    if (c.r==max) {
        h = (c.g-c.b)/delta;
    } else if (c.g == max) {
        h = 2 + (c.b-c.r)/delta;
    } else {
        h = 4 +(c.r-c.g)/delta;
    }

    h = h * 60;
    if (h < 0) {
        h += 360;
    }
    h = h/360;
    v = v/255;

    return (v < 0.6 || (h > 0.6 && s > 0.7));
};

function isInt(n){
    return typeof n== "number" && isFinite(n) && n%1===0;
}

Number.prototype.filesizeformat = function (round) {
    /*
    Formats the value like a 'human-readable' file size (i.e. 13 KB, 4.1 MB,
    102 bytes, etc).*/
    
    if (round === undefined || !isInt(round)) round = 2;
    
    var bytes = this;
    if (bytes < 1024) {
        return bytes + ' B';
    } else if (bytes < (1024*1024)) {
        return (bytes / 1024).toFixed(round) + ' KB';
    } else if (bytes < (1024*1024*1024)) {
        return (bytes / (1024*1024)).toFixed(round) + ' MB';
    } else if (bytes < (1024*1024*1024*1024)) {
        return (bytes / (1024*1024*1024)).toFixed(round) + ' GB';
    } else if (bytes < (1024*1024*1024*1024*1024)) {
        return (bytes / (1024*1024*1024*1024)).toFixed(round) + ' TB';
    } else {
        return (bytes / (1024*1024*1024*1024*1024)).toFixed(round) + ' PB';
    }
    
};

Number.prototype.lengthformat = function (round) {
    if (round === undefined || !isInt(round)) round = 2;
    
    var length = this;
    if (length < 0.001) {
        return (length * 1000 * 1000).toFixed(round) + ' pm';
    } else if (length < 0.1) {
        return (length * 1000 * 10).toFixed(round) + ' &#8491;';
    } else if (length < 1) {
        return (length * 1000).toFixed(round) + ' nm';
    } else if (length < 1000) {
        return length.toFixed(round) + ' &#181m';
    } else if (length < 1000 * 100) {
        return (length / 1000).toFixed(round) + ' mm';
    } else if (length < 1000 * 100 * 10) {
        return (length / 1000 / 100).toFixed(round) + ' cm';
    } else if (length < 1000 * 100 * 10 * 100) {
        return (length / 1000 / 100 / 10).toFixed(round) + ' m';
    } else {
        return (length / 1000 / 100 / 10 / 1000).toFixed(round) + ' km';
    }
};

String.prototype.escapeHTML = function(){
    /*
    HTML Escape Before Inserting Untrusted Data into HTML Element Content
    https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention
    _Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into
    _HTML_Element_Content
    */
    var s = this;
    if (!s) {
        return "";
    }
    s = s + "";
    return s.replace(/[\&"<>\\]/g, function(s) {
        switch(s) {
            case "&": return "&amp;";
            case "\\": return "&#92;";
            case "`": return '&#x60;';
            case "'": return '&#x27;';
            case '"': return '&quot;';
            case "<": return "&lt;";
            case ">": return "&gt;";
            default: return s;
        }
    });
};

String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
};

// IE polyfill from
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
if (!String.prototype.startsWith) {
    String.prototype.startsWith = function(search, pos) {
        return this.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    };
}

jQuery.fn.alternateRowColors = function() {
    var $rows = $(this).children().children('tr');
    $rows.not('.hidden').filter(':odd').removeClass('even').addClass('odd');
    $rows.not('.hidden').filter(':even').removeClass('odd').addClass('even');
  return this;
};


// Call this on an <input> to only allow numbers.
// I rejects all non-numeric characters but allows paste (then checks value)
// By default it only allows positive ints.
// To allow negative or float values use $(".number").numbersOnly({negative:true, float:true});
jQuery.fn.numbersOnly = function(options) {

    // First, save the current value (assumed to be valid)
    this.each(function() {
        $(this).data('numbersOnly', $(this).val());
    })
    .on('keypress', function(event){

        // we allow copy, paste, left or right
        var allowedChars = [37, 39, 99, 118];
        if (options && options.negative) {
            allowedChars.push(45);
        }
        if (options && options.float) {
            allowedChars.push(46);
        }
        // Reject keypress if not a number and NOT one of our allowed Chars
        var charCode = (event.which) ? event.which : event.keyCode;
        if (charCode > 31 && (charCode < 48 || charCode > 57) && allowedChars.indexOf(charCode) == -1) {
            return false;
        }

        // We've allowed keypress (including paste)...
        //finally check field value after waiting for keypress to update...
        var $this = $(this);
        setTimeout(function(){
            var n = $this.val();
            var isNumber = function(n) {
                if (n.length === 0) {
                    return true;        // empty strings are allowed
                }
                return !isNaN(parseFloat(n)) && isFinite(n);
            };
            // If so, save to 'data', otherwise revert to 'data'
            if (isNumber(n)) {
                $this.data('numbersOnly', n);     // update
            } else {
                $this.val( $this.data('numbersOnly') );
            }
        }, 10);

        return true;
    });

    return this;
};

OME.openPopup = function(url) {
    // IE8 doesn't support arbitrary text for 'name' 2nd arg.  #6118
    var owindow = window.open(url, '', 'height=600,width=850,left=50,top=50,toolbar=no,menubar=no,scrollbars=yes,resizable=yes,location=no,directories=no,status=no');
    if(!owindow.closed) {
        owindow.focus();
    }
    return false;
};


OME.openCenteredWindow = function(url, w, h) {
    var width = w ? +w : 550;
    var height = h ? +h : 600;
    var left = parseInt((screen.availWidth/2) - (width/2), 10);
    var top = 0;
    var windowFeatures = "width=" + width + ",height=" + height + ",status=no,resizable=yes,scrollbars=yes,menubar=no,toolbar=no,left=" + left + ",top=" + top + "screenX=" + left + ",screenY=" + top;
    var myWindow = window.open(url, "", windowFeatures);
    if(!myWindow.closed) {
        myWindow.focus();
    }
    return false;
};


OME.openScriptWindow = function(event, width, height) {
    // open script url, providing Data_Type and IDs params in request
    var script_url = $(event.target).attr('href');
    if (script_url == "#") return false;

    if (script_url.indexOf('script_upload') > -1) {
        OME.openCenteredWindow(script_url, width, 300);
        return;
    }

    // selected is list of {'id':'image-123'} etc.
    var selected = $("body").data("selected_objects.ome"),
        sel_types = {};
    if (typeof selected !== "undefined") {
        for (var i=0; i<selected.length; i++) {
            var type = selected[i].id.split("-")[0],
                oid = selected[i].id.split("-")[1];
            if (typeof sel_types[type] === "undefined") {
                sel_types[type] = [];
            }
            sel_types[type].push(oid);
        }
        var args = [];
        for (var key in sel_types) {
            // If in SPW with wells selected, handy to know what 'field'
            if (key === "well") {
                // grab the index select value:
                if ($("#id_index").length > 0) {
                    args.push("Index=" + $("#id_index").val());
                }
            }
            if (sel_types.hasOwnProperty(key)){
                args.push(key.capitalize() + "=" + sel_types[key].join(","));
            }
        }
        var fileAnnotationCheckboxes =
            $("#fileanns_container input[type=checkbox]").filter(":checked");
        if (fileAnnotationCheckboxes.length > 0) {
            var fileAnnotationIds = [];
            fileAnnotationCheckboxes.each(function() {
                var li = $(this).parents("li").first();
                var oid = li.attr('id').split('-')[1];
                fileAnnotationIds.push(oid);
            });
            args.push("File_Annotation=" + fileAnnotationIds.join(","));
        }
        script_url += "?" + args.join("&");
    }
    OME.openCenteredWindow(script_url, width, height);
    return false;
};


/*
 *  Returns a string representing the currently selected items in the $.jstree.
 * E.g.     "Image=23,34,98&Dataset=678"
**/
OME.get_tree_selection = function() {
    if (typeof $.jstree === "undefined") {
        return "";
    }
    var datatree = $.jstree.reference('#dataTree');
    var selected = datatree.get_selected(true);

    var selected_ids = {};

    $.each(selected, function(index, node) {
        var dtype = node.type;
        var data_type = dtype.charAt(0).toUpperCase() + dtype.slice(1); // capitalise
        var data_id = node.data.obj.id;
        if (data_type in selected_ids) {
            selected_ids[data_type] += ","+data_id;
        } else {
            selected_ids[data_type] = data_id;
        }
    });

    var ids_list = [];
    for (var key in selected_ids){
        ids_list.push(key+"="+selected_ids[key]);
    }
    return ids_list.join("&");
};


// we need to know parent for Channels or Rdefs 'apply to all'
OME.getParentId = function() {
    if (typeof $.jstree === "undefined") {
        return;
    }
    var datatree = $.jstree.reference('#dataTree');

    var selected = datatree.get_selected(true);
    if (selected.length == 1) {
        var node = selected[0],
            parentNode;

        if (node.type === 'acquisition') {
            parentNode = datatree.get_node(datatree.get_parent(node));
            return parentNode.type + '-' + parentNode.data.obj.id;
        } else if (node.type === 'plate') {
            return node.type + '-' + node.data.obj.id;
        } else if  (node.type === 'image') {
            parentNode = datatree.get_node(datatree.get_parent(node));
            if (parentNode.type === 'dataset') {
                return parentNode.type + '-' + parentNode.data.obj.id;
            }
        }
    }
};


/*
 * Confirm dialog using jquery-ui dialog. http://jqueryui.com/demos/dialog/
 * This code provides a short-cut that doens't need html elements on the page
 * Basic usage (text only - Default buttons are 'OK' and 'Cancel'):
 *    var OK_dialog = OME.confirm_dialog("Can you confirm that you want to proceed?", function() {
 *        var clicked_button_text = OK_dialog.data("clicked_button");
 *        alert(clicked_button_text);
 *    });
 *
 * Also possible to specify title, buttons, width, height:
 *    var btn_labels = ["Yes", "No", "Maybe", "Later"];
 *    var title_dialog = OME.confirm_dialog("Can you confirm that you want to proceed?",
 *          function() { alert( title_dialog.data("clicked_button") },
 *          "Dialog Title", btn_labels, 300, 200);
 */
OME.confirm_dialog = function(dialog_text, callback, title, button_labels, width, height) {

    if ((typeof title == "undefined") || (title === null)) {
        title = "Confirm";
    }
    if ((typeof width == "undefined") || (width === null)) {
        width = 350;
    }
    if ((typeof height == "undefined") || (height === null)) {
        height = 140;
    }

    var $dialog = $("#confirm_dialog");
    if ($dialog.length > 0) {       // get rid of any old dialogs
        $dialog.remove();
    }
    $dialog = $("<div id='confirm_dialog'></div>");
    $('body').append($dialog);

    $dialog.attr("title", title).hide();
    $dialog.html("<p>"+ dialog_text +"</p>");

    if (typeof button_labels == "undefined") {
        button_labels = ['OK', 'Cancel'];
    }
    var btns = {};
    for (var i=0; i<button_labels.length; i++) {
        var b = button_labels[i];
        btns[b] = function(event) {
            var btxt = $(event.target).text();
            $dialog.data("clicked_button", btxt);
            $( this ).dialog( "close" );
        };
    }

    $dialog.dialog({
        resizable: true,
        height: height,
        width: width,
        modal: true,
        buttons: btns
    });
    if (callback) {
        $dialog.bind("dialogclose", callback);
    }

    return $dialog;
};

// short-cut to simply display a message
OME.alert_dialog = function(message) {
    OME.confirm_dialog(message, undefined, "", ["OK"]);
};


/*
 * A dialog for sending feedback.
 * Loads and submits the feedback form at "/feedback/feedback"
 */
OME.feedback_dialog = function(error, feedbackUrl) {

    var $feedback_dialog = $("#feedback_dialog");
    if ($feedback_dialog.length > 0) {       // get rid of any old dialogs
        $feedback_dialog.remove();
    }
    $feedback_dialog = $("<div id='feedback_dialog'></div>");
    $('body').append($feedback_dialog);

    $feedback_dialog.attr("title", "Send Feedback").hide();
    $feedback_dialog.load(feedbackUrl + " #form-500", function() {
        $("textarea[name=error]", $feedback_dialog).val(error);
        $("input[type=submit]", $feedback_dialog).hide();
        $("form", $feedback_dialog).ajaxForm({
            success: function(data) {
                $feedback_dialog.html(data);
                $feedback_dialog.dialog("option", "buttons", {
                    "Close": function() {
                        $( this ).dialog( "close" );
                    }
                });
            }
        });
    });

    $feedback_dialog.dialog({
        resizable: true,
        height: 500,
        width: 700,
        modal: true,
        buttons: {
            "Cancel": function() {
                $( this ).dialog( "close" );
            },
            "Send": function() {
                $("form", $feedback_dialog).trigger('submit');
            }
        }
    });
    return $feedback_dialog;
};

/**
 * Handle jQuery load() errors (E.g. timeout)
 * In this case we simply refresh (will redirect to login page)
**/
OME.setupAjaxError = function(feedbackUrl){

    $(document).ajaxError(function(e, req, settings, exception) {
        var error;
        if (req.status == 404) {
            var msg = "Url: " + settings.url + "<br/>" + req.responseText;
            OME.confirm_dialog(msg, null, "404 Error", ["OK"], 360, 200);
        } else if (req.status == 403) {
            // Denied (E.g. session timeout) Refresh - will redirect to login page
            window.location.reload();
        } else if (req.status == 500) {
            // Our 500 handler returns only the stack-trace if request.is_json()
            error = req.responseText;
            // If the failed request was loading feedback, prevent recursive loading of feedback!
            if (settings.url.startsWith(feedbackUrl)) {
                return;
            }
            OME.feedback_dialog(error, feedbackUrl);
        } else if (req.status == 400) {
            if (req.responseText.indexOf('Request Line is too large') > -1) {
                // This should be handled by the caller - e.g. loading of right panel
            } else {
                // 400 Bad Request. Usually indicates some invalid parameter, e.g. an invalid group id
                // Usually indicates a problem with the webclient rather than the server as the webclient
                // requested something invalid
                error = req.responseText;
                OME.feedback_dialog(error, feedbackUrl);
            }
        }
    });
};


/*
 * NB: This code is NOT USED currently. Experimental.
 * A dialog for logging-in on the fly (without redirect to login page).
 * On clicking 'Connect' we post username & password to login url and on callback, the callback function is called
 */
OME.login_dialog = function(login_url, callback) {

    var $dialog = $("#login_dialog");
    if ($dialog.length > 0) {       // get rid of any old dialogs
        $dialog.remove();
    }
    $dialog = $("<div id='login_dialog'></div>");
    $('body').append($dialog);

    $dialog.attr("title", "Login").hide();
    $dialog.html("<form>Username:<input type='text' name='username' id='login_username' /><br />Password:<input type='text' name='password' id='login_password'/>");

    $dialog.dialog({
        resizable: true,
        height: 200,
        width: 300,
        modal: true,
        buttons: {
            "Cancel": function() {
                $( this ).dialog( "close" );
            },
            "Connect": function() {
                var username = $("#login_username").val();
                var password = $("#login_password").val();
                $.post(login_url, {'password':password, 'username':username, 'noredirect':'true'},  function(data) {
                    //console.log("logged-in...");
                    callback();
                });
                $( this ).dialog( "close" );
            }
        }
    });
    $dialog.bind("dialogclose", callback);

    return $dialog;
};


(function ($) {

    // This jQuery plugin is used to init a right-panel webclient-plugin (too many plugins!)
    // It adds listeners to selection and tab-change events, updating the panel by loading
    // a url based on the currently selected objects.
    // Example usage:
    //
    //  $("#rotation_3d_tab").omeroweb_right_plugin({           // The tab content element
    //      plugin_index: 3,                                    // The tab index
    //      load_plugin_content: function(selected, obj_dtype, obj_id) {    // Url based on selected object(s)
    //          $(this).load('{% url weblabs_index %}rotation_3d_viewer/'+obj_id);
    //      },
    //      supported_obj_types: ['image','dataset'],   // E.g. only support single image/dataset selected
    //  });
    $.fn.omeroweb_right_plugin = function (settings) {

        var returnValue = this;

        // Process each jQuery object in array
        this.each(function(i) {
            // 'this' is the element we're working with
            var $this = $(this);
            var plugin_tab_index = $this.index()-1;

            // store settings
            // 'load_plugin_content' was called 'load_tab_content' (4.4.9 and earlier). Support both...
            var load_plugin_content = settings['load_plugin_content'] || settings['load_tab_content'],
                supported_obj_types = settings['supported_obj_types'],
                // only used if 'supported_obj_types' undefined. (was called 'tab_enabled' in 4.4.9)
                plugin_enabled = settings['plugin_enabled'] || settings['tab_enabled'];

            var update_tab_content = function() {
                // get the selected id etc
                var selected = $("body").data("selected_objects.ome");
                if (selected.length === 0) {
                    return;
                }
                var obj_id = selected[0]['id'];     // E.g. image-123
                var dtype = obj_id.split("-")[0];    // E.g. 'image'
                var oid = obj_id.split("-")[1];

                // if the tab is visible and not loaded yet...
                if ($this.is(":visible") && $this.is(":empty")) {
                    // we want the context of load_plugin_content to be $this
                    $.proxy(load_plugin_content, $this)(selected, dtype, oid);
                }
            };

            // update tabs when tree selection changes or tabs switch
            $("#annotation_tabs").on( "tabsactivate", function(event, ui){
                // we get a "tabsactivate" event, but need to check if 'this' tab was chosen...
                if (ui.newTab.index() == plugin_tab_index) {
                    $this.show();   // sometimes this doesn't get shown until too late
                    update_tab_content();
                }
            });

            // on change of selection in tree, update which tabs are enabled
            $("body").on("selection_change.ome", function(event) {

                // clear contents of panel
                $this.empty();

                // get selected objects
                var selected = $("body").data("selected_objects.ome");
                if (selected.length === 0) {
                    $("#annotation_tabs").tabs("disable", plugin_tab_index);
                    return;
                }
                var obj_id = selected[0]['id'];     // E.g. image-123
                var orel = obj_id.split("-")[0];    // E.g. 'image'

                // we only care about changing selection if this tab is selected...
                var select_tab = $("#annotation_tabs").tabs( "option", "selected" );
                var supported;
                if (typeof supported_obj_types != 'undefined') {
                    supported = ($.inArray(orel, supported_obj_types) >-1) && (selected.length == 1);
                } else {
                    supported = plugin_enabled ? plugin_enabled(selected) : true;
                }

                // update enabled & selected state
                if(!supported) {
                    if (plugin_tab_index == select_tab) {
                        // if we're currently selected - switch to first tab
                        $("#annotation_tabs").tabs("select", 0);
                    }
                    $("#annotation_tabs").tabs("disable", plugin_tab_index);
                } else {
                    $("#annotation_tabs").tabs("enable", plugin_tab_index);
                    // update tab content
                    update_tab_content();
                }
            });

        });
        // return the jquery selection (or if it was a method call that returned a value - the returned value)
        return returnValue;
    };


    // This plugin is similar to the one above, handling center-panel webclient-plugin init.
    $.fn.omeroweb_center_plugin = function (settings) {

        var returnValue = this;

        // Process each jQuery object in array
        this.each(function(i) {
            // 'this' is the element we're working with
            var $this = $(this),
                plugin_index = $this.index() - 1;

            // store settings
            var load_plugin_content = settings['load_plugin_content'],
                supported_obj_types = settings['supported_obj_types'],
                plugin_enabled = settings['plugin_enabled'],      // only used if 'supported_obj_types' undefined
                empty_on_sel_change = settings['empty_on_sel_change'];
            if (typeof empty_on_sel_change == 'undefined') {
                empty_on_sel_change = true;  // TODO use default settings
            }

            var update_plugin_content = function() {
                // get the selected id etc
                var selected = $("body").data("selected_objects.ome");
                if (selected.length === 0) {
                    return;
                }
                var obj_id = selected[0]['id'];     // E.g. image-123
                var dtype = obj_id.split("-")[0];    // E.g. 'image'
                var oid = obj_id.split("-")[1];

                // if the tab is visible...
                if ($this.is(":visible")) {
                    // we want the context of load_plugin_content to be $this
                    $.proxy(load_plugin_content,$this)(selected, dtype, oid);
                }
            };


            $('#center_panel_chooser').on('center_plugin_changed.ome', update_plugin_content);

            // on change of selection in tree, update which tabs are enabled
            $("body").on("selection_change.ome", function(event) {

                // clear contents of panel
                if (empty_on_sel_change) {
                    $this.empty();
                }

                // get selected objects
                var selected = $("body").data("selected_objects.ome");
                if (selected.length === 0) {
                    OME.set_center_plugin_enabled(plugin_index, false);
                    return;
                }
                var obj_id = selected[0]['id'];     // E.g. image-123
                var orel = obj_id.split("-")[0];    // E.g. 'image'

                // do we support the data currently selected?
                var supported;
                if (typeof supported_obj_types != 'undefined') {
                    // simply test E.g. if "image" is in the supported types
                    supported = ($.inArray(orel, supported_obj_types) >-1) && (selected.length == 1);
                } else {
                    // OR use the user-specified function to check support
                    supported = plugin_enabled ? plugin_enabled(selected) : true;
                }

                // update enabled state
                OME.set_center_plugin_enabled(plugin_index, supported);
                if(supported) {
                    update_plugin_content();
                } else {
                    $this.empty();
                }
            });
        });

        // return the jquery selection (or if it was a method call that returned a value - the returned value)
        return returnValue;
    };

}(jQuery));


// jQuery plugin: simple emulation of table-sorter for other elements...
// Based on code from 'Learning jQuery 1.3 http://book.learningjquery.com/'
// Called on an element that resembles a table.
// Example usage:
//$(".element_sorter").elementsorter({
//    head: '.thead div',             // Selector for the equivalent of 'table head'
//    body: 'li.row',                 // Selector for the equivalent of 'table rows'
//    sort_key: '.hidden_sort_text'   // optional - how to find the text within each child of a 'row'.
//});
(function ($) {

    "use strict";

    var methods = {

    // initialise the plugin
    init : function (options) {

        if (!options.head || !options.body) {
            return;
        }

        return this.each(function(){
            var $this = $(this),
                data = $this.data('elementsorter');

            // If the plugin hasn't been initialized yet
            if ( ! data ) {

                data = options;     // save for later ref (E.g. destroy())
                
                var $headers = $(options.head, $this);
                // for each 'column'...
                $headers.each(function(column) {
                    var $header = $(this),
                        findSortKey;
                    var findSortText = function($cell) {
                        if (options.sort_key) {
                            if ($(options.sort_key, $cell).length > 0) {
                                return $(options.sort_key, $cell).text();
                            }
                        }
                        return $cell.text();
                    };
                    if ($header.is('.sort-alpha')) {
                        findSortKey = function($cell) {
                            return findSortText($cell).toLowerCase();
                        };
                    } else if ($header.is('.sort-numeric')) {
                        findSortKey = function($cell) {
                            var key = findSortText($cell).replace(/^[^\d.]*/, '');
                            key = parseFloat(key);
                            return isNaN(key) ? 0 : key;
                        };
                    } else if ($header.is('.sort-date')) {
                        findSortKey = function($cell) {
                            var date = Date.parse(findSortText($cell));
                            return isNaN(date) ? 0 : date;
                        };
                    }
                    if (findSortKey) {
                        $header
                            .addClass('clickable')
                            .on('click', function() {
                                var sortDirection = 1;
                                if ($header.is('.sorted-asc')) {
                                    sortDirection = -1;
                                }
                                var rows = $(options.body, $this).get();
                                // populate each row with current sort key
                                $.each(rows, function(index, row) {
                                    var $row = $(row),
                                        $cell = $row.children().eq(column);
                                    row.sortKey = findSortKey($cell);
                                    row.dataId = $row.attr('data-id');
                                });
                                // Do the sorting...
                                rows.sort(function(a, b){
                                    if (a.sortKey === b.sortKey) {
                                        return a.dataId <= b.dataId ? -sortDirection : sortDirection;
                                    }
                                    return a.sortKey < b.sortKey ? -sortDirection : sortDirection;
                                });
                                // add rows to DOM in order
                                $.each(rows, function(index, row) {
                                    $this.append(row);
                                    row.sortKey = null;
                                });
                                // clear classes from other headers
                                $headers.removeClass('sorted-asc')
                                    .removeClass('sorted-desc');
                                if (sortDirection == 1) {
                                    $header.addClass('sorted-asc');
                                } else {
                                    $header.addClass('sorted-desc');
                                }
                            });
                        // In this case, we sort by this column during plugin init.
                        if ($header.is('.sort-init')) {
                            $header.trigger('click');
                        }
                    }
                });

                $this.data('elementsorter', data);
                
            }
        });
    },

    destroy: function() {
        
        return this.each(function(){
            //var $this = $(this),
            //    data = $this.data('elementsorter');

            // all we need to do is remove the click handlers from headers
            // var $headers = $(data.head, $this);
        });
    }

    };


    // the plugin definition: either we init or we're calling a named method.
    $.fn.elementsorter = function( method ) {

        if ( methods[method] ) {
          return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
        }
        if ( typeof method === 'object' || ! method ) {
          return methods.init.apply( this, arguments );
        }
        $.error( 'Method ' +  method + ' does not exist on jQuery.src_loader' );
    };

}(jQuery));

// ** TESTING ONLY **
// http://remysharp.com/2007/11/01/detect-global-variables/
if (false) {                    // set to 'true' to run. NB: Need to uncomment 'console.log..' below.
    setTimeout(function(){      // use timeout to allow all scripts to load etc
        console.log("SHOWING GLOBAL VARIABLES...");
        var differences = {},
            exceptions,
            globals = {},
            //ignoreList = (prompt('Ignore filter (comma sep)?', '') || '').split(','),
            ignoreList = [],    // E.g. ["function"]
            i = ignoreList.length,
            iframe = document.createElement('iframe');
        while (i--) {
          globals[ignoreList[i]] = 1;
        }
        for (i in window) {
          differences[i] = {
            'type': typeof window[i],
            'val': window[i]
          };
        }
        iframe.style.display = 'none';
        document.body.appendChild(iframe);
        iframe.src = 'about:blank';
        iframe = iframe.contentWindow || iframe.contentDocument;
        for (i in differences) {
          if (typeof iframe[i] != 'undefined') {delete differences[i];}
          else if (globals[differences[i].type]) {delete differences[i];}
        }
        exceptions = 'addEventListener,document,location,navigator,window'.split(',');
        exceptions.push("jQuery", "$");  // Ignore jQuery etc...
        exceptions.push("isClientPhone", "callback", "isClientTouch", "isIE");      // from panojs/utils.js
        exceptions.push("sanitizeHexColor", "toRGB", "rgbToHex", "parseQuery", "downloadLandingDialog"); // from ome.gs_utils.js
        // All these from PanoJS
        exceptions.push("PanoJS", "PanoControls", "BisqueISLevel", "BisqueISPyramid", "formatInt");
        exceptions.push("ImgcnvPyramid", "ImgcnvLevel", "InfoControl", "Metadata", "OsdControl", "ROIControl", "ScaleBarControl");
        exceptions.push("Tile", "ZoomifyLevel", "ZoomifyPyramid", "SvgControl", "ThumbnailControl", "trim");
        i = exceptions.length;
        while (--i) {
          delete differences[exceptions[i]];
        }
        console.dir(differences);     // comment out to keep jsHint happy!
    }, 1000);
}

;/**
* jQuery AOP - jQuery plugin to add features of aspect-oriented programming (AOP) to jQuery.
* http://jquery-aop.googlecode.com/
*
* Licensed under the MIT license:
* http://www.opensource.org/licenses/mit-license.php
*
* Version: 1.3
*
* Cross-frame type detection based on Daniel Steigerwald's code (http://daniel.steigerwald.cz)
* http://gist.github.com/204554
*
*/

(function() {

	var _after			= 1;
	var _afterThrow		= 2;
	var _afterFinally	= 3;
	var _before			= 4;
	var _around			= 5;
	var _intro			= 6;
	var _regexEnabled = true;
	var _arguments = 'arguments';
	var _undef = 'undefined';

	var getType = (function() {
	 
		var toString = Object.prototype.toString,
			toStrings = {},
			nodeTypes = { 1: 'element', 3: 'textnode', 9: 'document', 11: 'fragment' },
			types = 'Arguments Array Boolean Date Document Element Error Fragment Function NodeList Null Number Object RegExp String TextNode Undefined Window'.split(' ');
	 
		for (var i = types.length; i--; ) {
			var type = types[i], constructor = window[type];
			if (constructor) {
				try { toStrings[toString.call(new constructor)] = type.toLowerCase(); }
				catch (e) { }
			}
		}
	 
		return function(item) {
			return item == null && (item === undefined ? _undef : 'null') ||
				item.nodeType && nodeTypes[item.nodeType] ||
				typeof item.length == 'number' && (
					item.callee && _arguments ||
					item.alert && 'window' ||
					item.item && 'nodelist') ||
				toStrings[toString.call(item)];
		};
	 
	})();

	var isFunc = function(obj) { return getType(obj) == 'function'; };

	/**
	 * Private weaving function.
	 */
	var weaveOne = function(source, method, advice) {

		var old = source[method];

		// Work-around IE6/7 behavior on some native method that return object instances
		if (advice.type != _intro && !isFunc(old)) {
			var oldObject = old;
			old = function() {
				var code = arguments.length > 0 ? _arguments + '[0]' : '';

				for (var i=1;i<arguments.length;i++) {
					code += ',' + _arguments + '[' + i + ']';
				}

				return eval('oldObject(' + code + ');');
			};
		}

		var aspect;
		if (advice.type == _after || advice.type == _afterThrow || advice.type == _afterFinally)
			aspect = function() {
				var returnValue, exceptionThrown = null;

				try {
					returnValue = old.apply(this, arguments);
				} catch (e) {
					exceptionThrown = e;
				}

				if (advice.type == _after)
					if (exceptionThrown == null)
						returnValue = advice.value.apply(this, [returnValue, method]);
					else
						throw exceptionThrown;
				else if (advice.type == _afterThrow && exceptionThrown != null)
					returnValue = advice.value.apply(this, [exceptionThrown, method]);
				else if (advice.type == _afterFinally)
					returnValue = advice.value.apply(this, [returnValue, exceptionThrown, method]);

				return returnValue;
			};
		else if (advice.type == _before)
			aspect = function() {
				advice.value.apply(this, [arguments, method]);
				return old.apply(this, arguments);
			};
		else if (advice.type == _intro)
			aspect = function() {
				return advice.value.apply(this, arguments);
			};
		else if (advice.type == _around) {
			aspect = function() {
				var invocation = { object: this, args: Array.prototype.slice.call(arguments) };
				return advice.value.apply(invocation.object, [{ arguments: invocation.args, method: method, proceed : 
					function() {
						return old.apply(invocation.object, invocation.args);
					}
				}] );
			};
		}

		aspect.unweave = function() { 
			source[method] = old;
			pointcut = source = aspect = old = null;
		};

		source[method] = aspect;

		return aspect;

	};

	/**
	 * Private method search
	 */
	var search = function(source, pointcut, advice) {
		
		var methods = [];

		for (var method in source) {

			var item = null;

			// Ignore exceptions during method retrival
			try {
				item = source[method];
			}
			catch (e) { }

			if (item != null && method.match(pointcut.method) && isFunc(item))
				methods[methods.length] = { source: source, method: method, advice: advice };

		}

		return methods;
	};

	/**
	 * Private weaver and pointcut parser.
	 */
	var weave = function(pointcut, advice) {

		var source = typeof(pointcut.target.prototype) != _undef ? pointcut.target.prototype : pointcut.target;
		var advices = [];

		// If it's not an introduction and no method was found, try with regex...
		if (advice.type != _intro && typeof(source[pointcut.method]) == _undef) {

			// First try directly on target
			var methods = search(pointcut.target, pointcut, advice);

			// No method found, re-try directly on prototype
			if (methods.length == 0)
				methods = search(source, pointcut, advice);

			for (var i in methods)
				advices[advices.length] = weaveOne(methods[i].source, methods[i].method, methods[i].advice);

		} 
		else
		{
			// Return as an array of one element
			advices[0] = weaveOne(source, pointcut.method, advice);
		}

		return _regexEnabled ? advices : advices[0];

	};

	jQuery.aop = 
	{
		/**
		 * Creates an advice after the defined point-cut. The advice will be executed after the point-cut method 
		 * has completed execution successfully, and will receive one parameter with the result of the execution.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.after( {target: window, method: 'MyGlobalMethod'}, function(result) { 
		 *                alert('Returned: ' + result); 
		 *                return result;
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.after( {target: String, method: 'indexOf'}, function(index) { 
		 *                alert('Result found at: ' + index + ' on:' + this); 
		 *                return index;
		 *          } );
		 * @result Array<Function>
		 *
		 * @name after
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called after the execution of the point-cut. It receives one parameter
		 *                        with the result of the point-cut's execution. The function can choose to return this same value or a different one.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		after : function(pointcut, advice)
		{
			return weave( pointcut, { type: _after, value: advice } );
		},

		/**
		 * Creates an advice after the defined point-cut only for unhandled exceptions. The advice will be executed 
		 * after the point-cut method only if the execution failed and an exception has been thrown. It will receive one 
		 * parameter with the exception thrown by the point-cut method.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.afterThrow( {target: String, method: 'indexOf'}, function(exception) { 
		 *                alert('Unhandled exception: ' + exception); 
		 *                return -1;
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.afterThrow( {target: calculator, method: 'Calculate'}, function(exception) { 
		 *                console.log('Unhandled exception: ' + exception);
		 *                throw exception;
		 *          } );
		 * @result Array<Function>
		 *
		 * @name afterThrow
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called after the execution of the point-cut. It receives one parameter
		 *                        with the exception thrown by the point-cut method.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		afterThrow : function(pointcut, advice)
		{
			return weave( pointcut, { type: _afterThrow, value: advice } );
		},

		/**
		 * Creates an advice after the defined point-cut. The advice will be executed after the point-cut method 
		 * regardless of its success or failure, and it will receive two parameters: one with the 
		 * result of a successful execution or null, and another one with the exception thrown or null.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.afterFinally( {target: window, method: 'MyGlobalMethod'}, function(result, exception) {
		 *                if (exception == null)
		 *                    return 'Returned: ' + result;
		 *                else
		 *                    return 'Unhandled exception: ' + exception;
		 *          } );
		 * @result Array<Function>
		 *
		 * @name afterFinally
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called after the execution of the point-cut regardless of its success or failure.
		 *                        It receives two parameters, the first one with the result of a successful execution or null, and the second one with the 
		 *                        exception or null.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		afterFinally : function(pointcut, advice)
		{
			return weave( pointcut, { type: _afterFinally, value: advice } );
		},


		/**
		 * Creates an advice before the defined point-cut. The advice will be executed before the point-cut method 
		 * but cannot modify the behavior of the method, or prevent its execution.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.before( {target: window, method: 'MyGlobalMethod'}, function() { 
		 *                alert('About to execute MyGlobalMethod'); 
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.before( {target: String, method: 'indexOf'}, function(index) {
		 *                alert('About to execute String.indexOf on: ' + this);
		 *          } );
		 * @result Array<Function>
		 *
		 * @name before
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called before the execution of the point-cut.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		before : function(pointcut, advice)
		{
			return weave( pointcut, { type: _before, value: advice } );
		},


		/**
		 * Creates an advice 'around' the defined point-cut. This type of advice can control the point-cut method execution by calling
		 * the functions '.proceed()' on the 'invocation' object, and also, can modify the arguments collection before sending them to the function call.
		 * This function returns an array of weaved aspects (Function).
		 *
		 * @example jQuery.aop.around( {target: window, method: 'MyGlobalMethod'}, function(invocation) {
		 *                alert('# of Arguments: ' + invocation.arguments.length); 
		 *                return invocation.proceed(); 
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.around( {target: String, method: 'indexOf'}, function(invocation) { 
		 *                alert('Searching: ' + invocation.arguments[0] + ' on: ' + this); 
		 *                return invocation.proceed(); 
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.around( {target: window, method: /Get(\d+)/}, function(invocation) {
		 *                alert('Executing ' + invocation.method); 
		 *                return invocation.proceed(); 
		 *          } );
		 * @desc Matches all global methods starting with 'Get' and followed by a number.
		 * @result Array<Function>
		 *
		 *
		 * @name around
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved. Regex are supported, but not on built-in objects.
		 * @param Function advice Function containing the code that will get called around the execution of the point-cut. This advice will be called with one
		 *                        argument containing one function '.proceed()', the collection of arguments '.arguments', and the matched method name '.method'.
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		around : function(pointcut, advice)
		{
			return weave( pointcut, { type: _around, value: advice } );
		},

		/**
		 * Creates an introduction on the defined point-cut. This type of advice replaces any existing methods with the same
		 * name. To restore them, just unweave it.
		 * This function returns an array with only one weaved aspect (Function).
		 *
		 * @example jQuery.aop.introduction( {target: window, method: 'MyGlobalMethod'}, function(result) {
		 *                alert('Returned: ' + result);
		 *          } );
		 * @result Array<Function>
		 *
		 * @example jQuery.aop.introduction( {target: String, method: 'log'}, function() {
		 *                alert('Console: ' + this);
		 *          } );
		 * @result Array<Function>
		 *
		 * @name introduction
		 * @param Map pointcut Definition of the point-cut to apply the advice. A point-cut is the definition of the object/s and method/s to be weaved.
		 * @option Object target Target object to be weaved. 
		 * @option String method Name of the function to be weaved.
		 * @param Function advice Function containing the code that will be executed on the point-cut. 
		 *
		 * @type Array<Function>
		 * @cat Plugins/General
		 */
		introduction : function(pointcut, advice)
		{
			return weave( pointcut, { type: _intro, value: advice } );
		},
		
		/**
		 * Configures global options.
		 *
		 * @name setup
		 * @param Map settings Configuration options.
		 * @option Boolean regexMatch Enables/disables regex matching of method names.
		 *
		 * @example jQuery.aop.setup( { regexMatch: false } );
		 * @desc Disable regex matching.
		 *
		 * @type Void
		 * @cat Plugins/General
		 */
		setup: function(settings)
		{
			_regexEnabled = settings.regexMatch;
		}
	};

})();

;//  \\
//  Raphal 2.3.0 - JavaScript Vector Library                                                              \\
//  \\
//  Copyright  2008-2016 Dmitry Baranovskiy (http://raphaeljs.com)                                        \\
//  Copyright  2008-2016 Sencha Labs (http://sencha.com)                                                  \\
//  \\
//  Licensed under the MIT (https://github.com/DmitryBaranovskiy/raphael/blob/master/license.txt) license. \\
//  \\

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Raphael"] = factory();
	else
		root["Raphael"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./dev/raphael.amd.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dev/raphael.amd.js":
/*!****************************!*\
  !*** ./dev/raphael.amd.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./raphael.core */ "./dev/raphael.core.js"), __webpack_require__(/*! ./raphael.svg */ "./dev/raphael.svg.js"), __webpack_require__(/*! ./raphael.vml */ "./dev/raphael.vml.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(R) {

    return R;

}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./dev/raphael.core.js":
/*!*****************************!*\
  !*** ./dev/raphael.core.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! eve */ "./node_modules/eve-raphael/eve.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(eve) {

    /*\
     * Raphael
     [ method ]
     **
     * Creates a canvas object on which to draw.
     * You must do this first, as all future calls to drawing methods
     * from this instance will be bound to this canvas.
     > Parameters
     **
     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eves DOMLoad event. In this case method returns `undefined`.
     = (object) @Paper
     > Usage
     | // Each of the following examples create a canvas
     | // that is 320px wide by 200px high.
     | // Canvas is created at the viewports 10,50 coordinate.
     | var paper = Raphael(10, 50, 320, 200);
     | // Canvas is created at the top left corner of the #notepad element
     | // (or its top right corner in dir="rtl" elements)
     | var paper = Raphael(document.getElementById("notepad"), 320, 200);
     | // Same as above
     | var paper = Raphael("notepad", 320, 200);
     | // Image dump
     | var set = Raphael(["notepad", 320, 200, {
     |     type: "rect",
     |     x: 10,
     |     y: 10,
     |     width: 25,
     |     height: 25,
     |     stroke: "#f00"
     | }, {
     |     type: "text",
     |     x: 30,
     |     y: 40,
     |     text: "Dump"
     | }]);
    \*/
    function R(first) {
        if (R.is(first, "function")) {
            return loaded ? first() : eve.on("raphael.DOMload", first);
        } else if (R.is(first, array)) {
            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
        } else {
            var args = Array.prototype.slice.call(arguments, 0);
            if (R.is(args[args.length - 1], "function")) {
                var f = args.pop();
                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
                    f.call(R._engine.create[apply](R, args));
                });
            } else {
                return R._engine.create[apply](R, arguments);
            }
        }
    }
    R.version = "2.3.0";
    R.eve = eve;
    var loaded,
        separator = /[, ]+/,
        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
        formatrg = /\{(\d+)\}/g,
        proto = "prototype",
        has = "hasOwnProperty",
        g = {
            doc: document,
            win: window
        },
        oldRaphael = {
            was: Object.prototype[has].call(g.win, "Raphael"),
            is: g.win.Raphael
        },
        Paper = function () {
            /*\
             * Paper.ca
             [ property (object) ]
             **
             * Shortcut for @Paper.customAttributes
            \*/
            /*\
             * Paper.customAttributes
             [ property (object) ]
             **
             * If you have a set of attributes that you would like to represent
             * as a function of some number you can do it easily with custom attributes:
             > Usage
             | paper.customAttributes.hue = function (num) {
             |     num = num % 1;
             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
             | };
             | // Custom attribute hue will change fill
             | // to be given hue with fixed saturation and brightness.
             | // Now you can use it like this:
             | var c = paper.circle(10, 10, 10).attr({hue: .45});
             | // or even like this:
             | c.animate({hue: 1}, 1e3);
             |
             | // You could also create custom attribute
             | // with multiple parameters:
             | paper.customAttributes.hsb = function (h, s, b) {
             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
             | };
             | c.attr({hsb: "0.5 .8 1"});
             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
            \*/
            this.ca = this.customAttributes = {};
        },
        paperproto,
        appendChild = "appendChild",
        apply = "apply",
        concat = "concat",
        //taken from Modernizr touch test: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js#L40
        supportsTouch = ('ontouchstart' in window) || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
        E = "",
        S = " ",
        Str = String,
        split = "split",
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
        touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },
        lowerCase = Str.prototype.toLowerCase,
        math = Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        PI = math.PI,
        nu = "number",
        string = "string",
        array = "array",
        toString = "toString",
        fillString = "fill",
        objectToString = Object.prototype.toString,
        paper = {},
        push = "push",
        ISURL = R._ISURL = /^url\(['"]?(.+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
        isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        round = math.round,
        setAttribute = "setAttribute",
        toFloat = parseFloat,
        toInt = parseInt,
        upperCase = Str.prototype.toUpperCase,
        availableAttrs = R._availableAttrs = {
            "arrow-end": "none",
            "arrow-start": "none",
            blur: 0,
            "clip-rect": "0 0 1e9 1e9",
            cursor: "default",
            cx: 0,
            cy: 0,
            fill: "#fff",
            "fill-opacity": 1,
            font: '10px "Arial"',
            "font-family": '"Arial"',
            "font-size": "10",
            "font-style": "normal",
            "font-weight": 400,
            gradient: 0,
            height: 0,
            href: "http://raphaeljs.com/",
            "letter-spacing": 0,
            opacity: 1,
            path: "M0,0",
            r: 0,
            rx: 0,
            ry: 0,
            src: "",
            stroke: "#000",
            "stroke-dasharray": "",
            "stroke-linecap": "butt",
            "stroke-linejoin": "butt",
            "stroke-miterlimit": 0,
            "stroke-opacity": 1,
            "stroke-width": 1,
            target: "_blank",
            "text-anchor": "middle",
            title: "Raphael",
            transform: "",
            width: 0,
            x: 0,
            y: 0,
            "class": ""
        },
        availableAnimAttrs = R._availableAnimAttrs = {
            blur: nu,
            "clip-rect": "csv",
            cx: nu,
            cy: nu,
            fill: "colour",
            "fill-opacity": nu,
            "font-size": nu,
            height: nu,
            opacity: nu,
            path: "path",
            r: nu,
            rx: nu,
            ry: nu,
            stroke: "colour",
            "stroke-opacity": nu,
            "stroke-width": nu,
            transform: "transform",
            width: nu,
            x: nu,
            y: nu
        },
        whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
        commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
        hsrg = {hs: 1, rg: 1},
        p2s = /,?([achlmqrstvxz]),?/gi,
        pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
        radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
        eldata = {},
        sortByKey = function (a, b) {
            return a.key - b.key;
        },
        sortByNumber = function (a, b) {
            return toFloat(a) - toFloat(b);
        },
        fun = function () {},
        pipe = function (x) {
            return x;
        },
        rectPath = R._rectPath = function (x, y, w, h, r) {
            if (r) {
                return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
            }
            return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        },
        ellipsePath = function (x, y, rx, ry) {
            if (ry == null) {
                ry = rx;
            }
            return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
        },
        getPath = R._getPath = {
            path: function (el) {
                return el.attr("path");
            },
            circle: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.r);
            },
            ellipse: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.rx, a.ry);
            },
            rect: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height, a.r);
            },
            image: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height);
            },
            text: function (el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            },
            set : function(el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        },
        /*\
         * Raphael.mapPath
         [ method ]
         **
         * Transform the path string with given matrix.
         > Parameters
         - path (string) path string
         - matrix (object) see @Matrix
         = (string) transformed path string
        \*/
        mapPath = R.mapPath = function (path, matrix) {
            if (!matrix) {
                return path;
            }
            var x, y, i, j, ii, jj, pathi;
            path = path2curve(path);
            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];
                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }
            return path;
        };

    R._g = g;
    /*\
     * Raphael.type
     [ property (string) ]
     **
     * Can be SVG, VML or empty, depending on browser support.
    \*/
    R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
    if (R.type == "VML") {
        var d = g.doc.createElement("div"),
            b;
        d.innerHTML = '<v:shape adj="1"/>';
        b = d.firstChild;
        b.style.behavior = "url(#default#VML)";
        if (!(b && typeof b.adj == "object")) {
            return (R.type = E);
        }
        d = null;
    }
    /*\
     * Raphael.svg
     [ property (boolean) ]
     **
     * `true` if browser supports SVG.
    \*/
    /*\
     * Raphael.vml
     [ property (boolean) ]
     **
     * `true` if browser supports VML.
    \*/
    R.svg = !(R.vml = R.type == "VML");
    R._Paper = Paper;
    /*\
     * Raphael.fn
     [ property (object) ]
     **
     * You can add your own method to the canvas. For example if you want to draw a pie chart,
     * you can create your own pie chart function and ship it as a Raphal plugin. To do this
     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
     * Raphal instance is created, otherwise it will take no effect. Please note that the
     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
     * ensure any namespacing ensures proper context.
     > Usage
     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
     |     return this.path( ... );
     | };
     | // or create namespace
     | Raphael.fn.mystuff = {
     |     arrow: function () {},
     |     star: function () {},
     |     // etc
     | };
     | var paper = Raphael(10, 10, 630, 480);
     | // then use it
     | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
     | paper.mystuff.arrow();
     | paper.mystuff.star();
    \*/
    R.fn = paperproto = Paper.prototype = R.prototype;
    R._id = 0;
    /*\
     * Raphael.is
     [ method ]
     **
     * Handful of replacements for `typeof` operator.
     > Parameters
     - o () any object or primitive
     - type (string) name of the type, i.e. string, function, number, etc.
     = (boolean) is given value is of given type
    \*/
    R.is = function (o, type) {
        type = lowerCase.call(type);
        if (type == "finite") {
            return !isnan[has](+o);
        }
        if (type == "array") {
            return o instanceof Array;
        }
        return  (type == "null" && o === null) ||
                (type == typeof o && o !== null) ||
                (type == "object" && o === Object(o)) ||
                (type == "array" && Array.isArray && Array.isArray(o)) ||
                objectToString.call(o).slice(8, -1).toLowerCase() == type;
    };

    function clone(obj) {
        if (typeof obj == "function" || Object(obj) !== obj) {
            return obj;
        }
        var res = new obj.constructor;
        for (var key in obj) if (obj[has](key)) {
            res[key] = clone(obj[key]);
        }
        return res;
    }

    /*\
     * Raphael.angle
     [ method ]
     **
     * Returns angle between two or three points
     > Parameters
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     - x3 (number) #optional x coord of third point
     - y3 (number) #optional y coord of third point
     = (number) angle in degrees.
    \*/
    R.angle = function (x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            var x = x1 - x2,
                y = y1 - y2;
            if (!x && !y) {
                return 0;
            }
            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
        } else {
            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
        }
    };
    /*\
     * Raphael.rad
     [ method ]
     **
     * Transform angle to radians
     > Parameters
     - deg (number) angle in degrees
     = (number) angle in radians.
    \*/
    R.rad = function (deg) {
        return deg % 360 * PI / 180;
    };
    /*\
     * Raphael.deg
     [ method ]
     **
     * Transform angle to degrees
     > Parameters
     - rad (number) angle in radians
     = (number) angle in degrees.
    \*/
    R.deg = function (rad) {
        return Math.round ((rad * 180 / PI% 360)* 1000) / 1000;
    };
    /*\
     * Raphael.snapTo
     [ method ]
     **
     * Snaps given value to given grid.
     > Parameters
     - values (array|number) given array of values or step of the grid
     - value (number) value to adjust
     - tolerance (number) #optional tolerance for snapping. Default is `10`.
     = (number) adjusted value.
    \*/
    R.snapTo = function (values, value, tolerance) {
        tolerance = R.is(tolerance, "finite") ? tolerance : 10;
        if (R.is(values, array)) {
            var i = values.length;
            while (i--) if (abs(values[i] - value) <= tolerance) {
                return values[i];
            }
        } else {
            values = +values;
            var rem = value % values;
            if (rem < tolerance) {
                return value - rem;
            }
            if (rem > values - tolerance) {
                return value - rem + values;
            }
        }
        return value;
    };

    /*\
     * Raphael.createUUID
     [ method ]
     **
     * Returns RFC4122, version 4 ID
    \*/
    var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
        return function () {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
        };
    })(/[xy]/g, function (c) {
        var r = math.random() * 16 | 0,
            v = c == "x" ? r : (r & 3 | 8);
        return v.toString(16);
    });

    /*\
     * Raphael.setWindow
     [ method ]
     **
     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
     > Parameters
     - newwin (window) new window object
    \*/
    R.setWindow = function (newwin) {
        eve("raphael.setWindow", R, g.win, newwin);
        g.win = newwin;
        g.doc = g.win.document;
        if (R._engine.initWin) {
            R._engine.initWin(g.win);
        }
    };
    var toHex = function (color) {
        if (R.vml) {
            // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
            var trim = /^\s+|\s+$/g;
            var bod;
            try {
                var docum = new ActiveXObject("htmlfile");
                docum.write("<body>");
                docum.close();
                bod = docum.body;
            } catch(e) {
                bod = createPopup().document.body;
            }
            var range = bod.createTextRange();
            toHex = cacher(function (color) {
                try {
                    bod.style.color = Str(color).replace(trim, E);
                    var value = range.queryCommandValue("ForeColor");
                    value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                    return "#" + ("000000" + value.toString(16)).slice(-6);
                } catch(e) {
                    return "none";
                }
            });
        } else {
            var i = g.doc.createElement("i");
            i.title = "Rapha\xebl Colour Picker";
            i.style.display = "none";
            g.doc.body.appendChild(i);
            toHex = cacher(function (color) {
                i.style.color = color;
                return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
            });
        }
        return toHex(color);
    },
    hsbtoString = function () {
        return "hsb(" + [this.h, this.s, this.b] + ")";
    },
    hsltoString = function () {
        return "hsl(" + [this.h, this.s, this.l] + ")";
    },
    rgbtoString = function () {
        return this.hex;
    },
    prepareRGB = function (r, g, b) {
        if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
            b = r.b;
            g = r.g;
            r = r.r;
        }
        if (g == null && R.is(r, string)) {
            var clr = R.getRGB(r);
            r = clr.r;
            g = clr.g;
            b = clr.b;
        }
        if (r > 1 || g > 1 || b > 1) {
            r /= 255;
            g /= 255;
            b /= 255;
        }

        return [r, g, b];
    },
    packageRGB = function (r, g, b, o) {
        r *= 255;
        g *= 255;
        b *= 255;
        var rgb = {
            r: r,
            g: g,
            b: b,
            hex: R.rgb(r, g, b),
            toString: rgbtoString
        };
        R.is(o, "finite") && (rgb.opacity = o);
        return rgb;
    };

    /*\
     * Raphael.color
     [ method ]
     **
     * Parses the color string and returns object with all values for the given color.
     > Parameters
     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
     = (object) Combined RGB & HSB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #,
     o     error (boolean) `true` if string cant be parsed,
     o     h (number) hue,
     o     s (number) saturation,
     o     v (number) value (brightness),
     o     l (number) lightness
     o }
    \*/
    R.color = function (clr) {
        var rgb;
        if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
            rgb = R.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
            rgb = R.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R.is(clr, "string")) {
                clr = R.getRGB(clr);
            }
            if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
                rgb = R.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = {hex: "none"};
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };
    /*\
     * Raphael.hsb2rgb
     [ method ]
     **
     * Converts HSB values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - v (number) value or brightness
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #
     o }
    \*/
    R.hsb2rgb = function (h, s, v, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
            v = h.b;
            s = h.s;
            o = h.o;
            h = h.h;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Raphael.hsl2rgb
     [ method ]
     **
     * Converts HSL values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #
     o }
    \*/
    R.hsl2rgb = function (h, s, l, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = 2 * s * (l < .5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = l - C / 2;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Raphael.rgb2hsb
     [ method ]
     **
     * Converts RGB values to HSB object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSB object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     b (number) brightness
     o }
    \*/
    R.rgb2hsb = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, V, C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = (C == 0 ? null :
             V == r ? (g - b) / C :
             V == g ? (b - r) / C + 2 :
                      (r - g) / C + 4
            );
        H = ((H + 360) % 6) * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return {h: H, s: S, b: V, toString: hsbtoString};
    };
    /*\
     * Raphael.rgb2hsl
     [ method ]
     **
     * Converts RGB values to HSL object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSL object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     l (number) luminosity
     o }
    \*/
    R.rgb2hsl = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, L, M, m, C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = (C == 0 ? null :
             M == r ? (g - b) / C :
             M == g ? (b - r) / C + 2 :
                      (r - g) / C + 4);
        H = ((H + 360) % 6) * 60 / 360;
        L = (M + m) / 2;
        S = (C == 0 ? 0 :
             L < .5 ? C / (2 * L) :
                      C / (2 - 2 * L));
        return {h: H, s: S, l: L, toString: hsltoString};
    };
    R._path2string = function () {
        return this.join(",").replace(p2s, "$1");
    };
    function repush(array, item) {
        for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
            return array.push(array.splice(i, 1)[0]);
        }
    }
    function cacher(f, scope, postprocessor) {
        function newf() {
            var arg = Array.prototype.slice.call(arguments, 0),
                args = arg.join("\u2400"),
                cache = newf.cache = newf.cache || {},
                count = newf.count = newf.count || [];
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1e3 && delete cache[count.shift()];
            count.push(args);
            cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return newf;
    }

    var preload = R._preload = function (src, f) {
        var img = g.doc.createElement("img");
        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
        img.onload = function () {
            f.call(this);
            this.onload = null;
            g.doc.body.removeChild(this);
        };
        img.onerror = function () {
            g.doc.body.removeChild(this);
        };
        g.doc.body.appendChild(img);
        img.src = src;
    };

    function clrToString() {
        return this.hex;
    }

    /*\
     * Raphael.getRGB
     [ method ]
     **
     * Parses colour string as RGB object
     > Parameters
     - colour (string) colour string in one of formats:
     # <ul>
     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>
     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>
     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
     #     <li>hsb(%, %, %)  same as above, but in %</li>
     #     <li>hsl(, , )  same as hsb</li>
     #     <li>hsl(%, %, %)  same as hsb</li>
     # </ul>
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue
     o     hex (string) color in HTML/CSS format: #,
     o     error (boolean) true if string cant be parsed
     o }
    \*/
    R.getRGB = cacher(function (colour) {
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
        }
        if (colour == "none") {
            return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
        var res,
            red,
            green,
            blue,
            opacity,
            t,
            values,
            rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {r: red, g: green, b: blue, toString: clrToString};
            rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
            R.is(opacity, "finite") && (rgb.opacity = opacity);
            return rgb;
        }
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
    }, R);
    /*\
     * Raphael.hsb
     [ method ]
     **
     * Converts HSB values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - b (number) value or brightness
     = (string) hex representation of the colour.
    \*/
    R.hsb = cacher(function (h, s, b) {
        return R.hsb2rgb(h, s, b).hex;
    });
    /*\
     * Raphael.hsl
     [ method ]
     **
     * Converts HSL values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (string) hex representation of the colour.
    \*/
    R.hsl = cacher(function (h, s, l) {
        return R.hsl2rgb(h, s, l).hex;
    });
    /*\
     * Raphael.rgb
     [ method ]
     **
     * Converts RGB values to hex representation of the colour.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (string) hex representation of the colour.
    \*/
    R.rgb = cacher(function (r, g, b) {
        function round(x) { return (x + 0.5) | 0; }
        return "#" + (16777216 | round(b) | (round(g) << 8) | (round(r) << 16)).toString(16).slice(1);
    });
    /*\
     * Raphael.getColor
     [ method ]
     **
     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
     > Parameters
     - value (number) #optional brightness, default is `0.75`
     = (string) hex representation of the colour.
    \*/
    R.getColor = function (value) {
        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
            rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += .075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= .2;
            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
        }
        return rgb.hex;
    };
    /*\
     * Raphael.getColor.reset
     [ method ]
     **
     * Resets spectrum position for @Raphael.getColor back to red.
    \*/
    R.getColor.reset = function () {
        delete this.start;
    };

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                        {x: +crp[i - 2], y: +crp[i - 1]},
                        {x: +crp[i],     y: +crp[i + 1]},
                        {x: +crp[i + 2], y: +crp[i + 3]},
                        {x: +crp[i + 4], y: +crp[i + 5]}
                    ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                  (p[1].x + 6 * p[2].x - p[3].x) / 6,
                  (p[1].y + 6*p[2].y - p[3].y) / 6,
                  p[2].x,
                  p[2].y
            ]);
        }

        return d;
    }
    /*\
     * Raphael.parsePathString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of arrays of path segments.
     > Parameters
     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
     = (array) array of segments.
    \*/
    R.parsePathString = function (pathString) {
        if (!pathString) {
            return null;
        }
        var pth = paths(pathString);
        if (pth.arr) {
            return pathClone(pth.arr);
        }

        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
            data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
            data = pathClone(pathString);
        }
        if (!data.length) {
            Str(pathString).replace(pathCommand, function (a, b, c) {
                var params = [],
                    name = b.toLowerCase();
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                if (name == "m" && params.length > 2) {
                    data.push([b][concat](params.splice(0, 2)));
                    name = "l";
                    b = b == "m" ? "l" : "L";
                }
                if (name == "r") {
                    data.push([b][concat](params));
                } else while (params.length >= paramCounts[name]) {
                    data.push([b][concat](params.splice(0, paramCounts[name])));
                    if (!paramCounts[name]) {
                        break;
                    }
                }
            });
        }
        data.toString = R._path2string;
        pth.arr = pathClone(data);
        return data;
    };
    /*\
     * Raphael.parseTransformString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of transformations.
     > Parameters
     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
     = (array) array of transformations.
    \*/
    R.parseTransformString = cacher(function (TString) {
        if (!TString) {
            return null;
        }
        var paramCounts = {r: 3, s: 4, t: 2, m: 6},
            data = [];
        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
            data = pathClone(TString);
        }
        if (!data.length) {
            Str(TString).replace(tCommand, function (a, b, c) {
                var params = [],
                    name = lowerCase.call(b);
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                data.push([b][concat](params));
            });
        }
        data.toString = R._path2string;
        return data;
    }, this, function(elem) {
        if (!elem) return elem;
        var newData = [];
        for (var i = 0; i < elem.length; i++) {
            var newLevel = [];
            for (var j = 0; j < elem[i].length; j++) {
                newLevel.push(elem[i][j]);
            }
            newData.push(newLevel);
        }
      return newData; } );
    // PATHS
    var paths = function (ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function () {
            for (var key in p) if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    };
    /*\
     * Raphael.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Find dot coordinates on the given cubic bezier curve at the given t.
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point
     o     y: (number) y coordinate of the point
     o     m: {
     o         x: (number) x coordinate of the left anchor
     o         y: (number) y coordinate of the left anchor
     o     }
     o     n: {
     o         x: (number) x coordinate of the right anchor
     o         y: (number) y coordinate of the right anchor
     o     }
     o     start: {
     o         x: (number) x coordinate of the start of the curve
     o         y: (number) y coordinate of the start of the curve
     o     }
     o     end: {
     o         x: (number) x coordinate of the end of the curve
     o         y: (number) y coordinate of the end of the curve
     o     }
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/
    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
        (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: {x: mx, y: my},
            n: {x: nx, y: ny},
            start: {x: ax, y: ay},
            end: {x: cx, y: cy},
            alpha: alpha
        };
    };
    /*\
     * Raphael.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given cubic bezier curve
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for bezier curve
     = (object) point information in format:
     o {
     o     min: {
     o         x: (number) x coordinate of the left point
     o         y: (number) y coordinate of the top point
     o     }
     o     max: {
     o         x: (number) x coordinate of the right point
     o         y: (number) y coordinate of the bottom point
     o     }
     o }
    \*/
    R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!R.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };
    /*\
     * Raphael.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding boxes.
     > Parameters
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point inside
    \*/
    R.isPointInsideBBox = function (bbox, x, y) {
        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
    };
    /*\
     * Raphael.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     > Parameters
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if they intersect
    \*/
    R.isBBoxIntersect = function (bbox1, bbox2) {
        var i = R.isPointInsideBBox;
        return i(bbox2, bbox1.x, bbox1.y)
            || i(bbox2, bbox1.x2, bbox1.y)
            || i(bbox2, bbox1.x, bbox1.y2)
            || i(bbox2, bbox1.x2, bbox1.y2)
            || i(bbox1, bbox2.x, bbox2.y)
            || i(bbox1, bbox2.x2, bbox2.y)
            || i(bbox1, bbox2.x, bbox2.y2)
            || i(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    };
    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
            n = 12,
            Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],
            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
            sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (
            mmax(x1, x2) < mmin(x3, x4) ||
            mmin(x1, x2) > mmax(x3, x4) ||
            mmax(y1, y2) < mmin(y3, y4) ||
            mmin(y1, y2) > mmax(y3, y4)
        ) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = +py.toFixed(2);
        if (
            px2 < +mmin(x1, x2).toFixed(2) ||
            px2 > +mmax(x1, x2).toFixed(2) ||
            px2 < +mmin(x3, x4).toFixed(2) ||
            px2 > +mmax(x3, x4).toFixed(2) ||
            py2 < +mmin(y1, y2).toFixed(2) ||
            py2 > +mmax(y1, y2).toFixed(2) ||
            py2 < +mmin(y3, y4).toFixed(2) ||
            py2 > +mmax(y3, y4).toFixed(2)
        ) {
            return;
        }
        return {x: px, y: py};
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        var bbox1 = R.bezierBBox(bez1),
            bbox2 = R.bezierBBox(bez2);
        if (!R.isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = mmax(~~(l1 / 5), 1),
            n2 = mmax(~~(l2 / 5), 1),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
        for (var i = 0; i < n1 + 1; i++) {
            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
            dots1.push({x: p.x, y: p.y, t: i / n1});
        }
        for (i = 0; i < n2 + 1; i++) {
            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
            dots2.push({x: p.x, y: p.y, t: i / n2});
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: mmin(t1, 1),
                                t2: mmin(t2, 1)
                            });
                        }
                    }
                }
            }
        }
        return res;
    }
    /*\
     * Raphael.pathIntersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     > Parameters
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point
     o         y: (number) y coordinate of the point
     o         t1: (number) t value for segment of path1
     o         t2: (number) t value for segment of path2
     o         segment1: (number) order number for segment of path1
     o         segment2: (number) order number for segment of path2
     o         bez1: (array) eight coordinates representing bezir curve for the segment of path1
     o         bez2: (array) eight coordinates representing bezir curve for the segment of path2
     o     }
     o ]
    \*/
    R.pathIntersection = function (path1, path2) {
        return interPathHelper(path1, path2);
    };
    R.pathIntersectionNumber = function (path1, path2) {
        return interPathHelper(path1, path2, 1);
    };
    function interPathHelper(path1, path2, justCount) {
        path1 = R._path2curve(path1);
        path2 = R._path2curve(path2);
        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    /*\
     * Raphael.isPointInsidePath
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     > Parameters
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) true, if point is inside the path
    \*/
    R.isPointInsidePath = function (path, x, y) {
        var bbox = R.pathBBox(path);
        return R.isPointInsideBBox(bbox, x, y) &&
               interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
    };
    R._removedFactory = function (methodname) {
        return function () {
            eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
        };
    };
    /*\
     * Raphael.pathBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given path
     > Parameters
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box
     o     y: (number) y coordinate of the left top point of the box
     o     x2: (number) x coordinate of the right bottom point of the box
     o     y2: (number) y coordinate of the right bottom point of the box
     o     width: (number) width of the box
     o     height: (number) height of the box
     o     cx: (number) x coordinate of the center of the box
     o     cy: (number) y coordinate of the center of the box
     o }
    \*/
    var pathDimensions = R.pathBBox = function (path) {
        var pth = paths(path);
        if (pth.bbox) {
            return clone(pth.bbox);
        }
        if (!path) {
            return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};
        }
        path = path2curve(path);
        var x = 0,
            y = 0,
            X = [],
            Y = [],
            p;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin[apply](0, X),
            ymin = mmin[apply](0, Y),
            xmax = mmax[apply](0, X),
            ymax = mmax[apply](0, Y),
            width = xmax - xmin,
            height = ymax - ymin,
                bb = {
                x: xmin,
                y: ymin,
                x2: xmax,
                y2: ymax,
                width: width,
                height: height,
                cx: xmin + width / 2,
                cy: ymin + height / 2
            };
        pth.bbox = clone(bb);
        return bb;
    },
        pathClone = function (pathArray) {
            var res = clone(pathArray);
            res.toString = R._path2string;
            return res;
        },
        pathToRelative = R._pathToRelative = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.rel) {
                return pathClone(pth.rel);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res.push(["M", x, y]);
            }
            for (var i = start, ii = pathArray.length; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);
                    switch (r[0]) {
                        case "a":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case "v":
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case "m":
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];
                    if (pa[0] == "m") {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                var len = res[i].length;
                switch (res[i][0]) {
                    case "z":
                        x = mx;
                        y = my;
                        break;
                    case "h":
                        x += +res[i][len - 1];
                        break;
                    case "v":
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }
            res.toString = R._path2string;
            pth.rel = pathClone(res);
            return res;
        },
        pathToAbsolute = R._pathToAbsolute = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.abs) {
                return pathClone(pth.abs);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            if (!pathArray || !pathArray.length) {
                return [["M", 0, 0]];
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ["M", x, y];
            }
            var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                res.push(r = []);
                pa = pathArray[i];
                if (pa[0] != upperCase.call(pa[0])) {
                    r[0] = upperCase.call(pa[0]);
                    switch (r[0]) {
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] + x);
                            r[7] = +(pa[7] + y);
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "R":
                            var dots = [x, y][concat](pa.slice(1));
                            for (var j = 2, jj = dots.length; j < jj; j++) {
                                dots[j] = +dots[j] + x;
                                dots[++j] = +dots[j] + y;
                            }
                            res.pop();
                            res = res[concat](catmullRom2bezier(dots, crz));
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:
                            for (j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +pa[j] + ((j % 2) ? x : y);
                            }
                    }
                } else if (pa[0] == "R") {
                    dots = [x, y][concat](pa.slice(1));
                    res.pop();
                    res = res[concat](catmullRom2bezier(dots, crz));
                    r = ["R"][concat](pa.slice(-2));
                } else {
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        r[k] = pa[k];
                    }
                }
                switch (r[0]) {
                    case "Z":
                        x = mx;
                        y = my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
            res.toString = R._path2string;
            pth.abs = pathClone(res);
            return res;
        },
        l2c = function (x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        },
        q2c = function (x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
                _23 = 2 / 3;
            return [
                    _13 * x1 + _23 * ax,
                    _13 * y1 + _23 * ay,
                    _13 * x2 + _23 * ax,
                    _13 * y2 + _23 * ay,
                    x2,
                    y2
                ];
        },
        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
                rad = PI / 180 * (+angle || 0),
                res = [],
                xy,
                rotate = cacher(function (x, y, rad) {
                    var X = x * math.cos(rad) - y * math.sin(rad),
                        Y = x * math.sin(rad) + y * math.cos(rad);
                    return {x: X, y: Y};
                });
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var cos = math.cos(PI / 180 * angle),
                    sin = math.sin(PI / 180 * angle),
                    x = (x1 - x2) / 2,
                    y = (y1 - y2) / 2;
                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                if (h > 1) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -1 : 1) *
                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / 2,
                    cy = k * -ry * x / rx + (y1 + y2) / 2,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);
                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2,
                    x2old = x2,
                    y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [m2, m3, m4][concat](res);
            } else {
                res = [m2, m3, m4][concat](res).join()[split](",");
                var newres = [];
                for (var i = 0, ii = res.length; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        },
        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t;
            return {
                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
            };
        },
        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
                c = p1x - c1x,
                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
                y = [p1y, p2y],
                x = [p1x, p2x],
                dot;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
            c = p1y - c1y;
            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            return {
                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
            };
        }),
        path2curve = R._path2curve = cacher(function (path, path2) {
            var pth = !path2 && paths(path);
            if (!path2 && pth.curve) {
                return pathClone(pth.curve);
            }
            var p = pathToAbsolute(path),
                p2 = path2 && pathToAbsolute(path2),
                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                processPath = function (path, d, pcom) {
                    var nx, ny, tq = {T:1, Q:1};
                    if (!path) {
                        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                    }
                    !(path[0] in tq) && (d.qx = d.qy = null);
                    switch (path[0]) {
                        case "M":
                            d.X = path[1];
                            d.Y = path[2];
                            break;
                        case "A":
                            path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                            break;
                        case "S":
                            if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                                nx = d.x * 2 - d.bx;          // And reflect the previous
                                ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                            }
                            else {                            // or some else or nothing
                                nx = d.x;
                                ny = d.y;
                            }
                            path = ["C", nx, ny][concat](path.slice(1));
                            break;
                        case "T":
                            if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                                d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                                d.qy = d.y * 2 - d.qy;        // to case "S".
                            }
                            else {                            // or something else or nothing
                                d.qx = d.x;
                                d.qy = d.y;
                            }
                            path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                            break;
                        case "Q":
                            d.qx = path[1];
                            d.qy = path[2];
                            path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                            break;
                        case "L":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                            break;
                        case "H":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                            break;
                        case "V":
                            path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                            break;
                        case "Z":
                            path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                            break;
                    }
                    return path;
                },
                fixArc = function (pp, i) {
                    if (pp[i].length > 7) {
                        pp[i].shift();
                        var pi = pp[i];
                        while (pi.length) {
                            pcoms1[i]="A"; // if created multiple C:s, their original seg is saved
                            p2 && (pcoms2[i]="A"); // the same as above
                            pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                        }
                        pp.splice(i, 1);
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                },
                fixM = function (path1, path2, a1, a2, i) {
                    if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                        path2.splice(i, 0, ["M", a2.x, a2.y]);
                        a1.bx = 0;
                        a1.by = 0;
                        a1.x = path1[i][1];
                        a1.y = path1[i][2];
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                },
                pcoms1 = [], // path commands of original path p
                pcoms2 = [], // path commands of original path p2
                pfirst = "", // temporary holder for original path command
                pcom = ""; // holder for previous path command of original path
            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                p[i] && (pfirst = p[i][0]); // save current path command

                if (pfirst != "C") // C is not saved yet, because it may be result of conversion
                {
                    pcoms1[i] = pfirst; // Save current path command
                    i && ( pcom = pcoms1[i-1]); // Get previous path command pcom
                }
                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

                if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
                // which may produce multiple C:s
                // so we have to make sure that C is also C in original path

                fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

                if (p2) { // the same procedures is done to p2
                    p2[i] && (pfirst = p2[i][0]);
                    if (pfirst != "C")
                    {
                        pcoms2[i] = pfirst;
                        i && (pcom = pcoms2[i-1]);
                    }
                    p2[i] = processPath(p2[i], attrs2, pcom);

                    if (pcoms2[i]!="A" && pfirst=="C") pcoms2[i]="C";

                    fixArc(p2, i);
                }
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                var seg = p[i],
                    seg2 = p2 && p2[i],
                    seglen = seg.length,
                    seg2len = p2 && seg2.length;
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }
            if (!p2) {
                pth.curve = pathClone(p);
            }
            return p2 ? [p, p2] : p;
        }, null, pathClone),
        parseDots = R._parseDots = cacher(function (gradient) {
            var dots = [];
            for (var i = 0, ii = gradient.length; i < ii; i++) {
                var dot = {},
                    par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                dot.color = R.getRGB(par[1]);
                if (dot.color.error) {
                    return null;
                }
                dot.opacity = dot.color.opacity;
                dot.color = dot.color.hex;
                par[2] && (dot.offset = par[2] + "%");
                dots.push(dot);
            }
            for (i = 1, ii = dots.length - 1; i < ii; i++) {
                if (!dots[i].offset) {
                    var start = toFloat(dots[i - 1].offset || 0),
                        end = 0;
                    for (var j = i + 1; j < ii; j++) {
                        if (dots[j].offset) {
                            end = dots[j].offset;
                            break;
                        }
                    }
                    if (!end) {
                        end = 100;
                        j = ii;
                    }
                    end = toFloat(end);
                    var d = (end - start) / (j - i + 1);
                    for (; i < j; i++) {
                        start += d;
                        dots[i].offset = start + "%";
                    }
                }
            }
            return dots;
        }),
        tear = R._tear = function (el, paper) {
            el == paper.top && (paper.top = el.prev);
            el == paper.bottom && (paper.bottom = el.next);
            el.next && (el.next.prev = el.prev);
            el.prev && (el.prev.next = el.next);
        },
        tofront = R._tofront = function (el, paper) {
            if (paper.top === el) {
                return;
            }
            tear(el, paper);
            el.next = null;
            el.prev = paper.top;
            paper.top.next = el;
            paper.top = el;
        },
        toback = R._toback = function (el, paper) {
            if (paper.bottom === el) {
                return;
            }
            tear(el, paper);
            el.next = paper.bottom;
            el.prev = null;
            paper.bottom.prev = el;
            paper.bottom = el;
        },
        insertafter = R._insertafter = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.top && (paper.top = el);
            el2.next && (el2.next.prev = el);
            el.next = el2.next;
            el.prev = el2;
            el2.next = el;
        },
        insertbefore = R._insertbefore = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.bottom && (paper.bottom = el);
            el2.prev && (el2.prev.next = el);
            el.prev = el2.prev;
            el2.prev = el;
            el.next = el2;
        },
        /*\
         * Raphael.toMatrix
         [ method ]
         **
         * Utility method
         **
         * Returns matrix of transformations applied to a given path
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (object) @Matrix
        \*/
        toMatrix = R.toMatrix = function (path, transform) {
            var bb = pathDimensions(path),
                el = {
                    _: {
                        transform: E
                    },
                    getBBox: function () {
                        return bb;
                    }
                };
            extractTransform(el, transform);
            return el.matrix;
        },
        /*\
         * Raphael.transformPath
         [ method ]
         **
         * Utility method
         **
         * Returns path transformed by a given transformation
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (string) path
        \*/
        transformPath = R.transformPath = function (path, transform) {
            return mapPath(path, toMatrix(path, transform));
        },
        extractTransform = R._extractTransform = function (el, tstr) {
            if (tstr == null) {
                return el._.transform;
            }
            tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
            var tdata = R.parseTransformString(tstr),
                deg = 0,
                dx = 0,
                dy = 0,
                sx = 1,
                sy = 1,
                _ = el._,
                m = new Matrix;
            _.transform = tdata || [];
            if (tdata) {
                for (var i = 0, ii = tdata.length; i < ii; i++) {
                    var t = tdata[i],
                        tlen = t.length,
                        command = Str(t[0]).toLowerCase(),
                        absolute = t[0] != command,
                        inver = absolute ? m.invert() : 0,
                        x1,
                        y1,
                        x2,
                        y2,
                        bb;
                    if (command == "t" && tlen == 3) {
                        if (absolute) {
                            x1 = inver.x(0, 0);
                            y1 = inver.y(0, 0);
                            x2 = inver.x(t[1], t[2]);
                            y2 = inver.y(t[1], t[2]);
                            m.translate(x2 - x1, y2 - y1);
                        } else {
                            m.translate(t[1], t[2]);
                        }
                    } else if (command == "r") {
                        if (tlen == 2) {
                            bb = bb || el.getBBox(1);
                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            deg += t[1];
                        } else if (tlen == 4) {
                            if (absolute) {
                                x2 = inver.x(t[2], t[3]);
                                y2 = inver.y(t[2], t[3]);
                                m.rotate(t[1], x2, y2);
                            } else {
                                m.rotate(t[1], t[2], t[3]);
                            }
                            deg += t[1];
                        }
                    } else if (command == "s") {
                        if (tlen == 2 || tlen == 3) {
                            bb = bb || el.getBBox(1);
                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            sx *= t[1];
                            sy *= t[tlen - 1];
                        } else if (tlen == 5) {
                            if (absolute) {
                                x2 = inver.x(t[3], t[4]);
                                y2 = inver.y(t[3], t[4]);
                                m.scale(t[1], t[2], x2, y2);
                            } else {
                                m.scale(t[1], t[2], t[3], t[4]);
                            }
                            sx *= t[1];
                            sy *= t[2];
                        }
                    } else if (command == "m" && tlen == 7) {
                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                    }
                    _.dirtyT = 1;
                    el.matrix = m;
                }
            }

            /*\
             * Element.matrix
             [ property (object) ]
             **
             * Keeps @Matrix object, which represents element transformation
            \*/
            el.matrix = m;

            _.sx = sx;
            _.sy = sy;
            _.deg = deg;
            _.dx = dx = m.e;
            _.dy = dy = m.f;

            if (sx == 1 && sy == 1 && !deg && _.bbox) {
                _.bbox.x += +dx;
                _.bbox.y += +dy;
            } else {
                _.dirtyT = 1;
            }
        },
        getEmpty = function (item) {
            var l = item[0];
            switch (l.toLowerCase()) {
                case "t": return [l, 0, 0];
                case "m": return [l, 1, 0, 0, 1, 0, 0];
                case "r": if (item.length == 4) {
                    return [l, 0, item[2], item[3]];
                } else {
                    return [l, 0];
                }
                case "s": if (item.length == 5) {
                    return [l, 1, 1, item[3], item[4]];
                } else if (item.length == 3) {
                    return [l, 1, 1];
                } else {
                    return [l, 1];
                }
            }
        },
        equaliseTransform = R._equaliseTransform = function (t1, t2) {
            t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
            t1 = R.parseTransformString(t1) || [];
            t2 = R.parseTransformString(t2) || [];
            var maxlength = mmax(t1.length, t2.length),
                from = [],
                to = [],
                i = 0, j, jj,
                tt1, tt2;
            for (; i < maxlength; i++) {
                tt1 = t1[i] || getEmpty(t2[i]);
                tt2 = t2[i] || getEmpty(tt1);
                if ((tt1[0] != tt2[0]) ||
                    (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                    (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                    ) {
                    return;
                }
                from[i] = [];
                to[i] = [];
                for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                    j in tt1 && (from[i][j] = tt1[j]);
                    j in tt2 && (to[i][j] = tt2[j]);
                }
            }
            return {
                from: from,
                to: to
            };
        };
    R._getContainer = function (x, y, w, h) {
        var container;
        container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
        if (container == null) {
            return;
        }
        if (container.tagName) {
            if (y == null) {
                return {
                    container: container,
                    width: container.style.pixelWidth || container.offsetWidth,
                    height: container.style.pixelHeight || container.offsetHeight
                };
            } else {
                return {
                    container: container,
                    width: y,
                    height: w
                };
            }
        }
        return {
            container: 1,
            x: x,
            y: y,
            width: w,
            height: h
        };
    };
    /*\
     * Raphael.pathToRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path to relative form
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
    R.pathToRelative = pathToRelative;
    R._engine = {};
    /*\
     * Raphael.path2curve
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic bezier curves.
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
    R.path2curve = path2curve;
    /*\
     * Raphael.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix based on given parameters.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     = (object) @Matrix
    \*/
    R.matrix = function (a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
    function Matrix(a, b, c, d, e, f) {
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function (matrixproto) {
        /*\
         * Matrix.add
         [ method ]
         **
         * Adds given matrix to existing one.
         > Parameters
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         or
         - matrix (object) @Matrix
        \*/
        matrixproto.add = function (a, b, c, d, e, f) {
            var out = [[], [], []],
                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                x, y, z, res;

            if (a && a instanceof Matrix) {
                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
            }

            for (x = 0; x < 3; x++) {
                for (y = 0; y < 3; y++) {
                    res = 0;
                    for (z = 0; z < 3; z++) {
                        res += m[x][z] * matrix[z][y];
                    }
                    out[x][y] = res;
                }
            }
            this.a = out[0][0];
            this.b = out[1][0];
            this.c = out[0][1];
            this.d = out[1][1];
            this.e = out[0][2];
            this.f = out[1][2];
        };
        /*\
         * Matrix.invert
         [ method ]
         **
         * Returns inverted version of the matrix
         = (object) @Matrix
        \*/
        matrixproto.invert = function () {
            var me = this,
                x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /*\
         * Matrix.clone
         [ method ]
         **
         * Returns copy of the matrix
         = (object) @Matrix
        \*/
        matrixproto.clone = function () {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         > Parameters
         - x (number)
         - y (number)
        \*/
        matrixproto.translate = function (x, y) {
            this.add(1, 0, 0, 1, x, y);
        };
        /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         > Parameters
         - x (number)
         - y (number) #optional
         - cx (number) #optional
         - cy (number) #optional
        \*/
        matrixproto.scale = function (x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
            this.add(x, 0, 0, y, 0, 0);
            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        };
        /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         > Parameters
         - a (number)
         - x (number)
         - y (number)
        \*/
        matrixproto.rotate = function (a, x, y) {
            a = R.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +math.cos(a).toFixed(9),
                sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            this.add(1, 0, 0, 1, -x, -y);
        };
        /*\
         * Matrix.x
         [ method ]
         **
         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         > Parameters
         - x (number)
         - y (number)
         = (number) x
        \*/
        matrixproto.x = function (x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /*\
         * Matrix.y
         [ method ]
         **
         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         > Parameters
         - x (number)
         - y (number)
         = (number) y
        \*/
        matrixproto.y = function (x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function (i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function () {
            return R.svg ?
                "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
                [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
        };
        matrixproto.toFilter = function () {
            return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
                ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
                ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
        };
        matrixproto.offset = function () {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
        \*/
        matrixproto.split = function () {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.c], [this.b, this.d]];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            // rotation
            var sin = -row[0][1],
                cos = row[1][1];
            if (cos < 0) {
                out.rotate = R.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = R.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Return transform string that represents given matrix
         = (string) transform string
        \*/
        matrixproto.toTransformString = function (shorter) {
            var s = shorter || this[split]();
            if (s.isSimple) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                        (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                        (s.rotate ? "r" + [s.rotate, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);

    var preventDefault = function () {
        this.returnValue = false;
    },
    preventTouch = function () {
        return this.originalEvent.preventDefault();
    },
    stopPropagation = function () {
        this.cancelBubble = true;
    },
    stopTouch = function () {
        return this.originalEvent.stopPropagation();
    },
    getEventPosition = function (e) {
        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

        return {
            x: e.clientX + scrollX,
            y: e.clientY + scrollY
        };
    },
    addEvent = (function () {
        if (g.doc.addEventListener) {
            return function (obj, type, fn, element) {
                var f = function (e) {
                    var pos = getEventPosition(e);
                    return fn.call(element, e, pos.x, pos.y);
                };
                obj.addEventListener(type, f, false);

                if (supportsTouch && touchMap[type]) {
                    var _f = function (e) {
                        var pos = getEventPosition(e),
                            olde = e;

                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                            if (e.targetTouches[i].target == obj) {
                                e = e.targetTouches[i];
                                e.originalEvent = olde;
                                e.preventDefault = preventTouch;
                                e.stopPropagation = stopTouch;
                                break;
                            }
                        }

                        return fn.call(element, e, pos.x, pos.y);
                    };
                    obj.addEventListener(touchMap[type], _f, false);
                }

                return function () {
                    obj.removeEventListener(type, f, false);

                    if (supportsTouch && touchMap[type])
                        obj.removeEventListener(touchMap[type], _f, false);

                    return true;
                };
            };
        } else if (g.doc.attachEvent) {
            return function (obj, type, fn, element) {
                var f = function (e) {
                    e = e || g.win.event;
                    var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                        x = e.clientX + scrollX,
                        y = e.clientY + scrollY;
                    e.preventDefault = e.preventDefault || preventDefault;
                    e.stopPropagation = e.stopPropagation || stopPropagation;
                    return fn.call(element, e, x, y);
                };
                obj.attachEvent("on" + type, f);
                var detacher = function () {
                    obj.detachEvent("on" + type, f);
                    return true;
                };
                return detacher;
            };
        }
    })(),
    drag = [],
    dragMove = function (e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
            dragi,
            j = drag.length;
        while (j--) {
            dragi = drag[j];
            if (supportsTouch && e.touches) {
                var i = e.touches.length,
                    touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }
            var node = dragi.el.node,
                o,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;
            g.win.opera && parent.removeChild(node);
            node.style.display = "none";
            o = dragi.el.paper.getElementByPoint(x, y);
            node.style.display = display;
            g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = function (e) {
        R.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;
        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    },
    /*\
     * Raphael.el
     [ property (object) ]
     **
     * You can add your own method to elements. This is useful when you want to hack default functionality or
     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
     * you can redefine element method at any time. Expending element methods wouldnt affect set.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | // then use it
     | paper.circle(100, 100, 20).red();
    \*/
    elproto = R.el = {};
    /*\
     * Element.click
     [ method ]
     **
     * Adds event handler for click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes event handler for click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds event handler for double click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes event handler for double click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds event handler for mousedown for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes event handler for mousedown for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds event handler for mousemove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes event handler for mousemove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds event handler for mouseout for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes event handler for mouseout for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds event handler for mouseover for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes event handler for mouseover for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds event handler for mouseup for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes event handler for mouseup for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds event handler for touchstart for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes event handler for touchstart for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds event handler for touchmove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes event handler for touchmove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchend
     [ method ]
     **
     * Adds event handler for touchend for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes event handler for touchend for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds event handler for touchcancel for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes event handler for touchcancel for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
    for (var i = events.length; i--;) {
        (function (eventName) {
            R[eventName] = elproto[eventName] = function (fn, scope) {
                if (R.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});
                }
                return this;
            };
            R["un" + eventName] = elproto["un" + eventName] = function (fn) {
                var events = this.events || [],
                    l = events.length;
                while (l--){
                    if (events[l].name == eventName && (R.is(fn, "undefined") || events[l].f == fn)) {
                        events[l].unbind();
                        events.splice(l, 1);
                        !events.length && delete this.events;
                    }
                }
                return this;
            };
        })(events[i]);
    }

    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value associated with given key.
     **
     * See also @Element.removeData
     > Parameters
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     * or, if key and value are not specified:
     = (object) Key/value pairs for all the data associated with the element.
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/
    elproto.data = function (key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0) {
            return data;
        }
        if (arguments.length == 1) {
            if (R.is(key, "object")) {
                for (var i in key) if (key[has](i)) {
                    this.data(i, key[i]);
                }
                return this;
            }
            eve("raphael.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("raphael.data.set." + this.id, this, value, key);
        return this;
    };
    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     > Parameters
     - key (string) #optional key
     = (object) @Element
    \*/
    elproto.removeData = function (key) {
        if (key == null) {
            delete eldata[this.id];
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };
     /*\
     * Element.getData
     [ method ]
     **
     * Retrieves the element data
     = (object) data
    \*/
    elproto.getData = function () {
        return clone(eldata[this.id] || {});
    };
    /*\
     * Element.hover
     [ method ]
     **
     * Adds event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /*\
     * Element.unhover
     [ method ]
     **
     * Removes event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];
    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for drag of the element.
     > Parameters
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
     * `drag.over.<id>` will be fired as well.
     *
     * Start event and start handler will be called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler will be called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler will be called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        function start(e) {
            (e.originalEvent || e).preventDefault();
            var x = e.clientX,
                y = e.clientY,
                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
            this._drag.id = e.identifier;
            if (supportsTouch && e.touches) {
                var i = e.touches.length, touch;
                while (i--) {
                    touch = e.touches[i];
                    this._drag.id = touch.identifier;
                    if (touch.identifier == this._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        break;
                    }
                }
            }
            this._drag.x = x + scrollX;
            this._drag.y = y + scrollY;
            !drag.length && R.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
            onstart && eve.on("raphael.drag.start." + this.id, onstart);
            onmove && eve.on("raphael.drag.move." + this.id, onmove);
            onend && eve.on("raphael.drag.end." + this.id, onend);
            eve("raphael.drag.start." + this.id, start_scope || move_scope || this, this._drag.x, this._drag.y, e);
        }
        this._drag = {};
        draggable.push({el: this, start: start});
        this.mousedown(start);
        return this;
    };
    /*\
     * Element.onDragOver
     [ method ]
     **
     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
     > Parameters
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/
    elproto.onDragOver = function (f) {
        f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
    };
    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from given element.
    \*/
    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) if (draggable[i].el == this) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            eve.unbind("raphael.drag.*." + this.id);
        }
        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
        drag = [];
    };
    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) Raphal element object with type circle
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
    \*/
    paperproto.circle = function (x, y, r) {
        var out = R._engine.circle(this, x || 0, y || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle.
     **
     > Parameters
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - r (number) #optional radius for rounded corners, default is 0
     = (object) Raphal element object with type rect
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/
    paperproto.rect = function (x, y, w, h, r) {
        var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) Raphal element object with type ellipse
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/
    paperproto.ellipse = function (x, y, rx, ry) {
        var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.path
     [ method ]
     **
     * Creates a path element by given path data string.
     > Parameters
     - pathString (string) #optional path string in SVG format.
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
     | "M10,20L30,40"
     * Here we can see two commands: M, with arguments `(10, 20)` and L with arguments `(30, 40)`. Upper case letter mean command is absolute, lower caserelative.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * Catmull-Rom curveto is a not standard SVG command and added in 2.0 to make life easier.
     * Note: there is a special case when path consist of just three commands: M10,10Rz. In this case path will smoothly connects to its beginning.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
     * For example of path strings, check out these icons: http://raphaeljs.com/icons/
    \*/
    paperproto.path = function (pathString) {
        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
        var out = R._engine.path(R.format[apply](R, arguments), this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.image
     [ method ]
     **
     * Embeds an image into the surface.
     **
     > Parameters
     **
     - src (string) URI of the source image
     - x (number) x coordinate position
     - y (number) y coordinate position
     - width (number) width of the image
     - height (number) height of the image
     = (object) Raphal element object with type image
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/
    paperproto.image = function (src, x, y, w, h) {
        var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string. If you need line breaks, put \n in the string.
     **
     > Parameters
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string) The text string to draw
     = (object) Raphal element object with type text
     **
     > Usage
     | var t = paper.text(50, 50, "Raphal\nkicks\nbutt!");
    \*/
    paperproto.text = function (x, y, text) {
        var out = R._engine.text(this, x || 0, y || 0, Str(text));
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.set
     [ method ]
     **
     * Creates array-like object to keep and operate several elements at once.
     * Warning: it doesnt create any elements for itself in the page, it just groups existing elements.
     * Sets act as pseudo elements  all methods available to an element can be used on a set.
     = (object) array-like object that represents set of elements
     **
     > Usage
     | var st = paper.set();
     | st.push(
     |     paper.circle(10, 10, 5),
     |     paper.circle(30, 10, 5)
     | );
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
    paperproto.set = function (itemsArray) {
        !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
        var out = new Set(itemsArray);
        this.__set__ && this.__set__.push(out);
        out["paper"] = this;
        out["type"] = "set";
        return out;
    };
    /*\
     * Paper.setStart
     [ method ]
     **
     * Creates @Paper.set. All elements that will be created after calling this method and before calling
     * @Paper.setFinish will be added to the set.
     **
     > Usage
     | paper.setStart();
     | paper.circle(10, 10, 5),
     | paper.circle(30, 10, 5)
     | var st = paper.setFinish();
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
    paperproto.setStart = function (set) {
        this.__set__ = set || this.set();
    };
    /*\
     * Paper.setFinish
     [ method ]
     **
     * See @Paper.setStart. This method finishes catching and returns resulting set.
     **
     = (object) set
    \*/
    paperproto.setFinish = function (set) {
        var out = this.__set__;
        delete this.__set__;
        return out;
    };
    /*\
     * Paper.getSize
     [ method ]
     **
     * Obtains current paper actual size.
     **
     = (object)
     \*/
    paperproto.getSize = function () {
        var container = this.canvas.parentNode;
        return {
            width: container.offsetWidth,
            height: container.offsetHeight
                };
        };
    /*\
     * Paper.setSize
     [ method ]
     **
     * If you need to change dimensions of the canvas call this method
     **
     > Parameters
     **
     - width (number) new width of the canvas
     - height (number) new height of the canvas
    \*/
    paperproto.setSize = function (width, height) {
        return R._engine.setSize.call(this, width, height);
    };
    /*\
     * Paper.setViewBox
     [ method ]
     **
     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
     * specifying new boundaries.
     **
     > Parameters
     **
     - x (number) new x position, default is `0`
     - y (number) new y position, default is `0`
     - w (number) new width of the canvas
     - h (number) new height of the canvas
     - fit (boolean) `true` if you want graphics to fit into new boundary box
    \*/
    paperproto.setViewBox = function (x, y, w, h, fit) {
        return R._engine.setViewBox.call(this, x, y, w, h, fit);
    };
    /*\
     * Paper.top
     [ property ]
     **
     * Points to the topmost element on the paper
    \*/
    /*\
     * Paper.bottom
     [ property ]
     **
     * Points to the bottom element on the paper
    \*/
    paperproto.top = paperproto.bottom = null;
    /*\
     * Paper.raphael
     [ property ]
     **
     * Points to the @Raphael object/function
    \*/
    paperproto.raphael = R;
    var getOffset = function (elem) {
        var box = elem.getBoundingClientRect(),
            doc = elem.ownerDocument,
            body = doc.body,
            docElem = doc.documentElement,
            clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
            top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };
    /*\
     * Paper.getElementByPoint
     [ method ]
     **
     * Returns you topmost element under given point.
     **
     = (object) Raphal element object
     > Parameters
     **
     - x (number) x coordinate from the top left corner of the window
     - y (number) y coordinate from the top left corner of the window
     > Usage
     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
    \*/
    paperproto.getElementByPoint = function (x, y) {
        var paper = this,
            svg = paper.canvas,
            target = g.doc.elementFromPoint(x, y);
        if (g.win.opera && target.tagName == "svg") {
            var so = getOffset(svg),
                sr = svg.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = 1;
            var hits = svg.getIntersectionList(sr, null);
            if (hits.length) {
                target = hits[hits.length - 1];
            }
        }
        if (!target) {
            return null;
        }
        while (target.parentNode && target != svg.parentNode && !target.raphael) {
            target = target.parentNode;
        }
        target == paper.canvas.parentNode && (target = svg);
        target = target && target.raphael ? paper.getById(target.raphaelid) : null;
        return target;
    };

    /*\
     * Paper.getElementsByBBox
     [ method ]
     **
     * Returns set of elements that have an intersecting bounding box
     **
     > Parameters
     **
     - bbox (object) bbox to check with
     = (object) @Set
     \*/
    paperproto.getElementsByBBox = function (bbox) {
        var set = this.set();
        this.forEach(function (el) {
            if (R.isBBoxIntersect(el.getBBox(), bbox)) {
                set.push(el);
            }
        });
        return set;
    };

    /*\
     * Paper.getById
     [ method ]
     **
     * Returns you element by its internal ID.
     **
     > Parameters
     **
     - id (number) id
     = (object) Raphal element object
    \*/
    paperproto.getById = function (id) {
        var bot = this.bottom;
        while (bot) {
            if (bot.id == id) {
                return bot;
            }
            bot = bot.next;
        }
        return null;
    };
    /*\
     * Paper.forEach
     [ method ]
     **
     * Executes given function for each element on the paper
     *
     * If callback function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Paper object
     > Usage
     | paper.forEach(function (el) {
     |     el.attr({ stroke: "blue" });
     | });
    \*/
    paperproto.forEach = function (callback, thisArg) {
        var bot = this.bottom;
        while (bot) {
            if (callback.call(thisArg, bot) === false) {
                return this;
            }
            bot = bot.next;
        }
        return this;
    };
    /*\
     * Paper.getElementsByPoint
     [ method ]
     **
     * Returns set of elements that have common point inside
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (object) @Set
    \*/
    paperproto.getElementsByPoint = function (x, y) {
        var set = this.set();
        this.forEach(function (el) {
            if (el.isPointInside(x, y)) {
                set.push(el);
            }
        });
        return set;
    };
    function x_y() {
        return this.x + S + this.y;
    }
    function x_y_w_h() {
        return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
    }
    /*\
     * Element.isPointInside
     [ method ]
     **
     * Determine if given point is inside this elements shape
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point inside the shape
    \*/
    elproto.isPointInside = function (x, y) {
        var rp = this.realPath = getPath[this.type](this);
        if (this.attr('transform') && this.attr('transform').length) {
            rp = R.transformPath(rp, this.attr('transform'));
        }
        return R.isPointInsidePath(rp, x, y);
    };
    /*\
     * Element.getBBox
     [ method ]
     **
     * Return bounding box for a given element
     **
     > Parameters
     **
     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
     = (object) Bounding box object:
     o {
     o     x: (number) top left corner x
     o     y: (number) top left corner y
     o     x2: (number) bottom right corner x
     o     y2: (number) bottom right corner y
     o     width: (number) width
     o     height: (number) height
     o }
    \*/
    elproto.getBBox = function (isWithoutTransform) {
        if (this.removed) {
            return {};
        }
        var _ = this._;
        if (isWithoutTransform) {
            if (_.dirty || !_.bboxwt) {
                this.realPath = getPath[this.type](this);
                _.bboxwt = pathDimensions(this.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = 0;
            }
            return _.bboxwt;
        }
        if (_.dirty || _.dirtyT || !_.bbox) {
            if (_.dirty || !this.realPath) {
                _.bboxwt = 0;
                this.realPath = getPath[this.type](this);
            }
            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = 0;
        }
        return _.bbox;
    };
    /*\
     * Element.clone
     [ method ]
     **
     = (object) clone of a given element
     **
    \*/
    elproto.clone = function () {
        if (this.removed) {
            return null;
        }
        var out = this.paper[this.type]().attr(this.attr());
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Element.glow
     [ method ]
     **
     * Return set of elements that create glow-like effect around given element. See @Paper.set.
     *
     * Note: Glow is not connected to the element. If you change element attributes it wont adjust itself.
     **
     > Parameters
     **
     - glow (object) #optional parameters object with all properties optional:
     o {
     o     width (number) size of the glow, default is `10`
     o     fill (boolean) will it be filled, default is `false`
     o     opacity (number) opacity, default is `0.5`
     o     offsetx (number) horizontal offset, default is `0`
     o     offsety (number) vertical offset, default is `0`
     o     color (string) glow colour, default is `black`
     o }
     = (object) @Paper.set of elements that represents glow
    \*/
    elproto.glow = function (glow) {
        if (this.type == "text") {
            return null;
        }
        glow = glow || {};
        var s = {
            width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
            fill: glow.fill || false,
            opacity: glow.opacity == null ? .5 : glow.opacity,
            offsetx: glow.offsetx || 0,
            offsety: glow.offsety || 0,
            color: glow.color || "#000"
        },
            c = s.width / 2,
            r = this.paper,
            out = r.set(),
            path = this.realPath || getPath[this.type](this);
        path = this.matrix ? mapPath(path, this.matrix) : path;
        for (var i = 1; i < c + 1; i++) {
            out.push(r.path(path).attr({
                stroke: s.color,
                fill: s.fill ? s.color : "none",
                "stroke-linejoin": "round",
                "stroke-linecap": "round",
                "stroke-width": +(s.width / c * i).toFixed(3),
                opacity: +(s.opacity / c).toFixed(3)
            }));
        }
        return out.insertBefore(this).translate(s.offsetx, s.offsety);
    };
    var curveslengths = {},
    getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) {
            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        } else {
            return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
        }
    },
    getLengthFactory = function (istotal, subpath) {
        return function (path, length, onlystart) {
            path = path2curve(path);
            var x, y, p, l, sp = "", subpaths = {}, point,
                len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                            if (onlystart) {return sp;}
                            subpaths.start = sp;
                            sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return {x: point.x, y: point.y, alpha: point.alpha};
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
            return point;
        };
    };
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    /*\
     * Raphael.getTotalLength
     [ method ]
     **
     * Returns length of the given path in pixels.
     **
     > Parameters
     **
     - path (string) SVG path string.
     **
     = (number) length.
    \*/
    R.getTotalLength = getTotalLength;
    /*\
     * Raphael.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path.
     **
     > Parameters
     **
     - path (string) SVG path string
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/
    R.getPointAtLength = getPointAtLength;
    /*\
     * Raphael.getSubpath
     [ method ]
     **
     * Return subpath of a given path from given length to given length.
     **
     > Parameters
     **
     - path (string) SVG path string
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/
    R.getSubpath = function (path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns length of the path in pixels. Only works for element of path type.
     = (number) length.
    \*/
    elproto.getTotalLength = function () {
        var path = this.getPath();
        if (!path) {
            return;
        }

        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }

        return getTotalLength(path);
    };
    /*\
     * Element.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path. Only works for element of path type.
     **
     > Parameters
     **
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/
    elproto.getPointAtLength = function (length) {
        var path = this.getPath();
        if (!path) {
            return;
        }

        return getPointAtLength(path, length);
    };
    /*\
     * Element.getPath
     [ method ]
     **
     * Returns path of the element. Only works for elements of path type and simple elements like circle.
     = (object) path
     **
    \*/
    elproto.getPath = function () {
        var path,
            getPath = R._getPath[this.type];

        if (this.type == "text" || this.type == "set") {
            return;
        }

        if (getPath) {
            path = getPath(this);
        }

        return path;
    };
    /*\
     * Element.getSubpath
     [ method ]
     **
     * Return subpath of a given element from given length to given length. Only works for element of path type.
     **
     > Parameters
     **
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/
    elproto.getSubpath = function (from, to) {
        var path = this.getPath();
        if (!path) {
            return;
        }

        return R.getSubpath(path, from, to);
    };
    /*\
     * Raphael.easing_formulas
     [ property ]
     **
     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
     # <ul>
     #     <li>linear</li>
     #     <li>&lt; or easeIn or ease-in</li>
     #     <li>> or easeOut or ease-out</li>
     #     <li>&lt;> or easeInOut or ease-in-out</li>
     #     <li>backIn or back-in</li>
     #     <li>backOut or back-out</li>
     #     <li>elastic</li>
     #     <li>bounce</li>
     # </ul>
     # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
    \*/
    var ef = R.easing_formulas = {
        linear: function (n) {
            return n;
        },
        "<": function (n) {
            return pow(n, 1.7);
        },
        ">": function (n) {
            return pow(n, .48);
        },
        "<>": function (n) {
            var q = .48 - n / 1.04,
                Q = math.sqrt(.1734 + q * q),
                x = Q - q,
                X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                y = -Q - q,
                Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                t = X + Y + .5;
            return (1 - t) * 3 * t * t + t * t * t;
        },
        backIn: function (n) {
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut: function (n) {
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic: function (n) {
            if (n == !!n) {
                return n;
            }
            return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
        },
        bounce: function (n) {
            var s = 7.5625,
                p = 2.75,
                l;
            if (n < (1 / p)) {
                l = s * n * n;
            } else {
                if (n < (2 / p)) {
                    n -= (1.5 / p);
                    l = s * n * n + .75;
                } else {
                    if (n < (2.5 / p)) {
                        n -= (2.25 / p);
                        l = s * n * n + .9375;
                    } else {
                        n -= (2.625 / p);
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        }
    };
    ef.easeIn = ef["ease-in"] = ef["<"];
    ef.easeOut = ef["ease-out"] = ef[">"];
    ef.easeInOut = ef["ease-in-out"] = ef["<>"];
    ef["back-in"] = ef.backIn;
    ef["back-out"] = ef.backOut;

    var animationElements = [],
        requestAnimFrame = window.requestAnimationFrame       ||
                           window.webkitRequestAnimationFrame ||
                           window.mozRequestAnimationFrame    ||
                           window.oRequestAnimationFrame      ||
                           window.msRequestAnimationFrame     ||
                           function (callback) {
                               setTimeout(callback, 16);
                           },
        animation = function () {
            var Now = +new Date,
                l = 0;
            for (; l < animationElements.length; l++) {
                var e = animationElements[l];
                if (e.el.removed || e.paused) {
                    continue;
                }
                var time = Now - e.start,
                    ms = e.ms,
                    easing = e.easing,
                    from = e.from,
                    diff = e.diff,
                    to = e.to,
                    t = e.t,
                    that = e.el,
                    set = {},
                    now,
                    init = {},
                    key;
                if (e.initstatus) {
                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                    e.status = e.initstatus;
                    delete e.initstatus;
                    e.stop && animationElements.splice(l--, 1);
                } else {
                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
                }
                if (time < 0) {
                    continue;
                }
                if (time < ms) {
                    var pos = easing(time / ms);
                    for (var attr in from) if (from[has](attr)) {
                        switch (availableAnimAttrs[attr]) {
                            case nu:
                                now = +from[attr] + pos * ms * diff[attr];
                                break;
                            case "colour":
                                now = "rgb(" + [
                                    upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                    upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                    upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                ].join(",") + ")";
                                break;
                            case "path":
                                now = [];
                                for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                    now[i] = [from[attr][i][0]];
                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                    }
                                    now[i] = now[i].join(S);
                                }
                                now = now.join(S);
                                break;
                            case "transform":
                                if (diff[attr].real) {
                                    now = [];
                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                        now[i] = [from[attr][i][0]];
                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                        }
                                    }
                                } else {
                                    var get = function (i) {
                                        return +from[attr][i] + pos * ms * diff[attr][i];
                                    };
                                    // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                    now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                }
                                break;
                            case "csv":
                                if (attr == "clip-rect") {
                                    now = [];
                                    i = 4;
                                    while (i--) {
                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                    }
                                }
                                break;
                            default:
                                var from2 = [][concat](from[attr]);
                                now = [];
                                i = that.paper.customAttributes[attr].length;
                                while (i--) {
                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
                                }
                                break;
                        }
                        set[attr] = now;
                    }
                    that.attr(set);
                    (function (id, that, anim) {
                        setTimeout(function () {
                            eve("raphael.anim.frame." + id, that, anim);
                        });
                    })(that.id, that, e.anim);
                } else {
                    (function(f, el, a) {
                        setTimeout(function() {
                            eve("raphael.anim.frame." + el.id, el, a);
                            eve("raphael.anim.finish." + el.id, el, a);
                            R.is(f, "function") && f.call(el);
                        });
                    })(e.callback, that, e.anim);
                    that.attr(to);
                    animationElements.splice(l--, 1);
                    if (e.repeat > 1 && !e.next) {
                        for (key in to) if (to[has](key)) {
                            init[key] = e.totalOrigin[key];
                        }
                        e.el.attr(init);
                        runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                    }
                    if (e.next && !e.stop) {
                        runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                    }
                }
            }
            animationElements.length && requestAnimFrame(animation);
        },
        upto255 = function (color) {
            return color > 255 ? 255 : color < 0 ? 0 : color;
        };
    /*\
     * Element.animateWith
     [ method ]
     **
     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
     **
     > Parameters
     **
     - el (object) element to sync with
     - anim (object) animation to sync with
     - params (object) #optional final attributes for the element, see also @Element.attr
     - ms (number) #optional number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - element (object) element to sync with
     - anim (object) animation to sync with
     - animation (object) #optional animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
    elproto.animateWith = function (el, anim, params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
            x, y;
        runAnimation(a, element, a.percents[0], null, element.attr());
        for (var i = 0, ii = animationElements.length; i < ii; i++) {
            if (animationElements[i].anim == anim && animationElements[i].el == el) {
                animationElements[ii - 1].start = animationElements[i].start;
                break;
            }
        }
        return element;
        //
        //
        // var a = params ? R.animation(params, ms, easing, callback) : anim,
        //     status = element.status(anim);
        // return this.animate(a).status(a, status * anim.ms / a.ms);
    };
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        var cx = 3 * p1x,
            bx = 3 * (p2x - p1x) - cx,
            ax = 1 - cx - bx,
            cy = 3 * p1y,
            by = 3 * (p2y - p1y) - cy,
            ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            var t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            var t0, t1, t2, x2, d2, i;
            for(t2 = x, i = 0; i < 8; i++) {
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) {
                    return t2;
                }
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) {
                    break;
                }
                t2 = t2 - x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) {
                return t0;
            }
            if (t2 > t1) {
                return t1;
            }
            while (t0 < t1) {
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) {
                    return t2;
                }
                if (x > x2) {
                    t0 = t2;
                } else {
                    t1 = t2;
                }
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function (f) {
        f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
        return this;
    };
    function Animation(anim, ms) {
        var percents = [],
            newAnim = {};
        this.ms = ms;
        this.times = 1;
        if (anim) {
            for (var attr in anim) if (anim[has](attr)) {
                newAnim[toFloat(attr)] = anim[attr];
                percents.push(toFloat(attr));
            }
            percents.sort(sortByNumber);
        }
        this.anim = newAnim;
        this.top = percents[percents.length - 1];
        this.percents = percents;
    }
    /*\
     * Animation.delay
     [ method ]
     **
     * Creates a copy of existing animation object with given delay.
     **
     > Parameters
     **
     - delay (number) number of ms to pass between animation start and actual animation
     **
     = (object) new altered Animation object
     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
     | circle1.animate(anim); // run the given animation immediately
     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
    \*/
    Animation.prototype.delay = function (delay) {
        var a = new Animation(this.anim, this.ms);
        a.times = this.times;
        a.del = +delay || 0;
        return a;
    };
    /*\
     * Animation.repeat
     [ method ]
     **
     * Creates a copy of existing animation object with given repetition.
     **
     > Parameters
     **
     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
     **
     = (object) new altered Animation object
    \*/
    Animation.prototype.repeat = function (times) {
        var a = new Animation(this.anim, this.ms);
        a.del = this.del;
        a.times = math.floor(mmax(times, 0)) || 1;
        return a;
    };
    function runAnimation(anim, element, percent, status, totalOrigin, times) {
        percent = toFloat(percent);
        var params,
            isInAnim,
            isInAnimSet,
            percents = [],
            next,
            prev,
            timestamp,
            ms = anim.ms,
            from = {},
            to = {},
            diff = {};
        if (status) {
            for (i = 0, ii = animationElements.length; i < ii; i++) {
                var e = animationElements[i];
                if (e.el.id == element.id && e.anim == anim) {
                    if (e.percent != percent) {
                        animationElements.splice(i, 1);
                        isInAnimSet = 1;
                    } else {
                        isInAnim = e;
                    }
                    element.attr(e.totalOrigin);
                    break;
                }
            }
        } else {
            status = +to; // NaN
        }
        for (var i = 0, ii = anim.percents.length; i < ii; i++) {
            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - 1] || 0;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + 1];
                params = anim.anim[percent];
                break;
            } else if (status) {
                element.attr(anim.anim[anim.percents[i]]);
            }
        }
        if (!params) {
            return;
        }
        if (!isInAnim) {
            for (var attr in params) if (params[has](attr)) {
                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                    from[attr] = element.attr(attr);
                    (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                    to[attr] = params[attr];
                    switch (availableAnimAttrs[attr]) {
                        case nu:
                            diff[attr] = (to[attr] - from[attr]) / ms;
                            break;
                        case "colour":
                            from[attr] = R.getRGB(from[attr]);
                            var toColour = R.getRGB(to[attr]);
                            diff[attr] = {
                                r: (toColour.r - from[attr].r) / ms,
                                g: (toColour.g - from[attr].g) / ms,
                                b: (toColour.b - from[attr].b) / ms
                            };
                            break;
                        case "path":
                            var pathes = path2curve(from[attr], to[attr]),
                                toPath = pathes[1];
                            from[attr] = pathes[0];
                            diff[attr] = [];
                            for (i = 0, ii = from[attr].length; i < ii; i++) {
                                diff[attr][i] = [0];
                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                }
                            }
                            break;
                        case "transform":
                            var _ = element._,
                                eq = equaliseTransform(_[attr], to[attr]);
                            if (eq) {
                                from[attr] = eq.from;
                                to[attr] = eq.to;
                                diff[attr] = [];
                                diff[attr].real = true;
                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                    diff[attr][i] = [from[attr][i][0]];
                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                    }
                                }
                            } else {
                                var m = (element.matrix || new Matrix),
                                    to2 = {
                                        _: {transform: _.transform},
                                        getBBox: function () {
                                            return element.getBBox(1);
                                        }
                                    };
                                from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                ];
                                extractTransform(to2, to[attr]);
                                to[attr] = to2._.transform;
                                diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms
                                ];
                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                // extractTransform(to2, to[attr]);
                                // diff[attr] = [
                                //     (to2._.sx - _.sx) / ms,
                                //     (to2._.sy - _.sy) / ms,
                                //     (to2._.deg - _.deg) / ms,
                                //     (to2._.dx - _.dx) / ms,
                                //     (to2._.dy - _.dy) / ms
                                // ];
                            }
                            break;
                        case "csv":
                            var values = Str(params[attr])[split](separator),
                                from2 = Str(from[attr])[split](separator);
                            if (attr == "clip-rect") {
                                from[attr] = from2;
                                diff[attr] = [];
                                i = from2.length;
                                while (i--) {
                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                }
                            }
                            to[attr] = values;
                            break;
                        default:
                            values = [][concat](params[attr]);
                            from2 = [][concat](from[attr]);
                            diff[attr] = [];
                            i = element.paper.customAttributes[attr].length;
                            while (i--) {
                                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                            }
                            break;
                    }
                }
            }
            var easing = params.easing,
                easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy.length == 5) {
                    var curve = easyeasy;
                    easyeasy = function (t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else {
                    easyeasy = pipe;
                }
            }
            timestamp = params.start || anim.start || +new Date;
            e = {
                anim: anim,
                percent: percent,
                timestamp: timestamp,
                start: timestamp + (anim.del || 0),
                status: 0,
                initstatus: status || 0,
                stop: false,
                ms: ms,
                easing: easyeasy,
                from: from,
                diff: diff,
                to: to,
                el: element,
                callback: params.callback,
                prev: prev,
                next: next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin: totalOrigin
            };
            animationElements.push(e);
            if (status && !isInAnim && !isInAnimSet) {
                e.stop = true;
                e.start = new Date - ms * status;
                if (animationElements.length == 1) {
                    return animation();
                }
            }
            if (isInAnimSet) {
                e.start = new Date - e.ms * status;
            }
            animationElements.length == 1 && requestAnimFrame(animation);
        } else {
            isInAnim.initstatus = status;
            isInAnim.start = new Date - isInAnim.ms * status;
        }
        eve("raphael.anim.start." + element.id, element, anim);
    }
    /*\
     * Raphael.animation
     [ method ]
     **
     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
     * See also @Animation.delay and @Animation.repeat methods.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     **
     = (object) @Animation
    \*/
    R.animation = function (params, ms, easing, callback) {
        if (params instanceof Animation) {
            return params;
        }
        if (R.is(easing, "function") || !easing) {
            callback = callback || easing || null;
            easing = null;
        }
        params = Object(params);
        ms = +ms || 0;
        var p = {},
            json,
            attr;
        for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
            json = true;
            p[attr] = params[attr];
        }
        if (!json) {
            // if percent-like syntax is used and end-of-all animation callback used
            if(callback){
                // find the last one
                var lastKey = 0;
                for(var i in params){
                    var percent = toInt(i);
                    if(params[has](i) && percent > lastKey){
                        lastKey = percent;
                    }
                }
                lastKey += '%';
                // if already defined callback in the last keyframe, skip
                !params[lastKey].callback && (params[lastKey].callback = callback);
            }
          return new Animation(params, ms);
        } else {
            easing && (p.easing = easing);
            callback && (p.callback = callback);
            return new Animation({100: p}, ms);
        }
    };
    /*\
     * Element.animate
     [ method ]
     **
     * Creates and starts animation for given element.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - animation (object) animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
    elproto.animate = function (params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[0], null, element.attr());
        return element;
    };
    /*\
     * Element.setTime
     [ method ]
     **
     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
     **
     > Parameters
     **
     - anim (object) animation object
     - value (number) number of milliseconds from the beginning of the animation
     **
     = (object) original element if `value` is specified
     * Note, that during animation following events are triggered:
     *
     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
    \*/
    elproto.setTime = function (anim, value) {
        if (anim && value != null) {
            this.status(anim, mmin(value, anim.ms) / anim.ms);
        }
        return this;
    };
    /*\
     * Element.status
     [ method ]
     **
     * Gets or sets the status of animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     - value (number) #optional 0  1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
     **
     = (number) status
     * or
     = (array) status if `anim` is not specified. Array of objects in format:
     o {
     o     anim: (object) animation object
     o     status: (number) status
     o }
     * or
     = (object) original element if `value` is specified
    \*/
    elproto.status = function (anim, value) {
        var out = [],
            i = 0,
            len,
            e;
        if (value != null) {
            runAnimation(anim, this, -1, mmin(value, 1));
            return this;
        } else {
            len = animationElements.length;
            for (; i < len; i++) {
                e = animationElements[i];
                if (e.el.id == this.id && (!anim || e.anim == anim)) {
                    if (anim) {
                        return e.status;
                    }
                    out.push({
                        anim: e.anim,
                        status: e.status
                    });
                }
            }
            if (anim) {
                return 0;
            }
            return out;
        }
    };
    /*\
     * Element.pause
     [ method ]
     **
     * Stops animation of the element with ability to resume it later on.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.pause = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                animationElements[i].paused = true;
            }
        }
        return this;
    };
    /*\
     * Element.resume
     [ method ]
     **
     * Resumes animation if it was paused with @Element.pause method.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.resume = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            var e = animationElements[i];
            if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                delete e.paused;
                this.status(e.anim, e.status);
            }
        }
        return this;
    };
    /*\
     * Element.stop
     [ method ]
     **
     * Stops animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.stop = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                animationElements.splice(i--, 1);
            }
        }
        return this;
    };
    function stopAnimation(paper) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
            animationElements.splice(i--, 1);
        }
    }
    eve.on("raphael.remove", stopAnimation);
    eve.on("raphael.clear", stopAnimation);
    elproto.toString = function () {
        return "Rapha\xebl\u2019s object";
    };

    // Set
    var Set = function (items) {
        this.items = [];
        this.length = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items.length; i < ii; i++) {
                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                    this[this.items.length] = this.items[this.items.length] = items[i];
                    this.length++;
                }
            }
        }
    },
    setproto = Set.prototype;
    /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set.
     = (object) original element
    \*/
    setproto.push = function () {
        var item,
            len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it.
     = (object) element
    \*/
    setproto.pop = function () {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set.
     *
     * If function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
    \*/
    setproto.forEach = function (callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    for (var method in elproto) if (elproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname][apply](el, arg);
                });
            };
        })(method);
    }
    setproto.attr = function (name, value) {
        if (name && R.is(name, array) && R.is(name[0], "object")) {
            for (var j = 0, jj = name.length; j < jj; j++) {
                this.items[j].attr(name[j]);
            }
        } else {
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                this.items[i].attr(name, value);
            }
        }
        return this;
    };
    /*\
     * Set.clear
     [ method ]
     **
     * Removes all elements from the set
    \*/
    setproto.clear = function () {
        while (this.length) {
            this.pop();
        }
    };
    /*\
     * Set.splice
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion (object) #optional elements to insert
     = (object) set elements that were deleted
    \*/
    setproto.splice = function (index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        var tail = [],
            todel = [],
            args = [],
            i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };
    /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - element (object) element to remove
     = (boolean) `true` if object was found & removed from the set
    \*/
    setproto.exclude = function (el) {
        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
    };
    setproto.animate = function (params, ms, easing, callback) {
        (R.is(easing, "function") || !easing) && (callback = easing || null);
        var len = this.items.length,
            i = len,
            item,
            set = this,
            collector;
        if (!len) {
            return this;
        }
        callback && (collector = function () {
            !--len && callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        var anim = R.animation(params, ms, easing, collector);
        item = this.items[--i].animate(anim);
        while (i--) {
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
            (this.items[i] && !this.items[i].removed) || len--;
        }
        return this;
    };
    setproto.insertAfter = function (el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    setproto.getBBox = function () {
        var x = [],
            y = [],
            x2 = [],
            y2 = [];
        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
            var box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        x2 = mmax[apply](0, x2);
        y2 = mmax[apply](0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y
        };
    };
    setproto.clone = function (s) {
        s = this.paper.set();
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function () {
        return "Rapha\xebl\u2018s set";
    };

    setproto.glow = function(glowConfig) {
        var ret = this.paper.set();
        this.forEach(function(shape, index){
            var g = shape.glow(glowConfig);
            if(g != null){
                g.forEach(function(shape2, index2){
                    ret.push(shape2);
                });
            }
        });
        return ret;
    };


    /*\
     * Set.isPointInside
     [ method ]
     **
     * Determine if given point is inside this sets elements
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point is inside any of the set's elements
     \*/
    setproto.isPointInside = function (x, y) {
        var isPointInside = false;
        this.forEach(function (el) {
            if (el.isPointInside(x, y)) {
                isPointInside = true;
                return false; // stop loop
            }
        });
        return isPointInside;
    };

    /*\
     * Raphael.registerFont
     [ method ]
     **
     * Adds given font to the registered set of fonts for Raphal. Should be used as an internal call from within Cufns font file.
     * Returns original parameter, so it could be used with chaining.
     # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufn and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
     **
     > Parameters
     **
     - font (object) the font to register
     = (object) the font you passed in
     > Usage
     | Cufon.registerFont(Raphael.registerFont({}));
    \*/
    R.registerFont = function (font) {
        if (!font.face) {
            return font;
        }
        this.fonts = this.fonts || {};
        var fontcopy = {
                w: font.w,
                face: {},
                glyphs: {}
            },
            family = font.face["font-family"];
        for (var prop in font.face) if (font.face[has](prop)) {
            fontcopy.face[prop] = font.face[prop];
        }
        if (this.fonts[family]) {
            this.fonts[family].push(fontcopy);
        } else {
            this.fonts[family] = [fontcopy];
        }
        if (!font.svg) {
            fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
                var path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
                            return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
                        }) + "z"
                };
                if (path.k) {
                    for (var k in path.k) if (path[has](k)) {
                        fontcopy.glyphs[glyph].k[k] = path.k[k];
                    }
                }
            }
        }
        return font;
    };
    /*\
     * Paper.getFont
     [ method ]
     **
     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like Myriad for Myriad Pro.
     **
     > Parameters
     **
     - family (string) font family name or any word from it
     - weight (string) #optional font weight
     - style (string) #optional font style
     - stretch (string) #optional font stretch
     = (object) the font object
     > Usage
     | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
    \*/
    paperproto.getFont = function (family, weight, style, stretch) {
        stretch = stretch || "normal";
        style = style || "normal";
        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
        if (!R.fonts) {
            return;
        }
        var font = R.fonts[family];
        if (!font) {
            var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R.fonts[fontName];
                    break;
                }
            }
        }
        var thefont;
        if (font) {
            for (var i = 0, ii = font.length; i < ii; i++) {
                thefont = font[i];
                if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                    break;
                }
            }
        }
        return thefont;
    };
    /*\
     * Paper.print
     [ method ]
     **
     * Creates path that represent given text written using given font at given position with given size.
     * Result of the method is path element that contains whole text as a separate path.
     **
     > Parameters
     **
     - x (number) x position of the text
     - y (number) y position of the text
     - string (string) text to print
     - font (object) font object, see @Paper.getFont
     - size (number) #optional size of the font, default is `16`
     - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
     - letter_spacing (number) #optional number in range `-1..1`, default is `0`
     - line_spacing (number) #optional number in range `1..3`, default is `1`
     = (object) resulting path element, which consist of all letters
     > Usage
     | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
    \*/
    paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {
        origin = origin || "middle"; // baseline|middle
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
        var letters = Str(string)[split](E),
            shift = 0,
            notfirst = 0,
            path = E,
            scale;
        R.is(font, "string") && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face["units-per-em"];
            var bb = font.face.bbox[split](separator),
                top = +bb[0],
                lineHeight = bb[3] - bb[1],
                shifty = 0,
                height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
            for (var i = 0, ii = letters.length; i < ii; i++) {
                if (letters[i] == "\n") {
                    shift = 0;
                    curr = 0;
                    notfirst = 0;
                    shifty += lineHeight * line_spacing;
                } else {
                    var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                        curr = font.glyphs[letters[i]];
                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                    notfirst = 1;
                }
                if (curr && curr.d) {
                    path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
                }
            }
        }
        return this.path(path).attr({
            fill: "#000",
            stroke: "none"
        });
    };

    /*\
     * Paper.add
     [ method ]
     **
     * Imports elements in JSON array in format `{type: type, <attributes>}`
     **
     > Parameters
     **
     - json (array)
     = (object) resulting set of imported elements
     > Usage
     | paper.add([
     |     {
     |         type: "circle",
     |         cx: 10,
     |         cy: 10,
     |         r: 5
     |     },
     |     {
     |         type: "rect",
     |         x: 10,
     |         y: 10,
     |         width: 10,
     |         height: 10,
     |         fill: "#fc0"
     |     }
     | ]);
    \*/
    paperproto.add = function (json) {
        if (R.is(json, "array")) {
            var res = this.set(),
                i = 0,
                ii = json.length,
                j;
            for (; i < ii; i++) {
                j = json[i] || {};
                elements[has](j.type) && res.push(this[j.type]().attr(j));
            }
        }
        return res;
    };

    /*\
     * Raphael.format
     [ method ]
     **
     * Simple format function. Replaces construction of type `{<number>}` to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     -  (string) rest of arguments will be treated as parameters for replacement
     = (string) formated string
     > Usage
     | var x = 10,
     |     y = 20,
     |     width = 40,
     |     height = 50;
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
    \*/
    R.format = function (token, params) {
        var args = R.is(params, array) ? [0][concat](params) : arguments;
        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
            return args[++i] == null ? E : args[i];
        }));
        return token || E;
    };
    /*\
     * Raphael.fullfill
     [ method ]
     **
     * A little bit more advanced format function than @Raphael.format. Replaces construction of type `{<name>}` to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - json (object) object which properties will be used as a replacement
     = (string) formated string
     > Usage
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
     |     x: 10,
     |     y: 20,
     |     dim: {
     |         width: 40,
     |         height: 50,
     |         "negative width": -40
     |     }
     | }));
    \*/
    R.fullfill = (function () {
        var tokenRegex = /\{([^\}]+)\}/g,
            objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
            replacer = function (all, key, obj) {
                var res = obj;
                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                    name = name || quotedName;
                    if (res) {
                        if (name in res) {
                            res = res[name];
                        }
                        typeof res == "function" && isFunc && (res = res());
                    }
                });
                res = (res == null || res == obj ? all : res) + "";
                return res;
            };
        return function (str, obj) {
            return String(str).replace(tokenRegex, function (all, key) {
                return replacer(all, key, obj);
            });
        };
    })();
    /*\
     * Raphael.ninja
     [ method ]
     **
     * If you want to leave no trace of Raphal (Well, Raphal creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
     * Beware, that in this case plugins could stop working, because they are depending on global variable existence.
     **
     = (object) Raphael object
     > Usage
     | (function (local_raphael) {
     |     var paper = local_raphael(10, 10, 320, 200);
     |     
     | })(Raphael.ninja());
    \*/
    R.ninja = function () {
        if (oldRaphael.was) {
            g.win.Raphael = oldRaphael.is;
        } else {
            // IE8 raises an error when deleting window property
            window.Raphael = undefined;
            try {
                delete window.Raphael;
            } catch(e) {}
        }
        return R;
    };
    /*\
     * Raphael.st
     [ property (object) ]
     **
     * You can add your own method to elements and sets. It is wise to add a set method for each element method
     * you added, so you will be able to call the same method on sets too.
     **
     * See also @Raphael.el.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | Raphael.st.red = function () {
     |     this.forEach(function (el) {
     |         el.red();
     |     });
     | };
     | // then use it
     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
    \*/
    R.st = setproto;

    eve.on("raphael.DOMload", function () {
        loaded = true;
    });

    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
    (function (doc, loaded, f) {
        if (doc.readyState == null && doc.addEventListener){
            doc.addEventListener(loaded, f = function () {
                doc.removeEventListener(loaded, f, false);
                doc.readyState = "complete";
            }, false);
            doc.readyState = "loading";
        }
        function isLoaded() {
            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
        }
        isLoaded();
    })(document, "DOMContentLoaded");

    return R;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./dev/raphael.svg.js":
/*!****************************!*\
  !*** ./dev/raphael.svg.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./raphael.core */ "./dev/raphael.core.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(R) {
    if (R && !R.svg) {
        return;
    }

    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        toInt = parseInt,
        math = Math,
        mmax = math.max,
        abs = math.abs,
        pow = math.pow,
        separator = /[, ]+/,
        eve = R.eve,
        E = "",
        S = " ";
    var xlink = "http://www.w3.org/1999/xlink",
        markers = {
            block: "M5,0 0,2.5 5,5z",
            classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
            diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
            open: "M6,1 1,3.5 6,6",
            oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
        },
        markerCounter = {};
    R.toString = function () {
        return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
    };
    var $ = function (el, attr) {
        if (attr) {
            if (typeof el == "string") {
                el = $(el);
            }
            for (var key in attr) if (attr[has](key)) {
                if (key.substring(0, 6) == "xlink:") {
                    el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                } else {
                    el.setAttribute(key, Str(attr[key]));
                }
            }
        } else {
            el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
            el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
        }
        return el;
    },
    addGradientFill = function (element, gradient) {
        var type = "linear",
            id = element.id + gradient,
            fx = .5, fy = .5,
            o = element.node,
            SVG = element.paper,
            s = o.style,
            el = R._g.doc.getElementById(id);
        if (!el) {
            gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
                type = "radial";
                if (_fx && _fy) {
                    fx = toFloat(_fx);
                    fy = toFloat(_fy);
                    var dir = ((fy > .5) * 2 - 1);
                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                        fy != .5 &&
                        (fy = fy.toFixed(5) - 1e-5 * dir);
                }
                return E;
            });
            gradient = gradient.split(/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
                var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                vector[2] *= max;
                vector[3] *= max;
                if (vector[2] < 0) {
                    vector[0] = -vector[2];
                    vector[2] = 0;
                }
                if (vector[3] < 0) {
                    vector[1] = -vector[3];
                    vector[3] = 0;
                }
            }
            var dots = R._parseDots(gradient);
            if (!dots) {
                return null;
            }
            id = id.replace(/[\(\)\s,\xb0#]/g, "_");

            if (element.gradient && id != element.gradient.id) {
                SVG.defs.removeChild(element.gradient);
                delete element.gradient;
            }

            if (!element.gradient) {
                el = $(type + "Gradient", {id: id});
                element.gradient = el;
                $(el, type == "radial" ? {
                    fx: fx,
                    fy: fy
                } : {
                    x1: vector[0],
                    y1: vector[1],
                    x2: vector[2],
                    y2: vector[3],
                    gradientTransform: element.matrix.invert()
                });
                SVG.defs.appendChild(el);
                for (var i = 0, ii = dots.length; i < ii; i++) {
                    el.appendChild($("stop", {
                        offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                        "stop-color": dots[i].color || "#fff",
                        "stop-opacity": isFinite(dots[i].opacity) ? dots[i].opacity : 1
                    }));
                }
            }
        }
        $(o, {
            fill: fillurl(id),
            opacity: 1,
            "fill-opacity": 1
        });
        s.fill = E;
        s.opacity = 1;
        s.fillOpacity = 1;
        return 1;
    },
    isIE9or10 = function () {
      var mode = document.documentMode;
      return mode && (mode === 9 || mode === 10);
    },
    fillurl = function (id) {
      if (isIE9or10()) {
          return "url('#" + id + "')";
      }
      var location = document.location;
      var locationString = (
          location.protocol + '//' +
          location.host +
          location.pathname +
          location.search
      );
      return "url('" + locationString + "#" + id + "')";
    },
    updatePosition = function (o) {
        var bbox = o.getBBox(1);
        $(o.pattern, {patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"});
    },
    addArrow = function (o, value, isEnd) {
        if (o.type == "path") {
            var values = Str(value).toLowerCase().split("-"),
                p = o.paper,
                se = isEnd ? "end" : "start",
                node = o.node,
                attrs = o.attrs,
                stroke = attrs["stroke-width"],
                i = values.length,
                type = "classic",
                from,
                to,
                dx,
                refX,
                attr,
                w = 3,
                h = 3,
                t = 5;
            while (i--) {
                switch (values[i]) {
                    case "block":
                    case "classic":
                    case "oval":
                    case "diamond":
                    case "open":
                    case "none":
                        type = values[i];
                        break;
                    case "wide": h = 5; break;
                    case "narrow": h = 2; break;
                    case "long": w = 5; break;
                    case "short": w = 2; break;
                }
            }
            if (type == "open") {
                w += 2;
                h += 2;
                t += 2;
                dx = 1;
                refX = isEnd ? 4 : 1;
                attr = {
                    fill: "none",
                    stroke: attrs.stroke
                };
            } else {
                refX = dx = w / 2;
                attr = {
                    fill: attrs.stroke,
                    stroke: "none"
                };
            }
            if (o._.arrows) {
                if (isEnd) {
                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                } else {
                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                }
            } else {
                o._.arrows = {};
            }
            if (type != "none") {
                var pathId = "raphael-marker-" + type,
                    markerId = "raphael-marker-" + se + type + w + h + "-obj" + o.id;
                if (!R._g.doc.getElementById(pathId)) {
                    p.defs.appendChild($($("path"), {
                        "stroke-linecap": "round",
                        d: markers[type],
                        id: pathId
                    }));
                    markerCounter[pathId] = 1;
                } else {
                    markerCounter[pathId]++;
                }
                var marker = R._g.doc.getElementById(markerId),
                    use;
                if (!marker) {
                    marker = $($("marker"), {
                        id: markerId,
                        markerHeight: h,
                        markerWidth: w,
                        orient: "auto",
                        refX: refX,
                        refY: h / 2
                    });
                    use = $($("use"), {
                        "xlink:href": "#" + pathId,
                        transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                        "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                    });
                    marker.appendChild(use);
                    p.defs.appendChild(marker);
                    markerCounter[markerId] = 1;
                } else {
                    markerCounter[markerId]++;
                    use = marker.getElementsByTagName("use")[0];
                }
                $(use, attr);
                var delta = dx * (type != "diamond" && type != "oval");
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = R.getTotalLength(attrs.path) - delta * stroke;
                } else {
                    from = delta * stroke;
                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                attr = {};
                attr["marker-" + se] = "url(#" + markerId + ")";
                if (to || from) {
                    attr.d = R.getSubpath(attrs.path, from, to);
                }
                $(node, attr);
                o._.arrows[se + "Path"] = pathId;
                o._.arrows[se + "Marker"] = markerId;
                o._.arrows[se + "dx"] = delta;
                o._.arrows[se + "Type"] = type;
                o._.arrows[se + "String"] = value;
            } else {
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = R.getTotalLength(attrs.path) - from;
                } else {
                    from = 0;
                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                o._.arrows[se + "Path"] && $(node, {d: R.getSubpath(attrs.path, from, to)});
                delete o._.arrows[se + "Path"];
                delete o._.arrows[se + "Marker"];
                delete o._.arrows[se + "dx"];
                delete o._.arrows[se + "Type"];
                delete o._.arrows[se + "String"];
            }
            for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
                var item = R._g.doc.getElementById(attr);
                item && item.parentNode.removeChild(item);
            }
        }
    },
    dasharray = {
        "-": [3, 1],
        ".": [1, 1],
        "-.": [3, 1, 1, 1],
        "-..": [3, 1, 1, 1, 1, 1],
        ". ": [1, 3],
        "- ": [4, 3],
        "--": [8, 3],
        "- .": [4, 3, 1, 3],
        "--.": [8, 3, 1, 3],
        "--..": [8, 3, 1, 3, 1, 3]
    },
    addDashes = function (o, value, params) {
        value = dasharray[Str(value).toLowerCase()];
        if (value) {
            var width = o.attrs["stroke-width"] || "1",
                butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                dashes = [],
                i = value.length;
            while (i--) {
                dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
            }
            $(o.node, {"stroke-dasharray": dashes.join(",")});
        }
        else {
          $(o.node, {"stroke-dasharray": "none"});
        }
    },
    setFillAndStroke = function (o, params) {
        var node = o.node,
            attrs = o.attrs,
            vis = node.style.visibility;
        node.style.visibility = "hidden";
        for (var att in params) {
            if (params[has](att)) {
                if (!R._availableAttrs[has](att)) {
                    continue;
                }
                var value = params[att];
                attrs[att] = value;
                switch (att) {
                    case "blur":
                        o.blur(value);
                        break;
                    case "title":
                        var title = node.getElementsByTagName("title");

                        // Use the existing <title>.
                        if (title.length && (title = title[0])) {
                          title.firstChild.nodeValue = value;
                        } else {
                          title = $("title");
                          var val = R._g.doc.createTextNode(value);
                          title.appendChild(val);
                          node.appendChild(title);
                        }
                        break;
                    case "href":
                    case "target":
                        var pn = node.parentNode;
                        if (pn.tagName.toLowerCase() != "a") {
                            var hl = $("a");
                            pn.insertBefore(hl, node);
                            hl.appendChild(node);
                            pn = hl;
                        }
                        if (att == "target") {
                            pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                        } else {
                            pn.setAttributeNS(xlink, att, value);
                        }
                        break;
                    case "cursor":
                        node.style.cursor = value;
                        break;
                    case "transform":
                        o.transform(value);
                        break;
                    case "arrow-start":
                        addArrow(o, value);
                        break;
                    case "arrow-end":
                        addArrow(o, value, 1);
                        break;
                    case "clip-rect":
                        var rect = Str(value).split(separator);
                        if (rect.length == 4) {
                            o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                            var el = $("clipPath"),
                                rc = $("rect");
                            el.id = R.createUUID();
                            $(rc, {
                                x: rect[0],
                                y: rect[1],
                                width: rect[2],
                                height: rect[3]
                            });
                            el.appendChild(rc);
                            o.paper.defs.appendChild(el);
                            $(node, {"clip-path": "url(#" + el.id + ")"});
                            o.clip = rc;
                        }
                        if (!value) {
                            var path = node.getAttribute("clip-path");
                            if (path) {
                                var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                clip && clip.parentNode.removeChild(clip);
                                $(node, {"clip-path": E});
                                delete o.clip;
                            }
                        }
                    break;
                    case "path":
                        if (o.type == "path") {
                            $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});
                            o._.dirty = 1;
                            if (o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                        }
                        break;
                    case "width":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fx) {
                            att = "x";
                            value = attrs.x;
                        } else {
                            break;
                        }
                    case "x":
                        if (attrs.fx) {
                            value = -attrs.x - (attrs.width || 0);
                        }
                    case "rx":
                        if (att == "rx" && o.type == "rect") {
                            break;
                        }
                    case "cx":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "height":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fy) {
                            att = "y";
                            value = attrs.y;
                        } else {
                            break;
                        }
                    case "y":
                        if (attrs.fy) {
                            value = -attrs.y - (attrs.height || 0);
                        }
                    case "ry":
                        if (att == "ry" && o.type == "rect") {
                            break;
                        }
                    case "cy":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "r":
                        if (o.type == "rect") {
                            $(node, {rx: value, ry: value});
                        } else {
                            node.setAttribute(att, value);
                        }
                        o._.dirty = 1;
                        break;
                    case "src":
                        if (o.type == "image") {
                            node.setAttributeNS(xlink, "href", value);
                        }
                        break;
                    case "stroke-width":
                        if (o._.sx != 1 || o._.sy != 1) {
                            value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                        }
                        node.setAttribute(att, value);
                        if (attrs["stroke-dasharray"]) {
                            addDashes(o, attrs["stroke-dasharray"], params);
                        }
                        if (o._.arrows) {
                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                        break;
                    case "stroke-dasharray":
                        addDashes(o, value, params);
                        break;
                    case "fill":
                        var isURL = Str(value).match(R._ISURL);
                        if (isURL) {
                            el = $("pattern");
                            var ig = $("image");
                            el.id = R.createUUID();
                            $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
                            $(ig, {x: 0, y: 0, "xlink:href": isURL[1]});
                            el.appendChild(ig);

                            (function (el) {
                                R._preload(isURL[1], function () {
                                    var w = this.offsetWidth,
                                        h = this.offsetHeight;
                                    $(el, {width: w, height: h});
                                    $(ig, {width: w, height: h});
                                });
                            })(el);
                            o.paper.defs.appendChild(el);
                            $(node, {fill: "url(#" + el.id + ")"});
                            o.pattern = el;
                            o.pattern && updatePosition(o);
                            break;
                        }
                        var clr = R.getRGB(value);
                        if (!clr.error) {
                            delete params.gradient;
                            delete attrs.gradient;
                            !R.is(attrs.opacity, "undefined") &&
                                R.is(params.opacity, "undefined") &&
                                $(node, {opacity: attrs.opacity});
                            !R.is(attrs["fill-opacity"], "undefined") &&
                                R.is(params["fill-opacity"], "undefined") &&
                                $(node, {"fill-opacity": attrs["fill-opacity"]});
                        } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                            if ("opacity" in attrs || "fill-opacity" in attrs) {
                                var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                if (gradient) {
                                    var stops = gradient.getElementsByTagName("stop");
                                    $(stops[stops.length - 1], {"stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)});
                                }
                            }
                            attrs.gradient = value;
                            attrs.fill = "none";
                            break;
                        }
                        clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                    case "stroke":
                        clr = R.getRGB(value);
                        node.setAttribute(att, clr.hex);
                        att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                        if (att == "stroke" && o._.arrows) {
                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                        break;
                    case "gradient":
                        (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                        break;
                    case "opacity":
                        if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                            $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
                        }
                        // fall
                    case "fill-opacity":
                        if (attrs.gradient) {
                            gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                            if (gradient) {
                                stops = gradient.getElementsByTagName("stop");
                                $(stops[stops.length - 1], {"stop-opacity": value});
                            }
                            break;
                        }
                    default:
                        att == "font-size" && (value = toInt(value, 10) + "px");
                        var cssrule = att.replace(/(\-.)/g, function (w) {
                            return w.substring(1).toUpperCase();
                        });
                        node.style[cssrule] = value;
                        o._.dirty = 1;
                        node.setAttribute(att, value);
                        break;
                }
            }
        }

        tuneText(o, params);
        node.style.visibility = vis;
    },
    leading = 1.2,
    tuneText = function (el, params) {
        if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
            return;
        }
        var a = el.attrs,
            node = el.node,
            fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

        if (params[has]("text")) {
            a.text = params.text;
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            var texts = Str(params.text).split("\n"),
                tspans = [],
                tspan;
            for (var i = 0, ii = texts.length; i < ii; i++) {
                tspan = $("tspan");
                i && $(tspan, {dy: fontSize * leading, x: a.x});
                tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                node.appendChild(tspan);
                tspans[i] = tspan;
            }
        } else {
            tspans = node.getElementsByTagName("tspan");
            for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
                $(tspans[i], {dy: fontSize * leading, x: a.x});
            } else {
                $(tspans[0], {dy: 0});
            }
        }
        $(node, {x: a.x, y: a.y});
        el._.dirty = 1;
        var bb = el._getBBox(),
            dif = a.y - (bb.y + bb.height / 2);
        dif && R.is(dif, "finite") && $(tspans[0], {dy: dif});
    },
    getRealNode = function (node) {
        if (node.parentNode && node.parentNode.tagName.toLowerCase() === "a") {
            return node.parentNode;
        } else {
            return node;
        }
    },
    Element = function (node, svg) {
        var X = 0,
            Y = 0;
        /*\
         * Element.node
         [ property (object) ]
         **
         * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
         **
         * Note: Dont mess with it.
         > Usage
         | // draw a circle at coordinate 10,10 with radius of 10
         | var c = paper.circle(10, 10, 10);
         | c.node.onclick = function () {
         |     c.attr("fill", "red");
         | };
        \*/
        this[0] = this.node = node;
        /*\
         * Element.raphael
         [ property (object) ]
         **
         * Internal reference to @Raphael object. In case it is not available.
         > Usage
         | Raphael.el.red = function () {
         |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
         |     hsb.h = 1;
         |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
         | }
        \*/
        node.raphael = true;
        /*\
         * Element.id
         [ property (number) ]
         **
         * Unique id of the element. Especially useful when you want to listen to events of the element,
         * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
        \*/
        this.id = guid();
        node.raphaelid = this.id;

        /**
        * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements
        * @returns {string} id
        */
        function guid() {
            return ("0000" + (Math.random()*Math.pow(36,5) << 0).toString(36)).slice(-5);
        }

        this.matrix = R.matrix();
        this.realPath = null;
        /*\
         * Element.paper
         [ property (object) ]
         **
         * Internal reference to paper where object drawn. Mainly for use in plugins and element extensions.
         > Usage
         | Raphael.el.cross = function () {
         |     this.attr({fill: "red"});
         |     this.paper.path("M10,10L50,50M50,10L10,50")
         |         .attr({stroke: "red"});
         | }
        \*/
        this.paper = svg;
        this.attrs = this.attrs || {};
        this._ = {
            transform: [],
            sx: 1,
            sy: 1,
            deg: 0,
            dx: 0,
            dy: 0,
            dirty: 1
        };
        !svg.bottom && (svg.bottom = this);
        /*\
         * Element.prev
         [ property (object) ]
         **
         * Reference to the previous element in the hierarchy.
        \*/
        this.prev = svg.top;
        svg.top && (svg.top.next = this);
        svg.top = this;
        /*\
         * Element.next
         [ property (object) ]
         **
         * Reference to the next element in the hierarchy.
        \*/
        this.next = null;
    },
    elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;

    R._engine.path = function (pathString, SVG) {
        var el = $("path");
        SVG.canvas && SVG.canvas.appendChild(el);
        var p = new Element(el, SVG);
        p.type = "path";
        setFillAndStroke(p, {
            fill: "none",
            stroke: "#000",
            path: pathString
        });
        return p;
    };
    /*\
     * Element.rotate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds rotation by given angle around given point to the list of
     * transformations of the element.
     > Parameters
     - deg (number) angle in degrees
     - cx (number) #optional x coordinate of the centre of rotation
     - cy (number) #optional y coordinate of the centre of rotation
     * If cx & cy arent specified centre of the shape is used as a point of rotation.
     = (object) @Element
    \*/
    elproto.rotate = function (deg, cx, cy) {
        if (this.removed) {
            return this;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this.transform(this._.transform.concat([["r", deg, cx, cy]]));
        return this;
    };
    /*\
     * Element.scale
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds scale by given amount relative to given point to the list of
     * transformations of the element.
     > Parameters
     - sx (number) horisontal scale amount
     - sy (number) vertical scale amount
     - cx (number) #optional x coordinate of the centre of scale
     - cy (number) #optional y coordinate of the centre of scale
     * If cx & cy arent specified centre of the shape is used instead.
     = (object) @Element
    \*/
    elproto.scale = function (sx, sy, cx, cy) {
        if (this.removed) {
            return this;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
        return this;
    };
    /*\
     * Element.translate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds translation by given amount to the list of transformations of the element.
     > Parameters
     - dx (number) horisontal shift
     - dy (number) vertical shift
     = (object) @Element
    \*/
    elproto.translate = function (dx, dy) {
        if (this.removed) {
            return this;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        this.transform(this._.transform.concat([["t", dx, dy]]));
        return this;
    };
    /*\
     * Element.transform
     [ method ]
     **
     * Adds transformation to the element which is separate to other attributes,
     * i.e. translation doesnt change `x` or `y` of the rectange. The format
     * of transformation string is similar to the path string syntax:
     | "t100,100r30,100,100s2,2,100,100r45s1.5"
     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
     * scale and `m` is for matrix.
     *
     * There are also alternative absolute translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
     *
     * So, the example line above could be read like translate by 100, 100; rotate 30 around 100, 100; scale twice around 100, 100;
     * rotate 45 around centre; scale 1.5 times relative to centre. As you can see rotate and scale commands have origin
     * coordinates as optional parameters, the default is the centre point of the element.
     * Matrix accepts six parameters.
     > Usage
     | var el = paper.rect(10, 20, 300, 200);
     | // translate 100, 100, rotate 45, translate -100, 0
     | el.transform("t100,100r45t-100,0");
     | // if you want you can append or prepend transformations
     | el.transform("...t50,50");
     | el.transform("s2...");
     | // or even wrap
     | el.transform("t50,50...t-50-50");
     | // to reset transformation call method with empty string
     | el.transform("");
     | // to get current value call it without parameters
     | console.log(el.transform());
     > Parameters
     - tstr (string) #optional transformation string
     * If tstr isnt specified
     = (string) current transformation string
     * else
     = (object) @Element
    \*/
    elproto.transform = function (tstr) {
        var _ = this._;
        if (tstr == null) {
            return _.transform;
        }
        R._extractTransform(this, tstr);

        this.clip && $(this.clip, {transform: this.matrix.invert()});
        this.pattern && updatePosition(this);
        this.node && $(this.node, {transform: this.matrix});

        if (_.sx != 1 || _.sy != 1) {
            var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
            this.attr({"stroke-width": sw});
        }

        return this;
    };
    /*\
     * Element.hide
     [ method ]
     **
     * Makes element invisible. See @Element.show.
     = (object) @Element
    \*/
    elproto.hide = function () {
        if(!this.removed) this.node.style.display = "none";
        return this;
    };
    /*\
     * Element.show
     [ method ]
     **
     * Makes element visible. See @Element.hide.
     = (object) @Element
    \*/
    elproto.show = function () {
        if(!this.removed) this.node.style.display = "";
        return this;
    };
    /*\
     * Element.remove
     [ method ]
     **
     * Removes element from the paper.
    \*/
    elproto.remove = function () {
        var node = getRealNode(this.node);
        if (this.removed || !node.parentNode) {
            return;
        }
        var paper = this.paper;
        paper.__set__ && paper.__set__.exclude(this);
        eve.unbind("raphael.*.*." + this.id);
        if (this.gradient) {
            paper.defs.removeChild(this.gradient);
        }
        R._tear(this, paper);

        node.parentNode.removeChild(node);

        // Remove custom data for element
        this.removeData();

        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    elproto._getBBox = function () {
        if (this.node.style.display == "none") {
            this.show();
            var hide = true;
        }
        var canvasHidden = false,
            containerStyle;
        if (this.paper.canvas.parentElement) {
          containerStyle = this.paper.canvas.parentElement.style;
        } //IE10+ can't find parentElement
        else if (this.paper.canvas.parentNode) {
          containerStyle = this.paper.canvas.parentNode.style;
        }

        if(containerStyle && containerStyle.display == "none") {
          canvasHidden = true;
          containerStyle.display = "";
        }
        var bbox = {};
        try {
            bbox = this.node.getBBox();
        } catch(e) {
            // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix
            bbox = {
                x: this.node.clientLeft,
                y: this.node.clientTop,
                width: this.node.clientWidth,
                height: this.node.clientHeight
            }
        } finally {
            bbox = bbox || {};
            if(canvasHidden){
              containerStyle.display = "none";
            }
        }
        hide && this.hide();
        return bbox;
    };
    /*\
     * Element.attr
     [ method ]
     **
     * Sets the attributes of the element.
     > Parameters
     - attrName (string) attributes name
     - value (string) value
     * or
     - params (object) object of name/value pairs
     * or
     - attrName (string) attributes name
     * or
     - attrNames (array) in this case method returns array of current values for given attribute names
     = (object) @Element if attrsName & value or params are passed in.
     = (...) value of the attribute if only attrsName is passed in.
     = (array) array of values of the attribute if attrsNames is passed in.
     = (object) object of attributes if nothing is passed in.
     > Possible parameters
     # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
     o clip-rect (string) comma or space separated values: x, y, width and height
     o cursor (string) CSS type of the cursor
     o cx (number) the x-axis coordinate of the center of the circle, or ellipse
     o cy (number) the y-axis coordinate of the center of the circle, or ellipse
     o fill (string) colour, gradient or image
     o fill-opacity (number)
     o font (string)
     o font-family (string)
     o font-size (number) font size in pixels
     o font-weight (string)
     o height (number)
     o href (string) URL, if specified element behaves as hyperlink
     o opacity (number)
     o path (string) SVG path string format
     o r (number) radius of the circle, ellipse or rounded corner on the rect
     o rx (number) horisontal radius of the ellipse
     o ry (number) vertical radius of the ellipse
     o src (string) image URL, only works for @Element.image element
     o stroke (string) stroke colour
     o stroke-dasharray (string) [, none, `-`, `.`, `-.`, `-..`, `. `, `- `, `--`, `- .`, `--.`, `--..`]
     o stroke-linecap (string) [`butt`, `square`, `round`]
     o stroke-linejoin (string) [`bevel`, `round`, `miter`]
     o stroke-miterlimit (number)
     o stroke-opacity (number)
     o stroke-width (number) stroke width in pixels, default is '1'
     o target (string) used with href
     o text (string) contents of the text element. Use `\n` for multiline text
     o text-anchor (string) [`start`, `middle`, `end`], default is `middle`
     o title (string) will create tooltip with a given text
     o transform (string) see @Element.transform
     o width (number)
     o x (number)
     o y (number)
     > Gradients
     * Linear gradient format: `angle-colour[-colour[:offset]]*-colour`, example: `90-#fff-#000`  90
     * gradient from white to black or `0-#fff-#f00:20-#000`  0 gradient from white via red (at 20%) to black.
     *
     * radial gradient: `r[(fx, fy)]colour[-colour[:offset]]*-colour`, example: `r#fff-#000` 
     * gradient from white to black or `r(0.25, 0.75)#fff-#000`  gradient from white to black with focus point
     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
     > Path String
     # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a paths data attributes format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphal fully supports it.</p>
     > Colour Parsing
     # <ul>
     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>
     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>
     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
     #     <li>rgba(, , , )  red, green and blue channels values: (<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>)</li>
     #     <li>rgba(%, %, %, %)  same as above, but in %: (<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>)</li>
     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
     #     <li>hsb(%, %, %)  same as above, but in %</li>
     #     <li>hsba(, , , )  same as above, but with opacity</li>
     #     <li>hsl(, , )  almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
     #     <li>hsl(%, %, %)  same as above, but in %</li>
     #     <li>hsla(, , , )  same as above, but with opacity</li>
     #     <li>Optionally for hsb and hsl you could specify hue as a degree: <code>hsl(240deg,&nbsp;1,&nbsp;.5)</code> or, if you want to go fancy, <code>hsl(240,&nbsp;1,&nbsp;.5)</code></li>
     # </ul>
    \*/
    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) if (this.attrs[has](a)) {
                res[a] = this.attrs[a];
            }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            if (name == "transform") {
                return this._.transform;
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.paper.customAttributes[name], "function")) {
                    out[name] = this.paper.customAttributes[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        if (value != null) {
            var params = {};
            params[name] = value;
        } else if (name != null && R.is(name, "object")) {
            params = name;
        }
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
            this.attrs[key] = params[key];
            for (var subkey in par) if (par[has](subkey)) {
                params[subkey] = par[subkey];
            }
        }
        setFillAndStroke(this, params);
        return this;
    };
    /*\
     * Element.toFront
     [ method ]
     **
     * Moves the element so it is the closest to the viewers eyes, on top of other elements.
     = (object) @Element
    \*/
    elproto.toFront = function () {
        if (this.removed) {
            return this;
        }
        var node = getRealNode(this.node);
        node.parentNode.appendChild(node);
        var svg = this.paper;
        svg.top != this && R._tofront(this, svg);
        return this;
    };
    /*\
     * Element.toBack
     [ method ]
     **
     * Moves the element so it is the furthest from the viewers eyes, behind other elements.
     = (object) @Element
    \*/
    elproto.toBack = function () {
        if (this.removed) {
            return this;
        }
        var node = getRealNode(this.node);
        var parentNode = node.parentNode;
        parentNode.insertBefore(node, parentNode.firstChild);
        R._toback(this, this.paper);
        var svg = this.paper;
        return this;
    };
    /*\
     * Element.insertAfter
     [ method ]
     **
     * Inserts current object after the given one.
     = (object) @Element
    \*/
    elproto.insertAfter = function (element) {
        if (this.removed || !element) {
            return this;
        }

        var node = getRealNode(this.node);
        var afterNode = getRealNode(element.node || element[element.length - 1].node);
        if (afterNode.nextSibling) {
            afterNode.parentNode.insertBefore(node, afterNode.nextSibling);
        } else {
            afterNode.parentNode.appendChild(node);
        }
        R._insertafter(this, element, this.paper);
        return this;
    };
    /*\
     * Element.insertBefore
     [ method ]
     **
     * Inserts current object before the given one.
     = (object) @Element
    \*/
    elproto.insertBefore = function (element) {
        if (this.removed || !element) {
            return this;
        }

        var node = getRealNode(this.node);
        var beforeNode = getRealNode(element.node || element[0].node);
        beforeNode.parentNode.insertBefore(node, beforeNode);
        R._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function (size) {
        // Experimental. No Safari support. Use it on your own risk.
        var t = this;
        if (+size !== 0) {
            var fltr = $("filter"),
                blur = $("feGaussianBlur");
            t.attrs.blur = size;
            fltr.id = R.createUUID();
            $(blur, {stdDeviation: +size || 1.5});
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {filter: "url(#" + fltr.id + ")"});
        } else {
            if (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                delete t._blur;
                delete t.attrs.blur;
            }
            t.node.removeAttribute("filter");
        }
        return t;
    };
    R._engine.circle = function (svg, x, y, r) {
        var el = $("circle");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
        res.type = "circle";
        $(el, res.attrs);
        return res;
    };
    R._engine.rect = function (svg, x, y, w, h, r) {
        var el = $("rect");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
        res.type = "rect";
        $(el, res.attrs);
        return res;
    };
    R._engine.ellipse = function (svg, x, y, rx, ry) {
        var el = $("ellipse");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
        res.type = "ellipse";
        $(el, res.attrs);
        return res;
    };
    R._engine.image = function (svg, src, x, y, w, h) {
        var el = $("image");
        $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
        el.setAttributeNS(xlink, "href", src);
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, src: src};
        res.type = "image";
        return res;
    };
    R._engine.text = function (svg, x, y, text) {
        var el = $("text");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {
            x: x,
            y: y,
            "text-anchor": "middle",
            text: text,
            "font-family": R._availableAttrs["font-family"],
            "font-size": R._availableAttrs["font-size"],
            stroke: "none",
            fill: "#000"
        };
        res.type = "text";
        setFillAndStroke(res, res.attrs);
        return res;
    };
    R._engine.setSize = function (width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        this.canvas.setAttribute("width", this.width);
        this.canvas.setAttribute("height", this.height);
        if (this._viewBox) {
            this.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.create = function () {
        var con = R._getContainer.apply(0, arguments),
            container = con && con.container;
        if (!container) {
            throw new Error("SVG container not found.");
        }
        var x = con.x,
            y = con.y,
            width = con.width,
            height = con.height,
            cnvs = $("svg"),
            css = "overflow:hidden;",
            isFloating;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
            height: height,
            version: 1.1,
            width: width,
            xmlns: "http://www.w3.org/2000/svg",
            "xmlns:xlink": "http://www.w3.org/1999/xlink"
        });
        if (container == 1) {
            cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
            R._g.doc.body.appendChild(cnvs);
            isFloating = 1;
        } else {
            cnvs.style.cssText = css + "position:relative";
            if (container.firstChild) {
                container.insertBefore(cnvs, container.firstChild);
            } else {
                container.appendChild(cnvs);
            }
        }
        container = new R._Paper;
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        container.clear();
        container._left = container._top = 0;
        isFloating && (container.renderfix = function () {});
        container.renderfix();
        return container;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
        eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var paperSize = this.getSize(),
            size = mmax(w / paperSize.width, h / paperSize.height),
            top = this.top,
            aspectRatio = fit ? "xMidYMid meet" : "xMinYMin",
            vb,
            sw;
        if (x == null) {
            if (this._vbSize) {
                size = 1;
            }
            delete this._vbSize;
            vb = "0 0 " + this.width + S + this.height;
        } else {
            this._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(this.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        while (size && top) {
            sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
            top.attr({"stroke-width": sw});
            top._.dirty = 1;
            top._.dirtyT = 1;
            top = top.prev;
        }
        this._viewBox = [x, y, w, h, !!fit];
        return this;
    };
    /*\
     * Paper.renderfix
     [ method ]
     **
     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent
     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
     * This method fixes the issue.
     **
       Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
    \*/
    R.prototype.renderfix = function () {
        var cnvs = this.canvas,
            s = cnvs.style,
            pos;
        try {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (e) {
            pos = cnvs.createSVGMatrix();
        }
        var left = -pos.e % 1,
            top = -pos.f % 1;
        if (left || top) {
            if (left) {
                this._left = (this._left + left) % 1;
                s.left = this._left + "px";
            }
            if (top) {
                this._top = (this._top + top) % 1;
                s.top = this._top + "px";
            }
        }
    };
    /*\
     * Paper.clear
     [ method ]
     **
     * Clears the paper, i.e. removes all the elements.
    \*/
    R.prototype.clear = function () {
        R.eve("raphael.clear", this);
        var c = this.canvas;
        while (c.firstChild) {
            c.removeChild(c.firstChild);
        }
        this.bottom = this.top = null;
        (this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
        c.appendChild(this.desc);
        c.appendChild(this.defs = $("defs"));
    };
    /*\
     * Paper.remove
     [ method ]
     **
     * Removes the paper from the DOM.
    \*/
    R.prototype.remove = function () {
        eve("raphael.remove", this);
        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
    };
    var setproto = R.st;
    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./dev/raphael.vml.js":
/*!****************************!*\
  !*** ./dev/raphael.vml.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./raphael.core */ "./dev/raphael.core.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(R) {
    if (R && !R.vml) {
        return;
    }

    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        math = Math,
        round = math.round,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        fillString = "fill",
        separator = /[, ]+/,
        eve = R.eve,
        ms = " progid:DXImageTransform.Microsoft",
        S = " ",
        E = "",
        map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
        bites = /([clmz]),?([^clmz]*)/gi,
        blurregexp = / progid:\S+Blur\([^\)]+\)/g,
        val = /-?[^,\s-]+/g,
        cssDot = "position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)",
        zoom = 21600,
        pathTypes = {path: 1, rect: 1, image: 1},
        ovalTypes = {circle: 1, ellipse: 1},
        path2vml = function (path) {
            var total =  /[ahqstv]/ig,
                command = R._pathToAbsolute;
            Str(path).match(total) && (command = R._path2curve);
            total = /[clmz]/g;
            if (command == R._pathToAbsolute && !Str(path).match(total)) {
                var res = Str(path).replace(bites, function (all, command, args) {
                    var vals = [],
                        isMove = command.toLowerCase() == "m",
                        res = map[command];
                    args.replace(val, function (value) {
                        if (isMove && vals.length == 2) {
                            res += vals + map[command == "m" ? "l" : "L"];
                            vals = [];
                        }
                        vals.push(round(value * zoom));
                    });
                    return res + vals;
                });
                return res;
            }
            var pa = command(path), p, r;
            res = [];
            for (var i = 0, ii = pa.length; i < ii; i++) {
                p = pa[i];
                r = pa[i][0].toLowerCase();
                r == "z" && (r = "x");
                for (var j = 1, jj = p.length; j < jj; j++) {
                    r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                }
                res.push(r);
            }
            return res.join(S);
        },
        compensation = function (deg, dx, dy) {
            var m = R.matrix();
            m.rotate(-deg, .5, .5);
            return {
                dx: m.x(dx, dy),
                dy: m.y(dx, dy)
            };
        },
        setCoords = function (p, sx, sy, dx, dy, deg) {
            var _ = p._,
                m = p.matrix,
                fillpos = _.fillpos,
                o = p.node,
                s = o.style,
                y = 1,
                flip = "",
                dxdy,
                kx = zoom / sx,
                ky = zoom / sy;
            s.visibility = "hidden";
            if (!sx || !sy) {
                return;
            }
            o.coordsize = abs(kx) + S + abs(ky);
            s.rotation = deg * (sx * sy < 0 ? -1 : 1);
            if (deg) {
                var c = compensation(deg, dx, dy);
                dx = c.dx;
                dy = c.dy;
            }
            sx < 0 && (flip += "x");
            sy < 0 && (flip += " y") && (y = -1);
            s.flip = flip;
            o.coordorigin = (dx * -kx) + S + (dy * -ky);
            if (fillpos || _.fillsize) {
                var fill = o.getElementsByTagName(fillString);
                fill = fill && fill[0];
                o.removeChild(fill);
                if (fillpos) {
                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                    fill.position = c.dx * y + S + c.dy * y;
                }
                if (_.fillsize) {
                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                }
                o.appendChild(fill);
            }
            s.visibility = "visible";
        };
    R.toString = function () {
        return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
    };
    var addArrow = function (o, value, isEnd) {
        var values = Str(value).toLowerCase().split("-"),
            se = isEnd ? "end" : "start",
            i = values.length,
            type = "classic",
            w = "medium",
            h = "medium";
        while (i--) {
            switch (values[i]) {
                case "block":
                case "classic":
                case "oval":
                case "diamond":
                case "open":
                case "none":
                    type = values[i];
                    break;
                case "wide":
                case "narrow": h = values[i]; break;
                case "long":
                case "short": w = values[i]; break;
            }
        }
        var stroke = o.node.getElementsByTagName("stroke")[0];
        stroke[se + "arrow"] = type;
        stroke[se + "arrowlength"] = w;
        stroke[se + "arrowwidth"] = h;
    },
    setFillAndStroke = function (o, params) {
        // o.paper.canvas.style.display = "none";
        o.attrs = o.attrs || {};
        var node = o.node,
            a = o.attrs,
            s = node.style,
            xy,
            newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
            isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
            res = o;


        for (var par in params) if (params[has](par)) {
            a[par] = params[par];
        }
        if (newpath) {
            a.path = R._getPath[o.type](o);
            o._.dirty = 1;
        }
        params.href && (node.href = params.href);
        params.title && (node.title = params.title);
        params.target && (node.target = params.target);
        params.cursor && (s.cursor = params.cursor);
        "blur" in params && o.blur(params.blur);
        if (params.path && o.type == "path" || newpath) {
            node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
            o._.dirty = 1;
            if (o.type == "image") {
                o._.fillpos = [a.x, a.y];
                o._.fillsize = [a.width, a.height];
                setCoords(o, 1, 1, 0, 0, 0);
            }
        }
        "transform" in params && o.transform(params.transform);
        if (isOval) {
            var cx = +a.cx,
                cy = +a.cy,
                rx = +a.rx || +a.r || 0,
                ry = +a.ry || +a.r || 0;
            node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
            o._.dirty = 1;
        }
        if ("clip-rect" in params) {
            var rect = Str(params["clip-rect"]).split(separator);
            if (rect.length == 4) {
                rect[2] = +rect[2] + (+rect[0]);
                rect[3] = +rect[3] + (+rect[1]);
                var div = node.clipRect || R._g.doc.createElement("div"),
                    dstyle = div.style;
                dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                if (!node.clipRect) {
                    dstyle.position = "absolute";
                    dstyle.top = 0;
                    dstyle.left = 0;
                    dstyle.width = o.paper.width + "px";
                    dstyle.height = o.paper.height + "px";
                    node.parentNode.insertBefore(div, node);
                    div.appendChild(node);
                    node.clipRect = div;
                }
            }
            if (!params["clip-rect"]) {
                node.clipRect && (node.clipRect.style.clip = "auto");
            }
        }
        if (o.textpath) {
            var textpathStyle = o.textpath.style;
            params.font && (textpathStyle.font = params.font);
            params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
            params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
            params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
            params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
        }
        if ("arrow-start" in params) {
            addArrow(res, params["arrow-start"]);
        }
        if ("arrow-end" in params) {
            addArrow(res, params["arrow-end"], 1);
        }
        if (params.opacity != null ||
            params.fill != null ||
            params.src != null ||
            params.stroke != null ||
            params["stroke-width"] != null ||
            params["stroke-opacity"] != null ||
            params["fill-opacity"] != null ||
            params["stroke-dasharray"] != null ||
            params["stroke-miterlimit"] != null ||
            params["stroke-linejoin"] != null ||
            params["stroke-linecap"] != null) {
            var fill = node.getElementsByTagName(fillString),
                newfill = false;
            fill = fill && fill[0];
            !fill && (newfill = fill = createNode(fillString));
            if (o.type == "image" && params.src) {
                fill.src = params.src;
            }
            params.fill && (fill.on = true);
            if (fill.on == null || params.fill == "none" || params.fill === null) {
                fill.on = false;
            }
            if (fill.on && params.fill) {
                var isURL = Str(params.fill).match(R._ISURL);
                if (isURL) {
                    fill.parentNode == node && node.removeChild(fill);
                    fill.rotate = true;
                    fill.src = isURL[1];
                    fill.type = "tile";
                    var bbox = o.getBBox(1);
                    fill.position = bbox.x + S + bbox.y;
                    o._.fillpos = [bbox.x, bbox.y];

                    R._preload(isURL[1], function () {
                        o._.fillsize = [this.offsetWidth, this.offsetHeight];
                    });
                } else {
                    fill.color = R.getRGB(params.fill).hex;
                    fill.src = E;
                    fill.type = "solid";
                    if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                        a.fill = "none";
                        a.gradient = params.fill;
                        fill.rotate = false;
                    }
                }
            }
            if ("fill-opacity" in params || "opacity" in params) {
                var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
                opacity = mmin(mmax(opacity, 0), 1);
                fill.opacity = opacity;
                if (fill.src) {
                    fill.color = "none";
                }
            }
            node.appendChild(fill);
            var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
            newstroke = false;
            !stroke && (newstroke = stroke = createNode("stroke"));
            if ((params.stroke && params.stroke != "none") ||
                params["stroke-width"] ||
                params["stroke-opacity"] != null ||
                params["stroke-dasharray"] ||
                params["stroke-miterlimit"] ||
                params["stroke-linejoin"] ||
                params["stroke-linecap"]) {
                stroke.on = true;
            }
            (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
            var strokeColor = R.getRGB(params.stroke);
            stroke.on && params.stroke && (stroke.color = strokeColor.hex);
            opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
            var width = (toFloat(params["stroke-width"]) || 1) * .75;
            opacity = mmin(mmax(opacity, 0), 1);
            params["stroke-width"] == null && (width = a["stroke-width"]);
            params["stroke-width"] && (stroke.weight = width);
            width && width < 1 && (opacity *= width) && (stroke.weight = 1);
            stroke.opacity = opacity;

            params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
            stroke.miterlimit = params["stroke-miterlimit"] || 8;
            params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
            if ("stroke-dasharray" in params) {
                var dasharray = {
                    "-": "shortdash",
                    ".": "shortdot",
                    "-.": "shortdashdot",
                    "-..": "shortdashdotdot",
                    ". ": "dot",
                    "- ": "dash",
                    "--": "longdash",
                    "- .": "dashdot",
                    "--.": "longdashdot",
                    "--..": "longdashdotdot"
                };
                stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
            }
            newstroke && node.appendChild(stroke);
        }
        if (res.type == "text") {
            res.paper.canvas.style.display = E;
            var span = res.paper.span,
                m = 100,
                fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
            s = span.style;
            a.font && (s.font = a.font);
            a["font-family"] && (s.fontFamily = a["font-family"]);
            a["font-weight"] && (s.fontWeight = a["font-weight"]);
            a["font-style"] && (s.fontStyle = a["font-style"]);
            fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
            s.fontSize = fontSize * m + "px";
            res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
            var brect = span.getBoundingClientRect();
            res.W = a.w = (brect.right - brect.left) / m;
            res.H = a.h = (brect.bottom - brect.top) / m;
            // res.paper.canvas.style.display = "none";
            res.X = a.x;
            res.Y = a.y + res.H / 2;

            ("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
            var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
            for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
                res._.dirty = 1;
                break;
            }

            // text-anchor emulation
            switch (a["text-anchor"]) {
                case "start":
                    res.textpath.style["v-text-align"] = "left";
                    res.bbx = res.W / 2;
                break;
                case "end":
                    res.textpath.style["v-text-align"] = "right";
                    res.bbx = -res.W / 2;
                break;
                default:
                    res.textpath.style["v-text-align"] = "center";
                    res.bbx = 0;
                break;
            }
            res.textpath.style["v-text-kern"] = true;
        }
        // res.paper.canvas.style.display = E;
    },
    addGradientFill = function (o, gradient, fill) {
        o.attrs = o.attrs || {};
        var attrs = o.attrs,
            pow = Math.pow,
            opacity,
            oindex,
            type = "linear",
            fxfy = ".5 .5";
        o.attrs.gradient = gradient;
        gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
            type = "radial";
            if (fx && fy) {
                fx = toFloat(fx);
                fy = toFloat(fy);
                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                fxfy = fx + S + fy;
            }
            return E;
        });
        gradient = gradient.split(/\s*\-\s*/);
        if (type == "linear") {
            var angle = gradient.shift();
            angle = -toFloat(angle);
            if (isNaN(angle)) {
                return null;
            }
        }
        var dots = R._parseDots(gradient);
        if (!dots) {
            return null;
        }
        o = o.shape || o.node;
        if (dots.length) {
            o.removeChild(fill);
            fill.on = true;
            fill.method = "none";
            fill.color = dots[0].color;
            fill.color2 = dots[dots.length - 1].color;
            var clrs = [];
            for (var i = 0, ii = dots.length; i < ii; i++) {
                dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
            }
            fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
            if (type == "radial") {
                fill.type = "gradientTitle";
                fill.focus = "100%";
                fill.focussize = "0 0";
                fill.focusposition = fxfy;
                fill.angle = 0;
            } else {
                // fill.rotate= true;
                fill.type = "gradient";
                fill.angle = (270 - angle) % 360;
            }
            o.appendChild(fill);
        }
        return 1;
    },
    Element = function (node, vml) {
        this[0] = this.node = node;
        node.raphael = true;
        this.id = R._oid++;
        node.raphaelid = this.id;
        this.X = 0;
        this.Y = 0;
        this.attrs = {};
        this.paper = vml;
        this.matrix = R.matrix();
        this._ = {
            transform: [],
            sx: 1,
            sy: 1,
            dx: 0,
            dy: 0,
            deg: 0,
            dirty: 1,
            dirtyT: 1
        };
        !vml.bottom && (vml.bottom = this);
        this.prev = vml.top;
        vml.top && (vml.top.next = this);
        vml.top = this;
        this.next = null;
    };
    var elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;
    elproto.transform = function (tstr) {
        if (tstr == null) {
            return this._.transform;
        }
        var vbs = this.paper._viewBoxShift,
            vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
            oldt;
        if (vbs) {
            oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
        }
        R._extractTransform(this, vbt + tstr);
        var matrix = this.matrix.clone(),
            skew = this.skew,
            o = this.node,
            split,
            isGrad = ~Str(this.attrs.fill).indexOf("-"),
            isPatt = !Str(this.attrs.fill).indexOf("url(");
        matrix.translate(1, 1);
        if (isPatt || isGrad || this.type == "image") {
            skew.matrix = "1 0 0 1";
            skew.offset = "0 0";
            split = matrix.split();
            if ((isGrad && split.noRotation) || !split.isSimple) {
                o.style.filter = matrix.toFilter();
                var bb = this.getBBox(),
                    bbt = this.getBBox(1),
                    dx = bb.x - bbt.x,
                    dy = bb.y - bbt.y;
                o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                setCoords(this, 1, 1, dx, dy, 0);
            } else {
                o.style.filter = E;
                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
            }
        } else {
            o.style.filter = E;
            skew.matrix = Str(matrix);
            skew.offset = matrix.offset();
        }
        if (oldt !== null) { // empty string value is true as well
            this._.transform = oldt;
            R._extractTransform(this, oldt);
        }
        return this;
    };
    elproto.rotate = function (deg, cx, cy) {
        if (this.removed) {
            return this;
        }
        if (deg == null) {
            return;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this._.dirtyT = 1;
        this.transform(this._.transform.concat([["r", deg, cx, cy]]));
        return this;
    };
    elproto.translate = function (dx, dy) {
        if (this.removed) {
            return this;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        if (this._.bbox) {
            this._.bbox.x += dx;
            this._.bbox.y += dy;
        }
        this.transform(this._.transform.concat([["t", dx, dy]]));
        return this;
    };
    elproto.scale = function (sx, sy, cx, cy) {
        if (this.removed) {
            return this;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
            isNaN(cx) && (cx = null);
            isNaN(cy) && (cy = null);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;

        this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
        this._.dirtyT = 1;
        return this;
    };
    elproto.hide = function () {
        !this.removed && (this.node.style.display = "none");
        return this;
    };
    elproto.show = function () {
        !this.removed && (this.node.style.display = E);
        return this;
    };
    // Needed to fix the vml setViewBox issues
    elproto.auxGetBBox = R.el.getBBox;
    elproto.getBBox = function(){
      var b = this.auxGetBBox();
      if (this.paper && this.paper._viewBoxShift)
      {
        var c = {};
        var z = 1/this.paper._viewBoxShift.scale;
        c.x = b.x - this.paper._viewBoxShift.dx;
        c.x *= z;
        c.y = b.y - this.paper._viewBoxShift.dy;
        c.y *= z;
        c.width  = b.width  * z;
        c.height = b.height * z;
        c.x2 = c.x + c.width;
        c.y2 = c.y + c.height;
        return c;
      }
      return b;
    };
    elproto._getBBox = function () {
        if (this.removed) {
            return {};
        }
        return {
            x: this.X + (this.bbx || 0) - this.W / 2,
            y: this.Y - this.H,
            width: this.W,
            height: this.H
        };
    };
    elproto.remove = function () {
        if (this.removed || !this.node.parentNode) {
            return;
        }
        this.paper.__set__ && this.paper.__set__.exclude(this);
        R.eve.unbind("raphael.*.*." + this.id);
        R._tear(this, this.paper);
        this.node.parentNode.removeChild(this.node);
        this.shape && this.shape.parentNode.removeChild(this.shape);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) if (this.attrs[has](a)) {
                res[a] = this.attrs[a];
            }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.paper.customAttributes[name], "function")) {
                    out[name] = this.paper.customAttributes[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (this.attrs && value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        var params;
        if (value != null) {
            params = {};
            params[name] = value;
        }
        value == null && R.is(name, "object") && (params = name);
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        if (params) {
            for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                this.attrs[key] = params[key];
                for (var subkey in par) if (par[has](subkey)) {
                    params[subkey] = par[subkey];
                }
            }
            // this.paper.canvas.style.display = "none";
            if (params.text && this.type == "text") {
                this.textpath.string = params.text;
            }
            setFillAndStroke(this, params);
            // this.paper.canvas.style.display = E;
        }
        return this;
    };
    elproto.toFront = function () {
        !this.removed && this.node.parentNode.appendChild(this.node);
        this.paper && this.paper.top != this && R._tofront(this, this.paper);
        return this;
    };
    elproto.toBack = function () {
        if (this.removed) {
            return this;
        }
        if (this.node.parentNode.firstChild != this.node) {
            this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
            R._toback(this, this.paper);
        }
        return this;
    };
    elproto.insertAfter = function (element) {
        if (this.removed) {
            return this;
        }
        if (element.constructor == R.st.constructor) {
            element = element[element.length - 1];
        }
        if (element.node.nextSibling) {
            element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
        } else {
            element.node.parentNode.appendChild(this.node);
        }
        R._insertafter(this, element, this.paper);
        return this;
    };
    elproto.insertBefore = function (element) {
        if (this.removed) {
            return this;
        }
        if (element.constructor == R.st.constructor) {
            element = element[0];
        }
        element.node.parentNode.insertBefore(this.node, element.node);
        R._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function (size) {
        var s = this.node.runtimeStyle,
            f = s.filter;
        f = f.replace(blurregexp, E);
        if (+size !== 0) {
            this.attrs.blur = size;
            s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
            s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
        } else {
            s.filter = f;
            s.margin = 0;
            delete this.attrs.blur;
        }
        return this;
    };

    R._engine.path = function (pathString, vml) {
        var el = createNode("shape");
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = vml.coordorigin;
        var p = new Element(el, vml),
            attr = {fill: "none", stroke: "#000"};
        pathString && (attr.path = pathString);
        p.type = "path";
        p.path = [];
        p.Path = E;
        setFillAndStroke(p, attr);
        vml.canvas && vml.canvas.appendChild(el);
        var skew = createNode("skew");
        skew.on = true;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        return p;
    };
    R._engine.rect = function (vml, x, y, w, h, r) {
        var path = R._rectPath(x, y, w, h, r),
            res = vml.path(path),
            a = res.attrs;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.r = r;
        a.path = path;
        res.type = "rect";
        return res;
    };
    R._engine.ellipse = function (vml, x, y, rx, ry) {
        var res = vml.path(),
            a = res.attrs;
        res.X = x - rx;
        res.Y = y - ry;
        res.W = rx * 2;
        res.H = ry * 2;
        res.type = "ellipse";
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            rx: rx,
            ry: ry
        });
        return res;
    };
    R._engine.circle = function (vml, x, y, r) {
        var res = vml.path(),
            a = res.attrs;
        res.X = x - r;
        res.Y = y - r;
        res.W = res.H = r * 2;
        res.type = "circle";
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            r: r
        });
        return res;
    };
    R._engine.image = function (vml, src, x, y, w, h) {
        var path = R._rectPath(x, y, w, h),
            res = vml.path(path).attr({stroke: "none"}),
            a = res.attrs,
            node = res.node,
            fill = node.getElementsByTagName(fillString)[0];
        a.src = src;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.path = path;
        res.type = "image";
        fill.parentNode == node && node.removeChild(fill);
        fill.rotate = true;
        fill.src = src;
        fill.type = "tile";
        res._.fillpos = [x, y];
        res._.fillsize = [w, h];
        node.appendChild(fill);
        setCoords(res, 1, 1, 0, 0, 0);
        return res;
    };
    R._engine.text = function (vml, x, y, text) {
        var el = createNode("shape"),
            path = createNode("path"),
            o = createNode("textpath");
        x = x || 0;
        y = y || 0;
        text = text || "";
        path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
        path.textpathok = true;
        o.string = Str(text);
        o.on = true;
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = "0 0";
        var p = new Element(el, vml),
            attr = {
                fill: "#000",
                stroke: "none",
                font: R._availableAttrs.font,
                text: text
            };
        p.shape = el;
        p.path = path;
        p.textpath = o;
        p.type = "text";
        p.attrs.text = Str(text);
        p.attrs.x = x;
        p.attrs.y = y;
        p.attrs.w = 1;
        p.attrs.h = 1;
        setFillAndStroke(p, attr);
        el.appendChild(o);
        el.appendChild(path);
        vml.canvas.appendChild(el);
        var skew = createNode("skew");
        skew.on = true;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        return p;
    };
    R._engine.setSize = function (width, height) {
        var cs = this.canvas.style;
        this.width = width;
        this.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        cs.width = width;
        cs.height = height;
        cs.clip = "rect(0 " + width + " " + height + " 0)";
        if (this._viewBox) {
            R._engine.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
        R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var paperSize = this.getSize(),
            width = paperSize.width,
            height = paperSize.height,
            H, W;
        if (fit) {
            H = height / h;
            W = width / w;
            if (w * H < width) {
                x -= (width - w * H) / 2 / H;
            }
            if (h * W < height) {
                y -= (height - h * W) / 2 / W;
            }
        }
        this._viewBox = [x, y, w, h, !!fit];
        this._viewBoxShift = {
            dx: -x,
            dy: -y,
            scale: paperSize
        };
        this.forEach(function (el) {
            el.transform("...");
        });
        return this;
    };
    var createNode;
    R._engine.initWin = function (win) {
            var doc = win.document;
            if (doc.styleSheets.length < 31) {
                doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
            } else {
                // no more room, add to the existing one
                // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx
                doc.styleSheets[0].addRule(".rvml", "behavior:url(#default#VML)");
            }
            try {
                !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
                createNode = function (tagName) {
                    return doc.createElement('<rvml:' + tagName + ' class="rvml">');
                };
            } catch (e) {
                createNode = function (tagName) {
                    return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
                };
            }
        };
    R._engine.initWin(R._g.win);
    R._engine.create = function () {
        var con = R._getContainer.apply(0, arguments),
            container = con.container,
            height = con.height,
            s,
            width = con.width,
            x = con.x,
            y = con.y;
        if (!container) {
            throw new Error("VML container not found.");
        }
        var res = new R._Paper,
            c = res.canvas = R._g.doc.createElement("div"),
            cs = c.style;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        res.width = width;
        res.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        res.coordsize = zoom * 1e3 + S + zoom * 1e3;
        res.coordorigin = "0 0";
        res.span = R._g.doc.createElement("span");
        res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
        c.appendChild(res.span);
        cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
        if (container == 1) {
            R._g.doc.body.appendChild(c);
            cs.left = x + "px";
            cs.top = y + "px";
            cs.position = "absolute";
        } else {
            if (container.firstChild) {
                container.insertBefore(c, container.firstChild);
            } else {
                container.appendChild(c);
            }
        }
        res.renderfix = function () {};
        return res;
    };
    R.prototype.clear = function () {
        R.eve("raphael.clear", this);
        this.canvas.innerHTML = E;
        this.span = R._g.doc.createElement("span");
        this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
        this.canvas.appendChild(this.span);
        this.bottom = this.top = null;
    };
    R.prototype.remove = function () {
        R.eve("raphael.remove", this);
        this.canvas.parentNode.removeChild(this.canvas);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        return true;
    };

    var setproto = R.st;
    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/eve-raphael/eve.js":
/*!*****************************************!*\
  !*** ./node_modules/eve-raphael/eve.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//  \\
//  Eve 0.5.0 - JavaScript Events Library                       \\
//  \\
//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\
//  \\

(function (glob) {
    var version = "0.5.0",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        comaseparator = /\s*,\s*/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
        firstDefined = function () {
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (typeof this[i] != "undefined") {
                    return this[i];
                }
            }
        },
        lastDefined = function () {
            var i = this.length;
            while (--i) {
                if (typeof this[i] != "undefined") {
                    return this[i];
                }
            }
        },
        objtos = Object.prototype.toString,
        Str = String,
        isArray = Array.isArray || function (ar) {
            return ar instanceof Array || objtos.call(ar) == "[object Array]";
        };
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     > Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
    \*/
        var eve = function (name, scope) {
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            out.firstDefined = firstDefined;
            out.lastDefined = lastDefined;
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out;
        };
        // Undocumented. Debug only.
        eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = isArray(name) ? name : name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    /*\
     * eve.separator
     [ method ]

     * If for some reasons you dont like default separators (`.` or `/`) you can specify yours
     * here. Be aware that if you pass a string longer than one character it will be treated as
     * a list of characters.

     - separator (string) new separator. Empty string resets to default: `.` or `/`.
    \*/
    eve.separator = function (sep) {
        if (sep) {
            sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
            sep = "[" + sep + "]";
            separator = new RegExp(sep);
        } else {
            separator = /[\.\/]/;
        }
    };
    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards `*` for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     - name (array) if you dont want to use separators, you can use array of strings
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt` function will be called before `eatIt`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.
    \*/
    eve.on = function (name, f) {
        if (typeof f != "function") {
            return function () {};
        }
        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
        for (var i = 0, ii = names.length; i < ii; i++) {
            (function (name) {
                var names = isArray(name) ? name : Str(name).split(separator),
                    e = events,
                    exist;
                for (var i = 0, ii = names.length; i < ii; i++) {
                    e = e.n;
                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
                }
                e.f = e.f || [];
                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
                    exist = true;
                    break;
                }
                !exist && e.f.push(f);
            }(names[i]));
        }
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
     | el.onclick = eve.f("click", 1, 2);
     | eve.on("click", function (a, b, c) {
     |     console.log(a, b, c); // 1, 2, [event object]
     | });
     > Arguments
     - event (string) event name
     - varargs () and any other arguments
     = (function) possible event handler function
    \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current events name contains `subname`
    \*/
    eve.nt = function (subname) {
        var cur = isArray(current_event) ? current_event.join(".") : current_event;
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
        }
        return cur;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return isArray(current_event) ? current_event : current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = {n: {}};
            return;
        }
        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
        if (names.length > 1) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                eve.off(names[i], f);
            }
            return;
        }
        names = isArray(name) ? name : Str(name).split(separator);
        var e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.off(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    ( true && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return eve; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (undefined));
})(this);


/***/ })

/******/ });
});
;/*
 * ScaleRaphael 0.8 by Zevan Rosser 2010 
 * For use with Raphael library : www.raphaeljs.com
 * Licensed under the MIT license.
 *
 * www.shapevent.com/scaleraphael/
 */
(function(){
  window.ScaleRaphael = function(container, width, height){
    var wrapper = document.getElementById(container);
    if (!wrapper.style.position) wrapper.style.position = "relative";
    wrapper.style.width = width + "px";
    wrapper.style.height = height + "px";
    wrapper.style.overflow = "hidden";
    
    var nestedWrapper;
      
    if (Raphael.type == "VML"){
      wrapper.innerHTML = "<rvml:group style='position : absolute; width: 1000px; height: 1000px; top: 0px; left: 0px' coordsize='1000,1000' class='rvml' id='vmlgroup'><\/rvml:group>";
      nestedWrapper = document.getElementById("vmlgroup");
    }else{
      wrapper.innerHTML = "<div id='svggroup'><\/div>";
      nestedWrapper = document.getElementById("svggroup");
    }
 
    var paper = new Raphael(nestedWrapper, width, height);
    var vmlDiv;
    
    if (Raphael.type == "SVG"){
      paper.canvas.setAttribute("viewBox", "0 0 "+width+" "+height);
    }else{
      vmlDiv = wrapper.getElementsByTagName("div")[0];
    }
    
    paper.changeSize = function(w, h, center, clipping){
      clipping = !clipping;
      
      var ratioW = w / width;
      var ratioH = h / height;
      var scale = ratioW < ratioH ? ratioW : ratioH;
      
      var newHeight = parseInt(height * scale);
      var newWidth = parseInt(width * scale);
      
      if (Raphael.type == "VML"){
         // scale the textpaths
       var txt = document.getElementsByTagName("textpath");
        for (var i in txt){
          var curr = txt[i];
          if (curr.style){
            if(!curr._fontSize){
              var mod = curr.style.font.split("px");
              curr._fontSize = parseInt(mod[0]);
              curr._font = mod[1];
            }
            curr.style.font = curr._fontSize * scale + "px" + curr._font;
          }
        }
        var newSize; 
        if (newWidth < newHeight){
         newSize = newWidth * 1000 / width;
        }else{
         newSize = newHeight * 1000 / height;
        }
        newSize = parseInt(newSize);
        nestedWrapper.style.width = newSize + "px";
        nestedWrapper.style.height = newSize + "px";
        if (clipping){
          nestedWrapper.style.left = parseInt((w - newWidth) / 2) + "px";
          nestedWrapper.style.top = parseInt((h - newHeight) / 2) + "px";
        }
        vmlDiv.style.overflow = "visible";
      }
      
      if (clipping){
        newWidth = w;
        newHeight = h;
      }
      
      wrapper.style.width = newWidth + "px";
      wrapper.style.height = newHeight + "px";
      paper.setSize(newWidth, newHeight);
      
      if (center){
        wrapper.style.position = "absolute";
        wrapper.style.left = parseInt((w - newWidth) / 2) + "px";
        wrapper.style.top = parseInt((h - newHeight) / 2) + "px";
      }
    }
    
    paper.scaleAll = function(amount){
      paper.changeSize(width * amount, height * amount);
    }
    
    paper.changeSize(width, height);
    
    paper.w = width;
    paper.h = height;
    
    return paper;
  }
})();
;// <![CDATA[

// Create a method callback on a javascript objects.
// Used for event handlers binding an object instance
// to a method invocation.  
// Usage:
//  on_event =  callback (m, 'some_method' [, arg1, ... ])
// When the event fires the callback will be called with 
// both the static arguments and the dynamic arguments provided
// by the event 
// Example:
//   m.some_method([arg1, arg,..., evt_arg1, evt_arg2, ...])
//

function callback (obj, method) {
    var thisobj = obj;
    var thismeth = (typeof method == "string")?thisobj[method]:method;
    var thisextra = Array.prototype.slice.call(arguments,2);
    
    return function () {
        var args = Array.prototype.slice.call(arguments);
        return thismeth.apply (thisobj, thisextra.concat(args));
    };
}

function isClientPhone () {
    // Apple
    //if (navigator.userAgent.indexOf("iPhone")>=0) return true;
    if (navigator.userAgent.indexOf("iPod")>=0) return true;    

    // Google
    if (navigator.userAgent.toLowerCase().indexOf("android")>=0) return true;      
    
    // Nokia
    if (navigator.userAgent.toLowerCase().indexOf("series60")>=0 &&
        navigator.userAgent.toLowerCase().indexOf("webkit")>=0) return true;   
    if (navigator.userAgent.toLowerCase().indexOf("symbian")>=0 &&
        navigator.userAgent.toLowerCase().indexOf("webkit")>=0) return true; 
    
    // RIM
    if (navigator.userAgent.toLowerCase().indexOf("blackberry")>=0) return true;      
    
    // Palm/HP
    if (navigator.userAgent.toLowerCase().indexOf("palm")>=0) return true;      
    if (navigator.userAgent.toLowerCase().indexOf("webos")>=0) return true;      

    // Mcrosoft
    if (navigator.userAgent.indexOf("Windows Phone OS")>=0) return true;  
    if (navigator.userAgent.indexOf("IEMobile")>=0) return true;      
    
    return false;
}

function isClientTouch () {
    // Apple
    if (navigator.userAgent.indexOf("iPad")>=0) return true;
    if (navigator.userAgent.indexOf("iPhone")>=0) return true;
    if (navigator.userAgent.indexOf("iPod")>=0) return true;   
    
    // Google
    if (navigator.userAgent.toLowerCase().indexOf("android")>=0) return true;    

    // Nokia
    if (navigator.userAgent.toLowerCase().indexOf("series60")>=0 &&
        navigator.userAgent.toLowerCase().indexOf("webkit")>=0) return true;   
    if (navigator.userAgent.toLowerCase().indexOf("symbian")>=0 &&
        navigator.userAgent.toLowerCase().indexOf("webkit")>=0) return true; 
    
    // RIM
    if (navigator.userAgent.toLowerCase().indexOf("blackberry")>=0 &&
        navigator.userAgent.toLowerCase().indexOf("webkit")>=0) return true;   
    if (navigator.userAgent.toLowerCase().indexOf("playbook")>=0 &&
        navigator.userAgent.toLowerCase().indexOf("webkit")>=0) return true;   
        
    // Palm/HP    
    if (navigator.userAgent.toLowerCase().indexOf("webos")>=0) return true;      
    
    // Mcrosoft
    if (navigator.userAgent.indexOf("Windows Phone OS")>=0) return true;         
    
    return false;
}

function isIE () {
    if (navigator.appName == 'Microsoft Internet Explorer') return true;  
    return false;
}

function isMobileSafari () {
  if (navigator.userAgent.toLowerCase().indexOf("mobile")>=0 &&
      navigator.userAgent.toLowerCase().indexOf("safari")>=0
      ) return true; 
}

// ]]>

;/*******************************************************************************
 Panoramic JavaScript Image Viewer (PanoJS) 2.0.0
 aka GSV 3.0 aka Giant-Ass Image Viewer 3

 Generates a draggable and zoomable viewer for images that would
 be otherwise too large for a browser window.  Examples would include
 maps or high resolution document scans.

 History:
   GSV 1.0 : Giant-Ass Image Viewer : http://mike.teczno.com/giant/pan/
   @author Michal Migurski <mike-gsv@teczno.com>

   GSV 2.0 : PanoJS : http://code.google.com/p/panojs/
   @author Dan Allen       <dan.allen@mojavelinux.com>
     
   GSV 3.0 : PanoJS3
   @author Dmitry Fedorov  <fedorov@ece.ucsb.edu> 

 Images must be precut into tiles: 
   a) tilemaker.py python library shipped with GSV 2.0
   b) Zoomify
   c) imagcnv 
   d) Bisque system
   e) dynamically served by websystems (requires writing TileProvider)

 
  var viewerBean = new PanoJS(element, 'tiles', 256, 3, 1);

 Copyright (c) 2005 Michal Migurski <mike-gsv@teczno.com>
                    Dan Allen <dan.allen@mojavelinux.com>
               2010 Dmitry Fedorov, Center for Bio-Image Informatics <fedorov@ece.ucsb.edu>
  
 Redistribution and use in source form, with or without modification,
 are permitted provided that the following conditions are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. The name of the author may not be used to endorse or promote products
    derived from this software without specific prior written permission.
  
 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*******************************************************************************/
 
 
function PanoJS(viewer, options) {
    
  // listeners that are notified on a move (pan) event
  this.viewerMovedListeners = [];
  // listeners that are notified on a zoom event
  this.viewerZoomedListeners = [];
  // listeners that are notified on a resize event
  this.viewerResizedListeners = [];
    
    
  if (typeof viewer == 'string')
    this.viewer = document.getElementById(viewer);
  else
    this.viewer = viewer;
    
  if (typeof options == 'undefined') options = {};
    
  if (typeof options.tileUrlProvider != 'undefined' && (options.tileUrlProvider instanceof PanoJS.TileUrlProvider) )
    this.tileUrlProvider = options.tileUrlProvider;
  else
    this.tileUrlProvider = new PanoJS.TileUrlProvider( options.tileBaseUri ? options.tileBaseUri : PanoJS.TILE_BASE_URI,
                                                       options.tilePrefix ? options.tilePrefix : PanoJS.TILE_PREFIX,
                                                       options.tileExtension ? options.tileExtension : PanoJS.TILE_EXTENSION
                                                     );

  this.xTileSize = (options.xTileSize ? options.xTileSize : PanoJS.TILE_SIZE);
  this.yTileSize = (options.yTileSize ? options.yTileSize : PanoJS.TILE_SIZE);
  this.realXTileSize = this.xTileSize;
  this.realYTileSize = this.yTileSize;
  
  
  if (options.staticBaseURL) PanoJS.STATIC_BASE_URL = options.staticBaseURL;  
      
  // assign and do some validation on the zoom levels to ensure sanity
  this.zoomLevel = (typeof options.initialZoom == 'undefined' ? -1 : parseInt(options.initialZoom));
  this.maxZoomLevel = (typeof options.maxZoom == 'undefined' ? 0 : Math.abs(parseInt(options.maxZoom)));
  if (this.zoomLevel > this.maxZoomLevel) this.zoomLevel = this.maxZoomLevel;
    
  this.initialPan = (options.initialPan ? options.initialPan : PanoJS.INITIAL_PAN);
  // map Zoom Levels to Scales (only needed if each zoom level is not a factor of 2)
  this.zoomLevelScaling = options.zoomLevelScaling;   // 'undefined' is handled in this.currentScale()
    
  this.initialized = false;
  this.surface = null;
  this.well = null;
  this.width = 0;
  this.height = 0;
  this.top = 0;
  this.left = 0;
  this.x = 0;
  this.y = 0;
  this.mark = { 'x' : 0, 'y' : 0 };
  this.pressed = false;
  this.tiles = [];
  
  this.cache = {};
  this.blankTile = options.blankTile ? options.blankTile : PanoJS.BLANK_TILE_IMAGE;
  this.loadingTile = options.loadingTile ? options.loadingTile : PanoJS.LOADING_TILE_IMAGE;      
  this.resetCache();
  this.image_size = { width: options.imageWidth, height: options.imageHeight };
  
  this.delay_ms = options.delay ? options.delay : PanoJS.DELAY_MS; 
  
  // employed to throttle the number of redraws that
  // happen while the mouse is moving
  this.moveCount = 0;
  this.slideMonitor = 0;
  this.slideAcceleration = 0;
}

// project specific variables
PanoJS.PROJECT_NAME = 'PanoJS';
PanoJS.PROJECT_VERSION = '2.0.0';
PanoJS.REVISION_FLAG = '';

// CSS definition settings
PanoJS.SURFACE_STYLE_CLASS  = 'surface';
PanoJS.SURFACE_ID           = 'viewer_contorls_surface';
PanoJS.SURFACE_STYLE_ZINDEX = 20;
PanoJS.WELL_STYLE_CLASS     = 'well';
PanoJS.CONTROLS_STYLE_CLASS = 'controls'
PanoJS.TILE_STYLE_CLASS     = 'tile';

// language settings
PanoJS.MSG_BEYOND_MIN_ZOOM = 'Cannot zoom out past the current level.';
PanoJS.MSG_BEYOND_MAX_ZOOM = 'Cannot zoom in beyond the current level.';

// defaults if not provided as constructor options
PanoJS.TILE_BASE_URI = 'tiles';
PanoJS.TILE_PREFIX = 'tile-';
PanoJS.TILE_EXTENSION = 'jpg';
PanoJS.TILE_SIZE = 256;
PanoJS.BLANK_TILE_IMAGE = 'blank.gif';
PanoJS.LOADING_TILE_IMAGE = 'blank.gif';
PanoJS.INITIAL_PAN = { 'x' : .5, 'y' : .5 };
PanoJS.USE_LOADER_IMAGE = true;
PanoJS.USE_SLIDE = true;

// Delay before positioning tiles in the viewer, see positionTiles 
// or moving the viewer, see: ThumbnailControl
PanoJS.DELAY_MS = 500;

// dima
if (!PanoJS.STATIC_BASE_URL) PanoJS.STATIC_BASE_URL = '';
PanoJS.CREATE_CONTROL_ZOOMIN = true;
PanoJS.CREATE_CONTROL_ZOOM11 = true;
PanoJS.CREATE_CONTROL_ZOOMOUT = true;
PanoJS.CREATE_CONTROL_MAXIMIZE = true;
PanoJS.CREATE_INFO_CONTROLS = true;
PanoJS.CREATE_OSD_CONTROLS = true;
PanoJS.CREATE_THUMBNAIL_CONTROLS = (isClientPhone() ? false : true);

PanoJS.MAX_OVER_ZOOM = 2;
PanoJS.PRE_CACHE_AMOUNT = 3; // 1 - only visible, 2 - more, 3 - even more

// dima
// The dafault is to pan with wheel events on a mac and zoom on other systems
PanoJS.USE_WHEEL_FOR_ZOOM = (navigator.userAgent.indexOf("Mac OS X")>0 ? false: true);
// the deltas on Firefox and Chrome are 40 times smaller than on Safari or IE
PanoJS.WHEEL_SCALE = (navigator.userAgent.toLowerCase().indexOf('chrome')>-1 ? 1 : 40);

// dima: keys used by keyboard handlers
// right now event is attached to 'document', can't make sure which element is current, skip for now
PanoJS.USE_KEYBOARD = false;
PanoJS.KEY_MOVE_THROTTLE = 15;
PanoJS.KEY_UP    = 38;
PanoJS.KEY_DOWN  = 40;
PanoJS.KEY_RIGHT = 39;
PanoJS.KEY_LEFT  = 37;
PanoJS.KEY_MINUS = {109:0, 189:0};
PanoJS.KEY_PLUS  = {107:0, 187:0};

// performance tuning variables
PanoJS.MOVE_THROTTLE = 3;
PanoJS.SLIDE_DELAY = 40;
PanoJS.SLIDE_ACCELERATION_FACTOR = 5;

// the following are calculated settings
PanoJS.DOM_ONLOAD = (navigator.userAgent.indexOf('KHTML') >= 0 ? false : true);
PanoJS.GRAB_MOUSE_CURSOR = (navigator.userAgent.search(/KHTML|Opera/i) >= 0 ? 'pointer' : (document.attachEvent ? 'url(grab.cur)' : '-moz-grab'));
PanoJS.GRABBING_MOUSE_CURSOR = (navigator.userAgent.search(/KHTML|Opera/i) >= 0 ? 'move' : (document.attachEvent ? 'url(grabbing.cur)' : '-moz-grabbing'));



PanoJS.prototype.init = function() {

    if (document.attachEvent)
      document.body.ondragstart = function() { return false; }
 
    if (this.width == 0 && this.height == 0) {
      this.width = this.viewer.offsetWidth;
      this.height = this.viewer.offsetHeight;
    }
   
    // calculate the zoom level based on what fits best in window
    if (this.zoomLevel < 0 || this.zoomLevel > this.maxZoomLevel) {
            var new_level = 0;
            // here MAX defines partial fit and MIN would use full fit
            while ((Math.max(this.xTileSize, this.yTileSize)) * Math.pow(2, new_level) <= Math.max(this.width, this.height) && 
                   new_level<=this.maxZoomLevel) {
                this.zoomLevel = new_level;
                new_level += 1;   
            }
    }
      
    // move top level up and to the left so that the image is centered
    var fullWidth = this.xTileSize * Math.pow(2, this.zoomLevel);
    var fullHeight = this.yTileSize * Math.pow(2, this.zoomLevel);
    if (this.image_size) {
      var cur_size = this.currentImageSize();  
      fullWidth = cur_size.width;
      fullHeight = cur_size.height;    
    }
    this.x = Math.floor((fullWidth - this.width) * -this.initialPan.x);
    this.y = Math.floor((fullHeight - this.height) * -this.initialPan.y);

       
    // offset of viewer in the window
    for (var node = this.viewer; node; node = node.offsetParent) {
      this.top += node.offsetTop;
      this.left += node.offsetLeft;
    }
        
    // Create viewer elements
    if (!this.surface) {
      this.surface = document.createElement('div');
      this.surface.className = PanoJS.SURFACE_STYLE_CLASS;
      this.surface.id = PanoJS.SURFACE_ID;
      this.viewer.appendChild(this.surface); 
      this.surface.style.cursor = PanoJS.GRAB_MOUSE_CURSOR;
      this.surface.style.zIndex = PanoJS.SURFACE_STYLE_ZINDEX;
    }
     
    if (!this.well) {
      this.well = document.createElement('div');
      this.well.className = PanoJS.WELL_STYLE_CLASS;
      this.viewer.appendChild(this.well);
    }


    // set event handlers for controls buttons
    if ((PanoJS.CREATE_CONTROL_ZOOMIN
         || PanoJS.CREATE_CONTROL_ZOOM11
         || PanoJS.CREATE_CONTROL_ZOOMOUT
         || PanoJS.CREATE_CONTROL_MAXIMIZE) && !this.controls)
      this.controls = new PanoControls(this);
         
    if (PanoJS.CREATE_INFO_CONTROLS && !this.info_control) {
      this.info_control = new InfoControl(this);
    }          

    if (PanoJS.CREATE_OSD_CONTROLS && !this.osd_control) {
      this.osd_control = new OsdControl(this);
    }     
  
    if (PanoJS.CREATE_THUMBNAIL_CONTROLS && !this.thumbnail_control) {
      this.thumbnail_control = new ThumbnailControl(this);
    }     
        
    this.prepareTiles();
    this.initialized = true;

    // dima: Setup UI events
    this.ui_listener = this.surface;
    if (isIE()) this.ui_listener = this.viewer; // issues with IE, hack it
    
    this.ui_listener.onmousedown   = callback(this, this.mousePressedHandler);
    this.ui_listener.onmouseup     = callback(this, this.mouseReleasedHandler);
    this.ui_listener.onmouseout    = callback(this, this.mouseReleasedHandler);
    this.ui_listener.oncontextmenu = function() {return false;}; 
    this.ui_listener.ondblclick    = callback(this, this.doubleClickHandler);
    if (PanoJS.USE_KEYBOARD)
      document.onkeydown  = callback(this, this.keyboardHandler);

    this.ui_listener.onmousewheel = callback(this, this.mouseWheelHandler);
    // dima: Firefox standard
    if (!('onmousewheel' in document.documentElement))
      this.surface.addEventListener ("DOMMouseScroll", callback(this, this.mouseScrollHandler), false);
        
    // dima: support for HTML5 touch interfaces like iphone and android
    this.ui_listener.ontouchstart    = callback(this, this.touchStartHandler);
    this.ui_listener.ontouchmove     = callback(this, this.touchMoveHandler);
    this.ui_listener.ongesturestart  = callback(this, this.gestureStartHandler);
    this.ui_listener.ongesturechange = callback(this, this.gestureChangeHandler);
    this.ui_listener.ongestureend    = callback(this, this.gestureEndHandler);        
    
    // notify listners
    this.notifyViewerZoomed();    
    this.notifyViewerMoved();  
};

PanoJS.prototype.viewerDomElement = function() {    
    return this.viewer;
};

PanoJS.prototype.thumbnailURL = function() {       
    return this.tileUrlProvider.assembleUrl(0, 0, 0);
};

PanoJS.prototype.imageSize = function() {        
    return this.image_size;
};     

PanoJS.prototype.currentImageSize = function() {    
    var scale = this.currentScale();
    return { width: this.image_size.width * scale, height: this.image_size.height * scale };       
};    
    
PanoJS.prototype.prepareTiles = function() {        
    var rows = Math.ceil(this.height / this.yTileSize)+ PanoJS.PRE_CACHE_AMOUNT;
    var cols = Math.ceil(this.width / this.xTileSize)+ PanoJS.PRE_CACHE_AMOUNT;
           
    for (var c = 0; c < cols; c++) {
      var tileCol = [];
            
      for (var r = 0; r < rows; r++) {
        /**
         * element is the DOM element associated with this tile
         * posx/posy are the pixel offsets of the tile
         * xIndex/yIndex are the index numbers of the tile segment
         * qx/qy represents the quadrant location of the tile
         */
        /*
        var tile = {
          'element' : null,
          'posx' : 0,
          'posy' : 0,
          'xIndex' : c,
          'yIndex' : r,
          'qx' : c,
          'qy' : r
        };*/
        
        var tile = new Tile(this, c, r);
        
        tileCol.push(tile);
      }
      this.tiles.push(tileCol);
    }
        
    this.positionTiles();
};
    
/**
 * Position the tiles based on the x, y coordinates of the
 * viewer, taking into account the motion offsets, which
 * are calculated by a motion event handler.
 */
PanoJS.prototype.positionTiles = function(motion, reset) {       
    // default to no motion, just setup tiles
    if (typeof motion == 'undefined') {
      motion = { 'x' : 0, 'y' : 0 };
    }

    var cur_size = this.currentImageSize();
       
    for (var c = 0; c < this.tiles.length; c++) {
      for (var r = 0; r < this.tiles[c].length; r++) {
        var tile = this.tiles[c][r];
                
        tile.posx = (tile.xIndex * this.xTileSize) + this.x + motion.x;
        tile.posy = (tile.yIndex * this.yTileSize) + this.y + motion.y;
                
        var visible = true;
                
        if (tile.posx > this.width  +this.xTileSize ) {
          // tile moved out of view to the right
          // consider the tile coming into view from the left
          do {
            tile.xIndex -= this.tiles.length;
            tile.posx = (tile.xIndex * this.xTileSize) + this.x + motion.x;
          } while (tile.posx > this.width +this.xTileSize  );
                    
          if (tile.posx + this.xTileSize < 0) {
            visible = false;
          }
                    
        } else {
          // tile may have moved out of view from the left
          // if so, consider the tile coming into view from the right
          while (tile.posx < -this.xTileSize  *2) {
            tile.xIndex += this.tiles.length;
            tile.posx = (tile.xIndex * this.xTileSize) + this.x + motion.x;
          }
                    
          if (tile.posx > this.width  +this.xTileSize) {
            visible = false;
          }
        }
                
        if (tile.posy > this.height   +this.yTileSize) {
          // tile moved out of view to the bottom
          // consider the tile coming into view from the top
          do {
            tile.yIndex -= this.tiles[c].length;
            tile.posy = (tile.yIndex * this.yTileSize) + this.y + motion.y;
          } while (tile.posy > this.height   +this.yTileSize);
                    
          if (tile.posy + this.yTileSize < 0) {
            visible = false;
          }
                    
        } else {
          // tile may have moved out of view to the top
          // if so, consider the tile coming into view from the bottom
          while (tile.posy < -this.yTileSize  *2) {
            tile.yIndex += this.tiles[c].length;
            tile.posy = (tile.yIndex * this.yTileSize) + this.y + motion.y;
          }
                    
          if (tile.posy > this.height   +this.yTileSize) {
            visible = false;
          }
        }
                
        // additional constraint                
        if (tile.xIndex*this.xTileSize >= cur_size.width) visible = false;
        if (tile.yIndex*this.yTileSize >= cur_size.height) visible = false;                    
                
        // display the image if visible
        if (visible)
            this.assignTileImage(tile);
        else
            this.removeTileFromWell(tile);
      }
    }

    // reset the x, y coordinates of the viewer according to motion
    if (reset) {
      this.x += motion.x;
      this.y += motion.y;
    }
};
    
PanoJS.prototype.removeTileFromWell = function(tile) {        
    if (!tile || !tile.element || !tile.element.parentNode) return;
    this.well.removeChild(tile.element);   
    tile.element = null;      
};
    
   
/**
 * Determine the source image of the specified tile based
 * on the zoom level and position of the tile.  If forceBlankImage
 * is specified, the source should be automatically set to the
 * null tile image.  This method will also setup an onload
 * routine, delaying the appearance of the tile until it is fully
 * loaded, if configured to do so.
 */
PanoJS.prototype.assignTileImage = function(tile) {    
    var tileImgId, src;
    var useBlankImage = false;
        
    // check if image has been scrolled too far in any particular direction
    // and if so, use the null tile image
    if (!useBlankImage) {
      var left = tile.xIndex < 0;
      var high = tile.yIndex < 0;
      
      // dima: allow zooming in more than 100%
      var cur_size = this.currentImageSize();      
      var right = tile.xIndex*this.xTileSize >= cur_size.width;
      var low   = tile.yIndex*this.yTileSize >= cur_size.height;              
            
      if (high || left || low || right) {
        useBlankImage = true;
      }
    }

    if (useBlankImage) {
      tileImgId = 'blank';
      src = this.cache['blank'].src;
    }
    else {
      tileImgId = src = this.tileUrlProvider.assembleUrl(tile.xIndex, tile.yIndex, this.zoomLevel);
    }

    // only remove tile if identity is changing
    if (tile.element != null &&
      tile.element.parentNode != null &&
      tile.element.relativeSrc != null &&      
      tile.element.relativeSrc != src) {
      delete this.cache[tile.element.relativeSrc];
      this.well.removeChild(tile.element);
    }

    var scale = Math.max(this.xTileSize / this.realXTileSize, 1.0);
    var tileImg = this.cache[tileImgId];

    //window.localStorage (details)
    //var available = navigator.mozIsLocallyAvailable("my-image-file.png", true);

    // create cache if not exist
    if (tileImg == null)
      //tileImg = this.cache[tileImgId] = this.createPrototype('', src); // delayed loading
      tileImg = this.cache[tileImgId] = this.createPrototype(src);
    else
      tileImg.done = true;

    //if (tileImg.done)  
    if (tileImg.naturalWidth && tileImg.naturalHeight && tileImg.naturalWidth>0 && tileImg.naturalHeight>0) {
      tileImg.style.width = tileImg.naturalWidth*scale + 'px';
      tileImg.style.height = tileImg.naturalHeight*scale + 'px';   
    } else 
    if (isIE() && tileImg.offsetWidth>0 && tileImg.offsetHeight>0) { // damn IE does not have naturalWidth ...
      tileImg.style.width = tileImg.offsetWidth*scale + 'px';
      tileImg.style.height = tileImg.offsetHeight*scale + 'px';         
    }

    // error handling for tile image loading - simply try to reload image after timeout
    tileImg.onerror = function() {
        var $this = $(this);
        // only try to reload if this is the first failure
        if (!$this.hasClass('failed')) {
          $this.addClass('failed');
          setTimeout(function(){
            var s = tileImg.src;
            tileImg.src = s;    // no change, but is enough to trigger reload
          }, 1000); // try to reload src after timeout - 1 sec seems to work OK
        }
      };

    if ( tileImg.done || !tileImg.delayed_loading &&
         (useBlankImage || !PanoJS.USE_LOADER_IMAGE || tileImg.complete || (tileImg.image && tileImg.image.complete))  ) {
      tileImg.onload = null;
      // tileImg.onerror = null;  // seems we can't remove error handler here
      $(tileImg).removeClass('failed');
      if (tileImg.image) tileImg.image.onload = null;
            
      if (tileImg.parentNode == null) {
        tile.element = this.well.appendChild(tileImg);
      }  
      tileImg.done = true;      
    } else {
      var loadingImg = this.createPrototype(this.cache['loading'].src);
      loadingImg.targetSrc = tileImgId;
            
      var well = this.well;
      tile.element = well.appendChild(loadingImg);
      tileImg.onload = function() {
        // make sure our destination is still present
        if (loadingImg.parentNode && loadingImg.targetSrc == tileImgId) {
          tileImg.style.top = loadingImg.style.top;
          tileImg.style.left = loadingImg.style.left;
          if (tileImg.naturalWidth && tileImg.naturalHeight && tileImg.naturalWidth>0 && tileImg.naturalHeight>0) {
            tileImg.style.width = tileImg.naturalWidth*scale + 'px';
            tileImg.style.height = tileImg.naturalHeight*scale + 'px'; 
          } else 
          if (isIE() && tileImg.offsetWidth>0 && tileImg.offsetHeight>0) { // damn IE does not have naturalWidth ...
            tileImg.style.width = tileImg.offsetWidth*scale + 'px';
            tileImg.style.height = tileImg.offsetHeight*scale + 'px';         
          }          
          well.replaceChild(tileImg, loadingImg);
          tile.element = tileImg;
        } else {
          // delete a tile if the destination is not present anymore
          if (loadingImg.parentNode) {
            well.removeChild(loadingImg);   
            tile.element = null;      
          }           
        }

        // since we've loaded OK, I assume this frees up memory (not confirmed)
        tileImg.onerror = null;
                
        tileImg.onload = function() {};
        return false;
      }

      // dima, fetch image after onload method is set-up
      if (!tileImg.done) {// && tileImg.delayed_loading) {
        tileImg.src = tileImg.relativeSrc;
      }
            
      // konqueror only recognizes the onload event on an Image
      // javascript object, so we must handle that case here
      if (!PanoJS.DOM_ONLOAD) {
        tileImg.image = new Image();
        tileImg.image.onload = tileImg.onload;
        tileImg.image.src = tileImg.src;
      }
    }
    
    if (tile.element) {
      tile.element.style.top = tile.posy + 'px';
      tile.element.style.left = tile.posx + 'px';    
    }
    
};

PanoJS.prototype.createPrototype = function(src, src_to_load) {        
    var img = document.createElement('img');
    img.src = src;
    if (!src_to_load)
      img.relativeSrc = src;
    else {
      img.relativeSrc = src_to_load;
      img.delayed_loading = true;
    }
    img.className = PanoJS.TILE_STYLE_CLASS;
    //img.style.width = this.xTileSize + 'px';
    //img.style.height = this.yTileSize + 'px';
    return img;
};
    
PanoJS.prototype.currentScale = function() {      
    var scale = 1.0;
    if (this.zoomLevel<this.maxZoomLevel) {
      var zoomDiff = Math.abs(this.zoomLevel-this.maxZoomLevel);
      if (this.zoomLevelScaling && typeof this.zoomLevelScaling[zoomDiff] != "undefined") {
        scale = this.zoomLevelScaling[zoomDiff];
      } else {
        scale = 1.0 / Math.pow(2, Math.abs(this.zoomLevel-this.maxZoomLevel));
      }
    }
    else
    if (this.zoomLevel>this.maxZoomLevel)
      scale = Math.pow(2, Math.abs(this.zoomLevel-this.maxZoomLevel));
    return scale;
};
  
PanoJS.prototype.toImageFromViewer = function(p) {   
    var scale = this.currentScale();
    p.x = (p.x / scale);
    p.y = (p.y / scale);    
    return p;
};  
    
PanoJS.prototype.toViewerFromImage = function(p) {       
    var scale = this.currentScale();
    p.x = (p.x * scale);
    p.y = (p.y * scale);    
    return p;
};  

PanoJS.prototype.addViewerMovedListener = function(listener) {          
    this.viewerMovedListeners.push(listener);
};
    
PanoJS.prototype.addViewerZoomedListener = function(listener) {  
    this.viewerZoomedListeners.push(listener);
};

PanoJS.prototype.addViewerResizedListener = function(listener) {      
    this.viewerResizedListeners.push(listener);
};  
    
// Notify listeners of a zoom event on the viewer.
PanoJS.prototype.notifyViewerZoomed = function() {         
    var scale = this.currentScale();
    var w = this.surface.clientWidth / scale;
    var h = this.surface.clientHeight / scale;  
    
    for (var i = 0; i < this.viewerZoomedListeners.length; i++)
      this.viewerZoomedListeners[i].viewerZoomed( new PanoJS.ZoomEvent(this.x, this.y, this.zoomLevel, scale, w, h) );
};
  
// dima : Notify listeners of a zoom event on the viewer
PanoJS.prototype.notifyViewerResized = function() {      
    var scale = this.currentScale();
    var w = this.surface.clientWidth / scale;
    var h = this.surface.clientHeight / scale;  
    for (var i = 0; i < this.viewerResizedListeners.length; i++)
      this.viewerResizedListeners[i].viewerResized( new PanoJS.ResizeEvent(this.x, this.y, w, h) );
};
    
// Notify listeners of a move event on the viewer.
PanoJS.prototype.notifyViewerMoved = function(coords) {         
    if (typeof coords == 'undefined') {
      coords = { 'x' : 0, 'y' : 0 };
    }
        
    for (var i = 0; i < this.viewerMovedListeners.length; i++) {
      this.viewerMovedListeners[i].viewerMoved( new PanoJS.MoveEvent( this.x + (coords.x - this.mark.x),
                                                                      this.y + (coords.y - this.mark.y)
                                                                    )
                                              );
    }
};

PanoJS.prototype.queuePositionTiles = function (motion, reset) {
  if (this.positionTiles_timeout) clearTimeout (this.positionTiles_timeout);
  this.positionTiles_timeout = setTimeout(callback(this, 'positionTilesNow', motion, reset), this.delay_ms);
}

PanoJS.prototype.positionTilesNow = function (motion, reset) {
  if (this.positionTiles_timeout) clearTimeout (this.positionTiles_timeout);
  this.positionTiles_timeout = null;
  this.positionTiles(motion, reset);
}


PanoJS.prototype.zoom = function(direction) {       
    // ensure we are not zooming out of range
    if (this.zoomLevel + direction < 0) {
      if (PanoJS.MSG_BEYOND_MIN_ZOOM) {
        alert(PanoJS.MSG_BEYOND_MIN_ZOOM);
      }
      return;
    }
    if (this.zoomLevel+direction > this.maxZoomLevel+PanoJS.MAX_OVER_ZOOM) return;
    
    this.blank();
    this.resetCache();       
        
    if (this.zoomLevel+direction > this.maxZoomLevel) {
        //dima
        var scale_dif = (this.zoomLevel+direction - this.maxZoomLevel) * 2;
        this.xTileSize = this.realXTileSize*scale_dif;
        this.yTileSize = this.realYTileSize*scale_dif;
    } else {
        this.xTileSize = this.realXTileSize;
        this.yTileSize = this.realYTileSize;
    }
    var coords = { 'x' : Math.floor(this.width / 2), 'y' : Math.floor(this.height / 2) };
        
    var before = {
      'x' : (coords.x - this.x),
      'y' : (coords.y - this.y)
    };
        
    var scaleDiff = Math.pow(2, direction);

    // if we're zooming less than 100%, check for non-default scaling as specified by this.zoomLevelScaling
    if (this.zoomLevel<this.maxZoomLevel || (this.zoomLevel+direction)<this.maxZoomLevel) {
      var oldZoom = Math.abs(this.zoomLevel-this.maxZoomLevel),
        newZoom = Math.abs((this.zoomLevel + direction) -this.maxZoomLevel);
      if (this.zoomLevelScaling && (typeof this.zoomLevelScaling[oldZoom] != "undefined") && this.zoomLevelScaling[newZoom]) {
        scaleDiff = this.zoomLevelScaling[newZoom] / this.zoomLevelScaling[oldZoom]
      }
    }

    var after = {
      'x' : Math.floor(before.x * scaleDiff),
      'y' : Math.floor(before.y * scaleDiff)
    };
        
    this.x = coords.x - after.x;
    this.y = coords.y - after.y;
    this.zoomLevel += direction;
        
    if (this.delay_ms<=0)
      this.positionTiles();
    else
      this.queuePositionTiles();
    this.notifyViewerZoomed();
};

PanoJS.prototype.update = function() {        
    this.blank();
    this.resetCache();
    this.positionTiles();
    if (this.thumbnail_control) this.thumbnail_control.update();
};    
    
// Clear all the tiles from the well for a complete reinitialization of the
// viewer. At this point the viewer is not considered to be initialized.
PanoJS.prototype.clear = function() {         
    this.blank();
    this.initialized = false;
    this.tiles = [];
    this.resetCache();
};
    
PanoJS.prototype.resetCache = function() {        
    this.cache = {};
    this.cache['blank'] = new Image();
    this.cache['blank'].src = this.blankTile;
    if (this.blankTile != this.loadingTile) {
      this.cache['loading'] = new Image();
      this.cache['loading'].src = this.loadingTile;
    } else {
      this.cache['loading'] = this.cache['blank'];
    }    
};    
    
// Remove all tiles from the well, which effectively "hides"
// them for a repaint.
PanoJS.prototype.blank = function() {      
    for (imgId in this.cache) {
      var img = this.cache[imgId];
      if (!img) continue;
      img.onload = function() {};
      if (img.image) {
        img.image.onload = function() {};
      }
            
      if (img.parentNode != null) {
        this.well.removeChild(img);
      }
    }
    this.resetCache();
};
    
// Method specifically for handling a mouse move event.  A direct
// movement of the viewer can be achieved by calling positionTiles() directly.
PanoJS.prototype.moveViewer = function(coords) {
  if (coords.x == this.x && coords.y == this.y) return;
  this.positionTiles({ 'x' : (coords.x - this.mark.x), 'y' : (coords.y - this.mark.y) });
  this.notifyViewerMoved(coords);
};
    
// dima: Event that works for any input, expects DeltaX and DeltaY
PanoJS.prototype.moveViewerBy = function(coords) {     
      this.positionTiles(coords, true);
      //this.notifyViewerMoved(coords);
      this.notifyViewerMoved();
},
  
  
/**
 * Make the specified coords the new center of the image placement.
 * This method is typically triggered as the result of a double-click
 * event.  The calculation considers the distance between the center
 * of the viewable area and the specified (viewer-relative) coordinates.
 * If absolute is specified, treat the point as relative to the entire
 * image, rather than only the viewable portion.
 */
PanoJS.prototype.recenter = function(coords, absolute, skip_motion) {   
  skip_motion = typeof(skip_motion) != 'undefined' ? skip_motion : false; 
  if (absolute) {
    coords.x += this.x;
    coords.y += this.y;
  }
  if (coords.x == this.x && coords.y == this.y) return;      
      
  var motion = {
    'x' : Math.floor((this.width / 2) - coords.x),
    'y' : Math.floor((this.height / 2) - coords.y)
  };
      
  if (motion.x == 0 && motion.y == 0) {
    return;
  }
      
  if (PanoJS.USE_SLIDE && !skip_motion) {
    var target = motion;
    var x, y;
    // handle special case of vertical movement
    if (target.x == 0) {
      x = 0;
      y = this.slideAcceleration;
    }
    else {
      var slope = Math.abs(target.y / target.x);
      x = Math.round(Math.pow(Math.pow(this.slideAcceleration, 2) / (1 + Math.pow(slope, 2)), .5));
      y = Math.round(slope * x);
    }
    
    motion = {
      'x' : Math.min(x, Math.abs(target.x)) * (target.x < 0 ? -1 : 1),
      'y' : Math.min(y, Math.abs(target.y)) * (target.y < 0 ? -1 : 1)
    }
  }
      
  this.positionTiles(motion, true);
  this.notifyViewerMoved();
      
  if (!PanoJS.USE_SLIDE && !skip_motion) {
    return;
  }
      
  var newcoords = {
    'x' : coords.x + motion.x,
    'y' : coords.y + motion.y
  };
      
  var self = this;
  // TODO: use an exponential growth rather than linear (should also depend on how far we are going)
  // FIXME: this could be optimized by calling positionTiles directly perhaps
  this.slideAcceleration += PanoJS.SLIDE_ACCELERATION_FACTOR;
  this.slideMonitor = setTimeout(function() { self.recenter(newcoords); }, PanoJS.SLIDE_DELAY );
};

PanoJS.prototype.resize = function() {     
  // IE fires a premature resize event
  if (!this.initialized) return;
  if (this.width == this.viewer.offsetWidth && this.height == this.viewer.offsetHeight) return;
      
  var newWidth = this.viewer.offsetWidth;
  var newHeight = this.viewer.offsetHeight;
  this.viewer.style.display = 'none';
  this.clear();
  this.width = newWidth;
  this.height = newHeight;
      
  this.prepareTiles();
  this.positionTiles();
  this.viewer.style.display = '';
  this.initialized = true;
  this.notifyViewerMoved();
  this.notifyViewerResized();
};

PanoJS.prototype.toggleMaximize = function() {     
  if (!this.maximized) this.maximized = false;
  this.maximized = !this.maximized;
  
  var vd = this.viewer;
  if (this.maximized) {
      this.viewer_style = { 'width': vd.style.width, 'height': vd.style.height,
          'position': vd.style.position, 'zIndex': vd.style.zIndex,
          'left': vd.style.left, 'top': vd.style.top };
      this.document_style = { 'padding': document.body.style.padding, 'overflow': document.body.style.overflow };
      
      vd.style.position = 'fixed';
      //vd.style.position = 'absolute';            
      vd.style.zIndex   = '14999';
      //vd.style.left     = window.scrollX + 'px';
      //vd.style.top      = window.scrollY + 'px';
      vd.style.left     = '0px';
      vd.style.top      = '0px';
      vd.style.width    = '100%';
      vd.style.height   = '100%'; 
      document.body.style.overflow = 'hidden';
      document.body.style.padding = '0';
      if (isMobileSafari()) {
        vd.style.left = window.scrollX + 'px';
        vd.style.top  = window.scrollY + 'px';
        vd.style.width    = window.innerWidth + 'px';
        vd.style.height   = window.innerHeight + 'px';        
      }
  } else {
      document.body.style.padding = this.document_style.padding;
      document.body.style.overflow = this.document_style.overflow;          
      vd.style.width    = this.viewer_style.width;
      vd.style.height   = this.viewer_style.height;
      vd.style.position = this.viewer_style.position;
      vd.style.zIndex   = this.viewer_style.zIndex;
      vd.style.left     = this.viewer_style.left;
      vd.style.top      = this.viewer_style.top;
  }
  
  this.resize();
};
  
/**
 * Resolve the coordinates from this mouse event by subtracting the
 * offset of the viewer in the browser window (or frame).  This does
 * take into account the scroll offset of the page.
 */
PanoJS.prototype.resolveCoordinates = function(e) {    
  if (this.maximized)
    return { 'x' : e.clientX, 'y' : e.clientY };

  return {
    'x' : (e.pageX || (e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft))) - this.left,
    'y' : (e.pageY || (e.clientY + (document.documentElement.scrollTop || document.body.scrollTop))) - this.top
  };
};

PanoJS.prototype.press = function(coords) {     
  this.activate(true);
  this.mark = coords;
  this.mouse_have_moved = false;
};

PanoJS.prototype.release = function(coords) {  
  this.activate(false);
  var motion = {
    'x' : (coords.x - this.mark.x),
    'y' : (coords.y - this.mark.y)
  };
      
  this.x += motion.x;
  this.y += motion.y;
  this.mark = { 'x' : 0, 'y' : 0 };
  this.mouse_have_moved = false;        
};
  
/**
 * Activate the viewer into motion depending on whether the mouse is pressed or
 * not pressed.  This method localizes the changes that must be made to the
 * layers.
 */
PanoJS.prototype.activate = function(pressed) {   
  this.pressed = pressed;
  this.surface.style.cursor = (pressed ? PanoJS.GRABBING_MOUSE_CURSOR : PanoJS.GRAB_MOUSE_CURSOR);
  this.ui_listener.onmousemove = (pressed ? callback(this, this.mouseMovedHandler) : function() {});
};
  
/**
 * Check whether the specified point exceeds the boundaries of
 * the viewer's primary image.
 */
PanoJS.prototype.pointExceedsBoundaries = function(coords) {     
  return (coords.x < this.x ||
          coords.y < this.y ||
          coords.x > (this.xTileSize * Math.pow(2, this.zoomLevel) + this.x) ||
          coords.y > (this.xTileSize * Math.pow(2, this.zoomLevel) + this.y));
};
  
// QUESTION: where is the best place for this method to be invoked?
PanoJS.prototype.resetSlideMotion = function() {     
  // QUESTION: should this be > 0 ? 
  if (this.slideMonitor != 0) {
    clearTimeout(this.slideMonitor);
    this.slideMonitor = 0;
  }
      
  this.slideAcceleration = 0;
};



//-------------------------------------------------------
// Mouse Events
//-------------------------------------------------------

PanoJS.prototype.blockPropagation = function (e) {
    if (e.stopPropagation) e.stopPropagation(); // DOM Level 2
    else e.cancelBubble = true;                 // IE    
    if (e.preventDefault) e.preventDefault(); // prevent image dragging
    else e.returnValue=false;    
}

PanoJS.prototype.mousePressedHandler = function(e) {
  e = e ? e : window.event;
  this.blockPropagation(e);
    
  // only grab on left-click
  var coords = this.resolveCoordinates(e);
  //if (this.pointExceedsBoundaries(coords))
    this.press(coords);
    
  // NOTE: MANDATORY! must return false so event does not propagate to well!
  return false;
};

PanoJS.prototype.mouseReleasedHandler = function(e) {
  e = e ? e : window.event;
  if (!this.pressed) return false;
  var coords = this.resolveCoordinates(e);    
  var motion = {
        'x' : (coords.x - this.mark.x),
        'y' : (coords.y - this.mark.y)
  };        
  var moved = this.mouse_have_moved;
  this.release(coords);
    
  // only if there was little movement
  if (moved || motion.x>5 || motion.y>5) return false;
    
  if (e.button == 2) {
    this.blockPropagation(e);      
    this.zoom(-1);    
  } else
  // move on one click
  if (e.button < 2) {
    //if (!this.pointExceedsBoundaries(coords)) {
         this.resetSlideMotion();
         this.recenter(coords);
    //}        
  }
    
  return false;    
};

PanoJS.prototype.mouseMovedHandler = function(e) {
  e = e ? e : window.event;
    
  // only move on left-click
  if (e.button < 2) {
    this.mouse_have_moved = true;
    this.moveCount++;
    if (this.moveCount % PanoJS.MOVE_THROTTLE == 0)
      this.moveViewer(this.resolveCoordinates(e));
  }
  return false;        
};

PanoJS.prototype.doubleClickHandler = function(e) {
  e = e ? e : window.event;
  //var coords = this.resolveCoordinates(e);
  //if (!this.pointExceedsBoundaries(coords)) {
    //this.resetSlideMotion();
    //this.recenter(coords);        
    this.zoom(1);
  //}
  return false;  
};

PanoJS.prototype.mouseWheelHandler = function(e) {
  e = e ? e : window.event;
  this.blockPropagation(e);     
  
  if (PanoJS.USE_WHEEL_FOR_ZOOM) {
      if (e.wheelDelta<0) this.zoom(-1);
      else                
      if (e.wheelDelta>0) this.zoom(1);  
  } else {
      var dx = e.wheelDeltaX/PanoJS.WHEEL_SCALE;
      var dy = e.wheelDeltaY/PanoJS.WHEEL_SCALE;
      this.moveViewerBy({'x': dx,'y': dy});
  }  
  return false;      
};

PanoJS.prototype.mouseScrollHandler = function(e) {
  e = e ? e : window.event;
  this.blockPropagation(e); 
  
  // Here we only have delta Y, so for firefox only Zoom will be implemented
  //var wheelData = e.detail * -1 * PanoJS.WHEEL_SCALE; // adjust delta value in sync with Webkit    
  if (e.detail<0) this.zoom(1);
  else                
  if (e.detail>0) this.zoom(-1);
  
  return false;  
};

//----------------------------------------------------------------------
// keyboard events
//----------------------------------------------------------------------

PanoJS.prototype.keyboardHandler = function(e) {
  if (!PanoJS.USE_KEYBOARD) return;  
  e = e ? e : window.event;
  var key = e.keyCode ? e.keyCode : e.which;
  
  if (key in PanoJS.KEY_MINUS) {
      this.blockPropagation(e); 
      this.zoom(-1);
      return false;      
  } else 
  if (key in PanoJS.KEY_PLUS) {
      this.blockPropagation(e); 
      this.zoom(1);
      return false;
  } else
  if (key == PanoJS.KEY_UP) {
      this.blockPropagation(e); 
      this.moveViewerBy({'x': 0,'y': -PanoJS.KEY_MOVE_THROTTLE});
      return false;      
  } else 
  if (key == PanoJS.KEY_RIGHT) {
      this.blockPropagation(e); 
      this.moveViewerBy({'x': PanoJS.KEY_MOVE_THROTTLE,'y': 0});      
      return false;      
  } else 
  if (key == PanoJS.KEY_DOWN) {
      this.blockPropagation(e); 
      this.moveViewerBy({'x': 0,'y': PanoJS.KEY_MOVE_THROTTLE});      
      return false;      
  } else 
  if (key == PanoJS.KEY_LEFT) {
      this.blockPropagation(e); 
       this.moveViewerBy({'x': -PanoJS.KEY_MOVE_THROTTLE,'y': 0});      
      return false;
  }  
  
}

//----------------------------------------------------------------------
// touch events
//----------------------------------------------------------------------

PanoJS.prototype.touchStartHandler = function(e) {
  e = e ? e : window.event;
  if (e == null) return false;
    
  if (e.touches.length == 1) { // Only deal with one finger
      // prevent anything else happening for this event further
      this.blockPropagation(e);   
      
      // actully store the initial touch move position
      var touch = e.touches[0]; // Get the information for finger #1
      this.touch_start = {'x': touch.clientX,'y': touch.clientY}; 
  }
  return false;       
}

PanoJS.prototype.touchMoveHandler = function(e) {
  e = e ? e : window.event;
  if (e == null) return false;
  
  if (e.touches.length==1 && this.touch_start) { // Only deal with one finger
      // prevent anything else happening for this event further
      this.blockPropagation(e);          
      
      // move
      var touch = e.touches[0]; // Get the information for finger #1    
      var p = {'x': touch.clientX-this.touch_start.x,'y': touch.clientY-this.touch_start.y};
      this.moveViewerBy(p); 
      this.touch_start = {'x': touch.clientX,'y': touch.clientY}; 
  }
  return false;       
}


//----------------------------------------------------------------------
// gesture events
//----------------------------------------------------------------------

PanoJS.prototype.gestureStartHandler = function(e) {
  e = e ? e : window.event;
  if (e == null) return false;  
  this.blockPropagation(e);
  this.gesture_current_scale = 1.0;
  this.gesture_image_scale = this.currentScale();  
  return false;              
}

PanoJS.prototype.gestureChangeHandler = function(e) {
  e = e ? e : window.event;
  if (e == null) return false;  
  this.blockPropagation(e);      
  
  if (e.scale/this.gesture_current_scale>2.0) {
    this.gesture_current_scale = e.scale;
    this.zoom(1);
  } else 
  if (e.scale/this.gesture_current_scale<0.5) {
    this.gesture_current_scale = e.scale;
    this.zoom(-1);
  }
  
  if (this.osd_control) {
    e.image_scale = this.gesture_image_scale;
    e.gesture_current_scale = this.gesture_current_scale;
    this.osd_control.viewerZooming(e); 
  }
  
  return false;       
}

PanoJS.prototype.gestureEndHandler = function(e) {
  e = e ? e : window.event;
  if (e == null) return false;  
  this.blockPropagation(e);      
  if (this.osd_control) this.osd_control.show(false);
  
  // e.scale e.rotation
  //if (e.scale>1) this.zoom(1);
  //else
  //if (e.scale<1) this.zoom(-1);  
  return false;       
}


//-------------------------------------------------------
// Control Events
//-------------------------------------------------------

PanoJS.prototype.zoomInHandler = function(e) {
  this.zoom(1);
};

PanoJS.prototype.zoomOutHandler = function(e) {
  this.zoom(-1);
};

PanoJS.prototype.zoom11Handler = function(e) {
  this.zoom(this.maxZoomLevel-this.zoomLevel);
};

PanoJS.prototype.maximizeHandler = function(e) {
  this.toggleMaximize();  
};


//-------------------------------------------------------
// PanoJS Events
//-------------------------------------------------------

PanoJS.MoveEvent = function(x, y) {
  this.x = x;
  this.y = y;
};

PanoJS.ZoomEvent = function(x, y, level, scale, width, height) {
  this.x = x;
  this.y = y;
  this.level = level;
  this.scale = scale;
  this.width = width;
  this.height = height;   
};

PanoJS.ResizeEvent = function(x, y, width, height) {
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;
};




//-------------------------------------------------------
// Tile
//-------------------------------------------------------
    
function Tile(viewer, x, y) {
    this.viewer = viewer;  
    this.element = null;
    this.posx = 0;
    this.posy = 0;
    this.xIndex = x;
    this.yIndex = y;
    this.qx = x;
    this.qy = y;
};

Tile.prototype.createDOMElements = function() {
    //this.dom_info.innerHTML = "";
};

//-------------------------------------------------------
// TileUrlProvider
//-------------------------------------------------------

PanoJS.TileUrlProvider = function(baseUri, prefix, extension) {
  this.baseUri = baseUri;
  this.prefix = prefix;
  this.extension = extension;
}

PanoJS.TileUrlProvider.prototype = {
assembleUrl: function(xIndex, yIndex, zoom) {
    return this.baseUri + '/' +
    this.prefix + zoom + '-' + xIndex + '-' + yIndex + '.' + this.extension +
    (PanoJS.REVISION_FLAG ? '?r=' + PanoJS.REVISION_FLAG : '');
}
}


;/*******************************************************************************
  Controls - creates buttons for zooming and, full screen 
  
  GSV 3.0 : PanoJS3
  @author Dmitry Fedorov  <fedorov@ece.ucsb.edu>   
  
  Copyright (c) 2010 Dmitry Fedorov, Center for Bio-Image Informatics
  
  using: isClientTouch() and isClientPhone() from utils.js

*******************************************************************************/

PanoJS.CONTROL_IMAGE_ZOOMIN   = "32px_plus.png";
PanoJS.CONTROL_IMAGE_ZOOM11   = "32px_11.png";
PanoJS.CONTROL_IMAGE_ZOOMOUT  = "32px_minus.png";
PanoJS.CONTROL_IMAGE_MAXIMIZE = "32px_show.png";

PanoJS.CONTROL_IMAGE_ZOOMIN_TOUCH   = "64px_plus.png";
PanoJS.CONTROL_IMAGE_ZOOM11_TOUCH   = "64px_11.png";
PanoJS.CONTROL_IMAGE_ZOOMOUT_TOUCH  = "64px_minus.png";
PanoJS.CONTROL_IMAGE_MAXIMIZE_TOUCH = "64px_show.png";

PanoJS.CONTROL_STYLE = "position: absolute; z-index: 30; "; //opacity:0.5; filter:alpha(opacity=50); ";

PanoJS.CONTROL_ZOOMIN = {
    className : "zoomIn",
    image : (isClientTouch() ? PanoJS.CONTROL_IMAGE_ZOOMIN_TOUCH : PanoJS.CONTROL_IMAGE_ZOOMIN),
    title : "Zoom in",
    style : PanoJS.CONTROL_STYLE + " top: 10px; left: 10px; width: 20px;",
};

PanoJS.CONTROL_ZOOM11 = {
    className : "zoom11",
    image : (isClientTouch() ? PanoJS.CONTROL_IMAGE_ZOOM11_TOUCH : PanoJS.CONTROL_IMAGE_ZOOM11),
    title : "Zoom 1:1",
    style : PanoJS.CONTROL_STYLE + " top: 40px; left: 10px; width: 20px;",
};

PanoJS.CONTROL_ZOOMOUT = {
    className : "zoomOut",
    image : (isClientTouch() ? PanoJS.CONTROL_IMAGE_ZOOMOUT_TOUCH : PanoJS.CONTROL_IMAGE_ZOOMOUT),
    title : "Zoom out",
    style : PanoJS.CONTROL_STYLE + " top: 70px; left: 10px; width: 20px;",
};

PanoJS.CONTROL_MAXIMIZE = {
    className : "maximize",
    image : (isClientTouch() ? PanoJS.CONTROL_IMAGE_MAXIMIZE_TOUCH : PanoJS.CONTROL_IMAGE_MAXIMIZE),
    title : "Maximize",
    style : PanoJS.CONTROL_STYLE + " top: 10px; right: 10px; width: 20px;",
};

if (isClientTouch()) {
  PanoJS.CONTROL_ZOOMIN.style   = PanoJS.CONTROL_STYLE + " top: 15px;  left: 15px;  width: 36px;";
  PanoJS.CONTROL_ZOOM11.style   = PanoJS.CONTROL_STYLE + " top: 75px;  left: 15px;  width: 36px;";
  PanoJS.CONTROL_ZOOMOUT.style  = PanoJS.CONTROL_STYLE + " top: 135px; left: 15px;  width: 36px;";
  PanoJS.CONTROL_MAXIMIZE.style = PanoJS.CONTROL_STYLE + " top: 15px;  right: 15px; width: 36px;";
}

if (isClientPhone()) {
  PanoJS.CONTROL_ZOOMIN.style   = PanoJS.CONTROL_STYLE + " top: 30px;  left: 30px;  width: 96px;";
  PanoJS.CONTROL_ZOOM11.style   = PanoJS.CONTROL_STYLE + " top: 180px; left: 30px;  width: 96px;";
  PanoJS.CONTROL_ZOOMOUT.style  = PanoJS.CONTROL_STYLE + " top: 320px; left: 30px;  width: 96px;";
  PanoJS.CONTROL_MAXIMIZE.style = PanoJS.CONTROL_STYLE + " top: 30px;  right: 30px; width: 96px;";
}



function PanoControls(viewer) {
    this.viewer = viewer;  
    this.initControls();
    this.createDOMElements();
}

PanoControls.prototype.initControls = function() {
  if (PanoJS.CONTROL_UPDATED_URLS) return;
  PanoJS.CONTROL_ZOOMIN.image   = PanoJS.STATIC_BASE_URL+PanoJS.CONTROL_ZOOMIN.image;
  PanoJS.CONTROL_ZOOM11.image   = PanoJS.STATIC_BASE_URL+PanoJS.CONTROL_ZOOM11.image;
  PanoJS.CONTROL_ZOOMOUT.image  = PanoJS.STATIC_BASE_URL+PanoJS.CONTROL_ZOOMOUT.image;
  PanoJS.CONTROL_MAXIMIZE.image = PanoJS.STATIC_BASE_URL+PanoJS.CONTROL_MAXIMIZE.image;
  PanoJS.CONTROL_UPDATED_URLS   = true;
}

PanoControls.prototype.createDOMElements = function() {
    this.dom_element = this.viewer.viewerDomElement();
      
    if (PanoJS.CREATE_CONTROL_ZOOMIN) {
      this.createButton (PanoJS.CONTROL_ZOOMIN);
    }
    if (PanoJS.CREATE_CONTROL_ZOOM11) {
      this.createButton (PanoJS.CONTROL_ZOOM11);
    }
    if (PanoJS.CREATE_CONTROL_ZOOMOUT) {
      this.createButton (PanoJS.CONTROL_ZOOMOUT);
    }
    if (PanoJS.CREATE_CONTROL_MAXIMIZE) {
      this.createButton (PanoJS.CONTROL_MAXIMIZE);
    }
}

PanoControls.prototype.createButton = function(control) {
      
    var className = control.className;
    var src = control.image;
    var title = control.title;
    var style = control.style;
    
    var btn = document.createElement('span');
    btn.className = className;
    this.dom_element.appendChild(btn); 

    if (style) {
      btn.setAttribute("style", style);
      btn.style.cssText = style;   
    }
    
    var img = document.createElement('img');
    img.src = src;
    if (title) img.title = title;
    if (btn.style.width) img.style.width = btn.style.width;
    btn.appendChild(img);    
    
    btn.onclick = callback(this.viewer, this.viewer[btn.className + 'Handler']); 
                
    return btn;
}


;/*******************************************************************************
  BisqueISPyramid - creates an image URL pyramid based on Bisque Image Service
  <http://www.bioimage.ucsb.edu/downloads/Bisque%20Database>
  
  GSV 3.0 : PanoJS3
  @author Dmitry Fedorov  <fedorov@ece.ucsb.edu>   
  
  Copyright (c) 2010 Dmitry Fedorov, Center for Bio-Image Informatics

*******************************************************************************/

function formatInt(n, pad) {
    var s = n.toString();
    while (s.length<pad)
        s = '0'+s;
    return s;
};   

// -----------------------------------------------------
// BisqueISLevel
// -----------------------------------------------------

function BisqueISLevel( width, height, xtilesize, ytilesize, level ) {
    this.width = width;
    this.height = height;
    this.xtiles = Math.ceil( width / xtilesize );
    this.ytiles = Math.ceil( height / ytilesize );
    this.level = level;
}

BisqueISLevel.prototype.tiles = function() {
    return this.xtiles * this.ytiles;
}

// -----------------------------------------------------
// BisqueISPyramid
// -----------------------------------------------------

function BisqueISPyramid( width, height, xtilesize, ytilesize, levels ) {
    this.width = width;
    this.height = height;
    this.xtilesize = xtilesize;
    this.ytilesize = ytilesize;
    this._pyramid = Array();
    
    var level_id = 0;
    var level_width = width;    
    var level_height = height;   
    var min_size = (Math.min(ytilesize,xtilesize) / 2) + 1;
    // pyramid can only have mazimum 6 levels
    while (level_id < levels) {
        var level = new BisqueISLevel( level_width, level_height, xtilesize, ytilesize, level_id );
        this._pyramid.push( level );
        if (levels > 1 ) {
            level_width  = Math.floor( level_width / (levels-1) );
            level_height = Math.floor( level_height / (levels-1) );
        } else {
            level_width  = Math.floor( level_width );
            level_height = Math.floor( level_height );
        }
        level_id++;
    }
    this._pyramid.reverse();
    
    this.length = this._pyramid.length;
    this.levels = this._pyramid.length;
}

BisqueISPyramid.prototype.getMaxLevel = function() {
    return this.levels - 1;    
}

BisqueISPyramid.prototype.getLevel = function( level ) {
    if (level<this._pyramid.length)
        return this._pyramid[ level ];    
    else
        return this._pyramid[ this._pyramid.length-1 ];          
}

BisqueISPyramid.prototype.tiles_upto_level = function( level ) {
    var tiles = 0;
    for (var i = 0; i < level; i++) {
        tiles = tiles + this._pyramid[i].tiles();
    }
    return tiles;
}

BisqueISPyramid.prototype.tiles = function() {
    return this.tiles_upto_level( this.levels );
}

BisqueISPyramid.prototype.tile_index = function( level, x_coordinate, y_coordinate ) {
    return x_coordinate + y_coordinate * this._pyramid[ level ].xtiles + this.tiles_upto_level( level );
}

BisqueISPyramid.prototype.tile_filename = function( level, x_coordinate, y_coordinate ) {
    var l = this.getLevel(level).level;
    var x = x_coordinate;
    var y = y_coordinate;
    return 'tile=' + l + ',' + x + ',' + y + ',' + this.xtilesize + ',' + this.ytilesize;
}


;/*******************************************************************************
  ImgcnvPyramid - creates an image URL pyramid based on imgcnv tool
  <http://www.bioimage.ucsb.edu/downloads/BioImage%20Convert>
  
  GSV 3.0 : PanoJS3
  @author Dmitry Fedorov  <fedorov@ece.ucsb.edu>   
  
  Copyright (c) 2010 Dmitry Fedorov, Center for Bio-Image Informatics

*******************************************************************************/

function formatInt(n, pad) {
    var s = n.toString();
    while (s.length<pad)
        s = '0'+s;
    return s;
};   

// -----------------------------------------------------
// ImgcnvLevel
// -----------------------------------------------------

function ImgcnvLevel( width, height, tilesize, level ) {
    this.width = width;
    this.height = height;
    this.xtiles = Math.ceil( width / tilesize );
    this.ytiles = Math.ceil( height / tilesize );
    this.level = level;
}

ImgcnvLevel.prototype.tiles = function() {
    return this.xtiles * this.ytiles;
}

// -----------------------------------------------------
// ImgcnvPyramid
// -----------------------------------------------------

function ImgcnvPyramid( width, height, tilesize ) {
    this.width = width;
    this.height = height;
    this.tilesize = tilesize;
    this._pyramid = Array();
    
    var level_id = 0;
    var level_width = width;    
    var level_height = height;   
    var min_size = (tilesize / 2) + 1;
    while (level_width > min_size || level_height > min_size ) {      
    //while (level_width > tilesize | level_height > tilesize ) {
        var level = new ImgcnvLevel( level_width, level_height, tilesize, level_id );
        this._pyramid.push( level );
        level_width  = Math.floor( level_width / 2 );
        level_height = Math.floor( level_height / 2 );
        level_id++;
    }
    this._pyramid.reverse();
    
    this.length = this._pyramid.length;
    this.levels = this._pyramid.length;
}

ImgcnvPyramid.prototype.getMaxLevel = function() {
    return this.levels - 1;    
}

ImgcnvPyramid.prototype.getLevel = function( level ) {
    if (level<this._pyramid.length)
        return this._pyramid[ level ];    
    else
        return this._pyramid[ this._pyramid.length-1 ];          
}

ImgcnvPyramid.prototype.tiles_upto_level = function( level ) {
    var tiles = 0;
    for (var i = 0; i < level; i++) {
        tiles = tiles + this._pyramid[i].tiles();
    }
    return tiles;
}

ImgcnvPyramid.prototype.tiles = function() {
    return this.tiles_upto_level( this.levels );
}

ImgcnvPyramid.prototype.tile_index = function( level, x_coordinate, y_coordinate ) {
    return x_coordinate + y_coordinate * this._pyramid[ level ].xtiles + this.tiles_upto_level( level );
}

ImgcnvPyramid.prototype.tile_filename = function( level, x_coordinate, y_coordinate ) {
    var l = formatInt( this.getLevel(level).level , 3);
    var x = formatInt(x_coordinate, 3);
    var y = formatInt(y_coordinate, 3);    
    return "" + l + "_" + x + "_" + y + ".jpg";//?"+level;    
}


;/*******************************************************************************
  ZoomifyAJAX - creates an image URL pyramid based on Zoomify tiles
  <http://www.staremapy.cz/zoomifyjs/>
  <http://www.zoomify.com/>
  
  GSV 3.0 : PanoJS3
  @author Klokan Petr Pridal
  
  Copyright (c) Klokan Petr Pridal

*******************************************************************************/

function ZoomifyLevel( width, height, tilesize ) {
    this.width = width;
    this.height = height;
    this.xtiles = Math.ceil( width / tilesize );
    this.ytiles = Math.ceil( height / tilesize );
}
ZoomifyLevel.prototype.tiles = function() {
    return this.xtiles * this.ytiles;
}

function ZoomifyPyramid( width, height, tilesize ) {
    this.width = width;
    this.height = height;
    this.tilesize = tilesize;
    this._pyramid = Array();
    var level = new ZoomifyLevel( width, height, tilesize );
    while (level.width > tilesize | level.height > tilesize ) {
        this._pyramid.push( level );
        level = new ZoomifyLevel( Math.floor( level.width / 2 ), Math.floor( level.height / 2 ), tilesize )
    }
    this._pyramid.push( level );
    this._pyramid.reverse();

    this.length = this._pyramid.length;
    this.levels = this._pyramid.length;
    // tiles() is needed
    //this.tiles = this.tiles_upto_level( this.levels );
}

ZoomifyPyramid.prototype.getMaxLevel = function() {
    return this.levels - 1;    
}

ZoomifyPyramid.prototype.tiles_upto_level = function( level ) {
    var tiles = 0;
    for (var i = 0; i < level; i++) {
        tiles = tiles + this._pyramid[i].tiles();
    }
    return tiles;
}
ZoomifyPyramid.prototype.tiles = function() {
    return this.tiles_upto_level( this.levels );
}
ZoomifyPyramid.prototype.tile_index = function( level, x_coordinate, y_coordinate ) {
    return x_coordinate + y_coordinate * this._pyramid[ level ].xtiles + this.tiles_upto_level( level );
}
ZoomifyPyramid.prototype.tile_filename = function( level, x_coordinate, y_coordinate ) {
    return "TileGroup" + Math.floor( this.tile_index( level, x_coordinate, y_coordinate ) / this.tilesize ) + "/" + level + "-" + x_coordinate + "-" + y_coordinate + ".jpg";
}


;/*******************************************************************************
  ThumbnailControl - creates thumbnail navigator and listens to the viewer for
                     view transformations
  
  GSV 3.0 : PanoJS3
  @author Dmitry Fedorov  <fedorov@ece.ucsb.edu>   
  
  Copyright (c) 2010 Dmitry Fedorov, Center for Bio-Image Informatics
  
  using: isClientTouch() and isClientPhone() from utils.js

*******************************************************************************/

PanoJS.CONTROL_THUMBNAIL_SHOW_MINIMIZE = true;
PanoJS.CONTROL_THUMBNAIL_STYLE = "position: absolute; z-index: 60; opacity:0.5; filter:alpha(opacity=50); ";
PanoJS.CONTROL_IMAGE_PLUS      = "16px_plus.png";
PanoJS.CONTROL_IMAGE_MINUS     = "16px_minus.png";
PanoJS.CONTROL_IMAGE_PROGRESS  = "progress_128.gif";

function trim(v, l, h) {
  if (v<l) return l;
  else
  if (v>h) return h;
  else
  return v;    
}  

function ThumbnailControl(viewer) {
  this.move_delay_ms = viewer.delay_ms;  // Delay before moving the viewer
  
  this.viewer = viewer;
  this.initControls();   
  this.createDOMElements();

  this.scale = 1;
  this.x = 0;
  this.y = 0;  
  this.width = 128;  
  this.height = 128; 
  
  this.viewer.addViewerMovedListener(this);
  this.viewer.addViewerZoomedListener(this);
  this.viewer.addViewerResizedListener(this);    
    
  // load thumbnail image
  this.update();
}

ThumbnailControl.prototype.initControls = function() {
  if (PanoJS.CONTROL_THUMBNAIL_UPDATED_URLS) return;
  PanoJS.CONTROL_IMAGE_PLUS     = PanoJS.STATIC_BASE_URL + PanoJS.CONTROL_IMAGE_PLUS;
  PanoJS.CONTROL_IMAGE_MINUS    = PanoJS.STATIC_BASE_URL + PanoJS.CONTROL_IMAGE_MINUS;
  PanoJS.CONTROL_IMAGE_PROGRESS = PanoJS.STATIC_BASE_URL + PanoJS.CONTROL_IMAGE_PROGRESS;
  PanoJS.CONTROL_THUMBNAIL_UPDATED_URLS = true;
}

ThumbnailControl.prototype.update = function() {
  this.dom_image.onload = callback(this, this.init);
  this.dom_image.src = this.viewer.thumbnailURL();
}

ThumbnailControl.prototype.init = function() {
  this.dom_image.onload = null;  
  if (this.dom_image_progress 
      && this.dom_image_progress.parentNode)
    this.dom_element.removeChild(this.dom_image_progress);   
  
  // the thumbnail image may be larger that the space allocated for the thumbnail view
  // resize control accordingly to the larger side
  if (this.dom_image.width >= this.dom_image.height) {
    this.dom_image.width = PanoJS.CONTROL_THUMBNAIL_SIZE;
    this.dom_element.style.height = this.dom_image.height+'px';
  } else { // if (this.dom_image.width < this.dom_image.height)
    this.dom_image.height = PanoJS.CONTROL_THUMBNAIL_SIZE;    
    this.dom_element.style.width = this.dom_image.width+'px';    
  }
  
  // store thumbnmail control size for maximizing
  this.dom_width = this.dom_element.style.width;
  this.dom_height = this.dom_element.style.height;  
  
  this.tw = this.dom_image.width;
  this.th = this.dom_image.height;  
  this.thumbscale = this.tw / this.viewer.imageSize().width;

  this.viewer.notifyViewerZoomed();
  this.viewer.notifyViewerMoved();
}

ThumbnailControl.prototype.createDOMElements = function() {
    var de = this.viewer.viewerDomElement();

    this.dom_element = document.createElement('div');
    this.dom_element.className = 'thumbnail';
    de.appendChild(this.dom_element); 
    PanoJS.CONTROL_THUMBNAIL_SIZE = Math.max(this.dom_element.clientWidth, this.dom_element.clientHeight);
    PanoJS.CONTROL_THUMBNAIL_BORDER = (this.dom_element.offsetWidth - this.dom_element.clientWidth) / 2;
      
    this.dom_surface = document.createElement('div');
    this.dom_surface.className = 'thumbnail_surface';
    this.dom_element.appendChild(this.dom_surface); 

    this.dom_roi = document.createElement('div');
    this.dom_roi.className = 'thumbnail_roi';
    this.dom_element.appendChild(this.dom_roi); 

    this.dom_roi_prev = document.createElement('div');
    this.dom_roi_prev.className = 'thumbnail_roi_preview';
    this.dom_element.appendChild(this.dom_roi_prev); 
    
    this.dom_scale = document.createElement('span');
    this.dom_scale.className = 'thumbnail_scale';
    this.dom_element.appendChild(this.dom_scale); 

    this.dom_image_progress = document.createElement('img');
    this.dom_element.appendChild(this.dom_image_progress); 
    this.dom_image_progress.width = '128';
    this.dom_image_progress.height = '128';    
    this.dom_image_progress.src = PanoJS.CONTROL_IMAGE_PROGRESS;
    
    this.dom_image = document.createElement('img');
    this.dom_element.appendChild(this.dom_image); 

    if (isIE()) {
        // Using dom_element instead of dom_surface as IE gets the mouse events on the
        // dom_image element and bubbles up from there, making dom_surface never
        // see them.
        this.dom_element.onmousedown = callback (this, this.onmousedown );
        this.dom_element.onmouseup   = callback (this, this.onmouseup );
        this.dom_element.onmousemove = callback (this, this.onmousemove );
        this.dom_element.onmouseout  = callback (this, this.onmouseout );
    } else {
        // Using dom_element instead of dom_surface as IE gets the mouse events on the
        // dom_image element and bubbles up from there, making dom_surface never
        // see them.
        this.dom_surface.onmousedown = callback (this, this.onmousedown );
        this.dom_surface.onmouseup   = callback (this, this.onmouseup );
        this.dom_surface.onmousemove = callback (this, this.onmousemove );
        this.dom_surface.onmouseout  = callback (this, this.onmouseout );
    }
    
    if (PanoJS.CONTROL_THUMBNAIL_SHOW_MINIMIZE) {
        var style = PanoJS.CONTROL_THUMBNAIL_STYLE + " bottom: 16px; right: 1px; width: 16px;"
        this.btn = document.createElement('span');
        this.dom_element.appendChild(this.btn);
        this.btn.setAttribute("style", style);
        this.btn.style.cssText = style;   
        
        this.img = document.createElement('img');
        this.img.src = PanoJS.CONTROL_IMAGE_MINUS;
        if (this.btn.style.width) this.img.style.width = this.btn.style.width;
        this.btn.appendChild(this.img);    
        
        this.btn.onclick = callback(this, this.toggleMinimize); 
    }
}

ThumbnailControl.prototype.toggleMinimize = function(e) {
    if (!this.minimized) this.minimized=false;
    this.minimized = !this.minimized;

    if (this.minimized) {
        this.img.src = PanoJS.CONTROL_IMAGE_PLUS;
        this.dom_element.style.width = '17px';
        this.dom_element.style.height = '17px'; 

        this.dom_surface.style.display  = 'none';
        this.dom_roi.style.display      = 'none';
        this.dom_roi_prev.style.display = 'none';        
        this.dom_scale.style.display    = 'none';
        this.dom_image.style.display    = 'none';
        
    } else {
        this.img.src = PanoJS.CONTROL_IMAGE_MINUS;
        this.dom_element.style.width = this.dom_width;
        this.dom_element.style.height = this.dom_height;
        
        this.dom_surface.style.display  = '';
        this.dom_roi.style.display      = '';
        this.dom_roi_prev.style.display = '';               
        this.dom_scale.style.display    = '';
        this.dom_image.style.display    = '';
    }
}

ThumbnailControl.prototype.viewerMoved = function(e) {
    if (this.dom_image.onload) return
    if (!this.dom_roi || typeof this.dom_roi == 'undefined') return;
    var img_x = -1.0 * (e.x / this.scale);
    var img_y = -1.0 * (e.y / this.scale);  
    var tx = trim( img_x * this.thumbscale, 0, this.tw);
    var ty = trim( img_y * this.thumbscale, 0, this.th);
    var w = trim(this.width, 0, this.viewer.imageSize().width-img_x);
    var h = trim(this.height, 0, this.viewer.imageSize().height-img_y);
    if (img_x<0) w += img_x;
    if (img_y<0) h += img_y;  

    this.dom_roi.style.left = tx + 'px';
    this.dom_roi.style.top  = ty + 'px';   
    this.dom_roi.style.width = trim(1, w*this.thumbscale-2, this.tw-tx-PanoJS.CONTROL_THUMBNAIL_BORDER) + 'px';
    this.dom_roi.style.height = trim(1, h*this.thumbscale-2, this.th-ty-PanoJS.CONTROL_THUMBNAIL_BORDER) + 'px';
    
    this.dom_roi_prev.style.left = tx + 'px';
    this.dom_roi_prev.style.top  = ty + 'px';   
    this.dom_roi_prev.style.width = trim(1, w*this.thumbscale-2, this.tw-tx-PanoJS.CONTROL_THUMBNAIL_BORDER) + 'px';
    this.dom_roi_prev.style.height = trim(1, h*this.thumbscale-2, this.th-ty-PanoJS.CONTROL_THUMBNAIL_BORDER) + 'px';
}

ThumbnailControl.prototype.viewerZoomed = function(e) {
    this.scale  = e.scale;
    this.width  = e.width;
    this.height = e.height;
    //if (this.dom_scale) this.dom_scale.innerHTML = this.scale*100 + '%';   
    this.viewerMoved(e);
}

ThumbnailControl.prototype.viewerResized = function(e) {
    this.width  = e.width;
    this.height = e.height;
    this.viewerMoved(e);
}

ThumbnailControl.prototype.moveViewer = function (e) {
    if (!this.viewer) return;
    var mx = e.offsetX != undefined ? e.offsetX : e.layerX;
    var my = e.offsetY != undefined ? e.offsetY : e.layerY; 
    var x = (mx / this.thumbscale);
    var y = (my / this.thumbscale);   
    
    this.viewer.resetSlideMotion();
    PanoJS.USE_SLIDE = false;
    this.viewer.recenter( this.viewer.toViewerFromImage({'x': x, 'y': y}), true, true );
    PanoJS.USE_SLIDE = true;    
}

ThumbnailControl.prototype.movePreview = function (e) {
    var mx = e.offsetX != undefined ? e.offsetX : e.layerX;
    var my = e.offsetY != undefined ? e.offsetY : e.layerY; 
    mx -= this.dom_roi_prev.offsetWidth/2;
    my -= this.dom_roi_prev.offsetHeight/2;
    this.dom_roi_prev.style.left = mx + 'px';
    this.dom_roi_prev.style.top  = my + 'px';
}

ThumbnailControl.prototype.moveViewerNow = function (e) {
    if (this.move_timeout) clearTimeout (this.move_timeout);
    this.move_timeout = null;
    this.moveViewer(e);
}

ThumbnailControl.prototype.queueMove = function (e) {
  this.movePreview(e);
  if (this.move_timeout) clearTimeout (this.move_timeout);
  // IE8 releases references in the event object before the timer ticks
  // leading to "member not found" errors. Making a shallow copy of
  // members we are interested in.
  if (isIE()) {
      var x = {};
      x.offsetX = e.offsetX;
      x.offsetY = e.offsetY;
      this.move_timeout = setTimeout(callback(this, 'moveViewerNow', x), this.move_delay_ms);
  } else {
      this.move_timeout = setTimeout(callback(this, 'moveViewerNow', e), this.move_delay_ms);
  }
}

ThumbnailControl.prototype.blockPropagation = function (e) {
  if (e.stopPropagation) e.stopPropagation(); // DOM Level 2
  else e.cancelBubble = true;                 // IE    
  if (e.preventDefault) e.preventDefault(); // prevent image dragging
  else e.returnValue = false;        
}

ThumbnailControl.prototype.onmousedown = function (e) {
    if (!e) e = window.event;  // IE event model
    if (e == null) return false;
    this.blockPropagation(e);

    this.mouse_pressed = true;  
    if (this.dom_surface) this.dom_surface.style.cursor = 'move';
    //this.moveViewer(e);
    return false;
}

ThumbnailControl.prototype.onmouseup = function (e) {
    if (!e) e = window.event;  // IE event model  
    if (e == null) return false; 
    this.blockPropagation(e);

    // UE sends mouseup events even after mouseout
    if (!this.mouse_pressed) return false;

    this.mouse_pressed = false; 
    if (this.dom_surface) this.dom_surface.style.cursor = 'default';
    this.moveViewer(e);
    return false;    
}

ThumbnailControl.prototype.onmousemove = function (e) {
    if (!e) e = window.event;  // IE event model  
    if (e == null) return false;
    this.blockPropagation(e);        

    if (!this.mouse_pressed) return false;
    if(isIE()) {
        if ((e.offsetX + ',' + e.offsetY) == this.mousemoveoffset) {
            // IE keeps firing mousemove events after a mouse button is pressed
            // resulting in weird errors
            return false;
        }
        this.mousemoveoffset = e.offsetX + ',' + e.offsetY;
    }
    if (this.move_delay_ms<=0)
      this.moveViewer(e);
    else      
      this.queueMove(e);
    return false;      
}

ThumbnailControl.prototype.onmouseout = function (e) {
    if (!e) e = window.event;  // IE event model  
    if (e == null) return false; 
    
    if(isIE()) {
        // IE triggers mouseout events on both the image and the wrapping div,
        // as well as on the ROI indicators, so we must filter out the unwanted
        // ones.
        if (e.offsetX >= 0 && e.offsetX < this.dom_image.width &&
            e.offsetY >= 0 && e.offsetY < this.dom_image.height) {
            return false;
        }
    }
    this.blockPropagation(e);    
 
    this.mouse_pressed = false;   
    if (this.dom_surface) this.dom_surface.style.cursor = 'default';
    return false;    
}

;/*******************************************************************************
  InfoControl - creates text about an image at the bottom
  
  GSV 3.0 : PanoJS3
  @author Dmitry Fedorov  <fedorov@ece.ucsb.edu>   
  
  Copyright (c) 2010 Dmitry Fedorov, Center for Bio-Image Informatics
  
  using: isClientTouch() and isClientPhone() from utils.js

*******************************************************************************/

function InfoControl(viewer) {
    this.viewer = viewer;  
    this.createDOMElements();
    this.viewer.addViewerZoomedListener(this);    
}

PanoJS.INFO_CONTROL_STYLE = "padding: 5px; text-shadow: 1px 1px 1px #000000; font-size: 12px;";

if (isClientTouch())
  PanoJS.INFO_CONTROL_STYLE = "padding: 10px; text-shadow: 2px 2px 2px #000000; font-size: 18px;";

if (isClientPhone())
  PanoJS.INFO_CONTROL_STYLE   = "padding: 10px; text-shadow: 6px 6px 6px #000000; font-size: 40px;";



InfoControl.prototype.createDOMElements = function() {
    this.dom_element = this.viewer.viewerDomElement();
      
    this.dom_info = document.createElement('span');
    this.dom_info.className = 'info';
    this.dom_element.appendChild(this.dom_info);       

    this.dom_info.setAttribute("style", PanoJS.INFO_CONTROL_STYLE );
    this.dom_info.style.cssText = PanoJS.INFO_CONTROL_STYLE;   
    
    //this.dom_info.innerHTML = "";
}

InfoControl.prototype.viewerZoomed = function(e) {
    var sz = this.viewer.imageSize();
    if (this.dom_info) 
        this.dom_info.innerHTML = 'Image size: '+ sz.width +'x'+ sz.height +' Scale: '+ e.scale*100 +'%' + 
        ' - <a href="http://www.dimin.net/software/panojs">PanoJS3</a>';   
}

//------------------------------------------------------------------------------
// OsdControl
//------------------------------------------------------------------------------

PanoJS.OSD_CONTROL_STYLE = "text-shadow: 1px 1px 1px #000000; font-size: 50px;";

if (isClientTouch())
PanoJS.OSD_CONTROL_STYLE = "text-shadow: 2px 2px 2px #000000; font-size: 80px;";

if (isClientPhone())
PanoJS.OSD_CONTROL_STYLE   = "text-shadow: 6px 6px 6px #000000; font-size: 120px;";

function OsdControl(viewer) {
  this.viewer = viewer;  

  this.dom_element = this.viewer.viewerDomElement();
  
  this.dom_info = document.createElement('span');
  this.dom_info.className = 'osd';
  this.dom_element.appendChild(this.dom_info);       
  
  this.dom_info.setAttribute("style", PanoJS.OSD_CONTROL_STYLE );
  this.dom_info.style.cssText = PanoJS.OSD_CONTROL_STYLE; 
}

OsdControl.prototype.show = function(v) {
  if (!this.dom_info) return;
  if (!v) this.dom_info.innerHTML = '';
}

OsdControl.prototype.viewerZooming = function(e) {
  if (!this.dom_info) return;
  var dir = e.scale/e.gesture_current_scale>1.0 ? '+' : '-'; 
  this.dom_info.innerHTML = dir+'<br />'+ Math.round(e.scale*e.image_scale*100)+'%';
}


;/*******************************************************************************
  SVG listner - listens to the viewer and translates SVG
  
  GSV 3.0 : PanoJS3
  @author Dmitry Fedorov  <fedorov@ece.ucsb.edu>   
  
  Copyright (c) 2010 Dmitry Fedorov, Center for Bio-Image Informatics

*******************************************************************************/

function SvgControl(viewer, element) {
  this.viewer = viewer;  
    
  if (typeof element == 'string')
    this.svg_element = document.getElementById(element);
  else
    this.svg_element = element;    

  this.viewer.addViewerMovedListener(this);
  this.viewer.addViewerZoomedListener(this);    
}

SvgControl.prototype.viewerMoved = function(e) {
    this.svg_element.style.left = e.x + 'px';
    this.svg_element.style.top  = e.y + 'px';            
}

SvgControl.prototype.viewerZoomed = function(e) {
    this.svg_element.style.left = e.x + 'px';
    this.svg_element.style.top  = e.y + 'px';  
  
    var current_size = this.viewer.currentImageSize();
    this.svg_element.style.width  = current_size.width + 'px';
    this.svg_element.style.height = current_size.height + 'px';           
  
    //var svgembed = document.getElementById( 'svgembed' ); 
    //svgembed.style.width = level.width + 'px';
    //svgembed.style.height  = level.height + 'px';       
}

;PanoJS.CONTROL_ROI_STYLE = "position: absolute;";

function ROIControl(viewer) {
  this.viewer = viewer; 
  this.createDOMElements();

  this.scale = 1;
  this.x = 0;
  this.y = 0;  
  this.width = 0;
  this.height = 0; 
  
  this.viewer.addViewerMovedListener(this);
  this.viewer.addViewerZoomedListener(this);
  this.viewer.addViewerResizedListener(this);
  
  // load thumbnail image
  this.init();
}


ROIControl.prototype.init = function() {
  this.updateDOMElements();
  this.viewer.notifyViewerZoomed();
}

ROIControl.prototype.createDOMElements = function() {
    var de = this.viewer.surface;

    var canvas_id = this.viewer.viewer.id+'-roi';

    this.dom_element = document.createElement('div');
    this.dom_element.id = canvas_id;
    this.dom_element.className = 'weblitz-viewport-roi';
    this.dom_element.setAttribute("style", PanoJS.CONTROL_ROI_STYLE);
    de.appendChild(this.dom_element); 
    
}

ROIControl.prototype.updateDOMElements = function() {
  var cur_size = this.viewer.currentImageSize();
  this.width = cur_size.width;
  this.height = cur_size.height;

  this.dom_element.style.width = this.width + 'px';
  this.dom_element.style.height = this.height + 'px';
  this.dom_element.style.left = this.x + 'px';
  this.dom_element.style.top = this.y + 'px';
}

ROIControl.prototype.viewerMoved = function(e) {
    if (!this.dom_element || typeof this.dom_element == 'undefined') return;
    this.x = e.x;
    this.y = e.y;
    this.updateDOMElements();

    //notify the viewer
    var vp = $.WeblitzViewport($(this.viewer.viewer).parent().parent().parent());

    var theT = vp.getTPos();
    var theZ = vp.getZPos();
    
    if (vp.viewportimg.get(0).setRoiZoom) {
        vp.viewportimg.get(0).setRoiZoom(this.scale*100);
    }
    if (vp.viewportimg.get(0).refresh_rois) {
        if ((vp.viewportimg.get(0).theT != theT) || (vp.viewportimg.get(0).theZ != theZ)) {
            vp.viewportimg.get(0).refresh_rois(theZ, theT);
        }
    }
}

ROIControl.prototype.viewerZoomed = function(e) {
    this.scale  = e.scale;
    this.viewerMoved(e);
}

ROIControl.prototype.viewerResized = function(e) {
    this.viewerMoved(e);
}



;PanoJS.CONTROL_SCALEBAR_STYLE = "position: absolute;";

function ScaleBarControl(viewer) {
  this.viewer = viewer; 
  this.createDOMElements();

  this.scale = 1;
  this.x = 0;
  this.y = 0;  
  this.width = 0;
  this.height = 0; 
  
  this.viewer.addViewerZoomedListener(this);
  
  // load scalebar
  this.init();
}


ScaleBarControl.prototype.init = function() {
  this.viewer.notifyViewerZoomed();
}

ScaleBarControl.prototype.createDOMElements = function() {
  var de = this.viewer.surface;

  var scalebar_id = this.viewer.viewer.id+'-scalebar';

  this.dom_element = document.createElement('div');
  this.dom_element.id = scalebar_id;
  this.dom_element.className = 'weblitz-viewport-scalebar';
  this.dom_element.setAttribute("style", PanoJS.CONTROL_SCALEBAR_STYLE);
  de.appendChild(this.dom_element); 
}



ScaleBarControl.prototype.viewerZoomed = function(e) {
  if (!this.dom_element || typeof this.dom_element == 'undefined') return;
  
  this.scale  = e.scale;
  var vp = $.WeblitzViewport($(this.viewer.viewer).parent().parent().parent());

  if (vp.viewportimg.get(0).setScalebarZoom) {
    vp.viewportimg.get(0).setScalebarZoom(this.scale);
  }
}



;/*! Hammer.JS - v2.0.8 - 2016-04-23
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(j(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(b,c,d){var e="DEPRECATED METHOD: "+c+"\n"+d+" AT \n";return function(){var c=new Error("get-stack-trace"),d=c&&c.stack?c.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",f=a.console&&(a.console.warn||a.console.log);return f&&f.call(a.console,e,d),b.apply(this,arguments)}}function i(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&la(d,c)}function j(a,b){return function(){return a.apply(b,arguments)}}function k(a,b){return typeof a==oa?a.apply(b?b[0]||d:d,b):a}function l(a,b){return a===d?b:a}function m(a,b,c){g(q(b),function(b){a.addEventListener(b,c,!1)})}function n(a,b,c){g(q(b),function(b){a.removeEventListener(b,c,!1)})}function o(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function p(a,b){return a.indexOf(b)>-1}function q(a){return a.trim().split(/\s+/g)}function r(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function s(a){return Array.prototype.slice.call(a,0)}function t(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];r(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function u(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ma.length;){if(c=ma[g],e=c?c+f:b,e in a)return e;g++}return d}function v(){return ua++}function w(b){var c=b.ownerDocument||b;return c.defaultView||c.parentWindow||a}function x(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){k(a.options.enable,[a])&&c.handler(b)},this.init()}function y(a){var b,c=a.options.inputClass;return new(b=c?c:xa?M:ya?P:wa?R:L)(a,z)}function z(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&Ea&&d-e===0,g=b&(Ga|Ha)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,A(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function A(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=D(b)),e>1&&!c.firstMultiple?c.firstMultiple=D(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=E(d);b.timeStamp=ra(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=I(h,i),b.distance=H(h,i),B(c,b),b.offsetDirection=G(b.deltaX,b.deltaY);var j=F(b.deltaTime,b.deltaX,b.deltaY);b.overallVelocityX=j.x,b.overallVelocityY=j.y,b.overallVelocity=qa(j.x)>qa(j.y)?j.x:j.y,b.scale=g?K(g.pointers,d):1,b.rotation=g?J(g.pointers,d):0,b.maxPointers=c.prevInput?b.pointers.length>c.prevInput.maxPointers?b.pointers.length:c.prevInput.maxPointers:b.pointers.length,C(c,b);var k=a.element;o(b.srcEvent.target,k)&&(k=b.srcEvent.target),b.target=k}function B(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};b.eventType!==Ea&&f.eventType!==Ga||(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function C(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Ha&&(i>Da||h.velocity===d)){var j=b.deltaX-h.deltaX,k=b.deltaY-h.deltaY,l=F(i,j,k);e=l.x,f=l.y,c=qa(l.x)>qa(l.y)?l.x:l.y,g=G(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function D(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:pa(a.pointers[c].clientX),clientY:pa(a.pointers[c].clientY)},c++;return{timeStamp:ra(),pointers:b,center:E(b),deltaX:a.deltaX,deltaY:a.deltaY}}function E(a){var b=a.length;if(1===b)return{x:pa(a[0].clientX),y:pa(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:pa(c/b),y:pa(d/b)}}function F(a,b,c){return{x:b/a||0,y:c/a||0}}function G(a,b){return a===b?Ia:qa(a)>=qa(b)?0>a?Ja:Ka:0>b?La:Ma}function H(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function I(a,b,c){c||(c=Qa);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function J(a,b){return I(b[1],b[0],Ra)+I(a[1],a[0],Ra)}function K(a,b){return H(b[0],b[1],Ra)/H(a[0],a[1],Ra)}function L(){this.evEl=Ta,this.evWin=Ua,this.pressed=!1,x.apply(this,arguments)}function M(){this.evEl=Xa,this.evWin=Ya,x.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function N(){this.evTarget=$a,this.evWin=_a,this.started=!1,x.apply(this,arguments)}function O(a,b){var c=s(a.touches),d=s(a.changedTouches);return b&(Ga|Ha)&&(c=t(c.concat(d),"identifier",!0)),[c,d]}function P(){this.evTarget=bb,this.targetIds={},x.apply(this,arguments)}function Q(a,b){var c=s(a.touches),d=this.targetIds;if(b&(Ea|Fa)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=s(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return o(a.target,i)}),b===Ea)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ga|Ha)&&delete d[g[e].identifier],e++;return h.length?[t(f.concat(h),"identifier",!0),h]:void 0}function R(){x.apply(this,arguments);var a=j(this.handler,this);this.touch=new P(this.manager,a),this.mouse=new L(this.manager,a),this.primaryTouch=null,this.lastTouches=[]}function S(a,b){a&Ea?(this.primaryTouch=b.changedPointers[0].identifier,T.call(this,b)):a&(Ga|Ha)&&T.call(this,b)}function T(a){var b=a.changedPointers[0];if(b.identifier===this.primaryTouch){var c={x:b.clientX,y:b.clientY};this.lastTouches.push(c);var d=this.lastTouches,e=function(){var a=d.indexOf(c);a>-1&&d.splice(a,1)};setTimeout(e,cb)}}function U(a){for(var b=a.srcEvent.clientX,c=a.srcEvent.clientY,d=0;d<this.lastTouches.length;d++){var e=this.lastTouches[d],f=Math.abs(b-e.x),g=Math.abs(c-e.y);if(db>=f&&db>=g)return!0}return!1}function V(a,b){this.manager=a,this.set(b)}function W(a){if(p(a,jb))return jb;var b=p(a,kb),c=p(a,lb);return b&&c?jb:b||c?b?kb:lb:p(a,ib)?ib:hb}function X(){if(!fb)return!1;var b={},c=a.CSS&&a.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach(function(d){b[d]=c?a.CSS.supports("touch-action",d):!0}),b}function Y(a){this.options=la({},this.defaults,a||{}),this.id=v(),this.manager=null,this.options.enable=l(this.options.enable,!0),this.state=nb,this.simultaneous={},this.requireFail=[]}function Z(a){return a&sb?"cancel":a&qb?"end":a&pb?"move":a&ob?"start":""}function $(a){return a==Ma?"down":a==La?"up":a==Ja?"left":a==Ka?"right":""}function _(a,b){var c=b.manager;return c?c.get(a):a}function aa(){Y.apply(this,arguments)}function ba(){aa.apply(this,arguments),this.pX=null,this.pY=null}function ca(){aa.apply(this,arguments)}function da(){Y.apply(this,arguments),this._timer=null,this._input=null}function ea(){aa.apply(this,arguments)}function fa(){aa.apply(this,arguments)}function ga(){Y.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function ha(a,b){return b=b||{},b.recognizers=l(b.recognizers,ha.defaults.preset),new ia(a,b)}function ia(a,b){this.options=la({},ha.defaults,b||{}),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=a,this.input=y(this),this.touchAction=new V(this,this.options.touchAction),ja(this,!0),g(this.options.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function ja(a,b){var c=a.element;if(c.style){var d;g(a.options.cssProps,function(e,f){d=u(c.style,f),b?(a.oldCssProps[d]=c.style[d],c.style[d]=e):c.style[d]=a.oldCssProps[d]||""}),b||(a.oldCssProps={})}}function ka(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var la,ma=["","webkit","Moz","MS","ms","o"],na=b.createElement("div"),oa="function",pa=Math.round,qa=Math.abs,ra=Date.now;la="function"!=typeof Object.assign?function(a){if(a===d||null===a)throw new TypeError("Cannot convert undefined or null to object");for(var b=Object(a),c=1;c<arguments.length;c++){var e=arguments[c];if(e!==d&&null!==e)for(var f in e)e.hasOwnProperty(f)&&(b[f]=e[f])}return b}:Object.assign;var sa=h(function(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a},"extend","Use `assign`."),ta=h(function(a,b){return sa(a,b,!0)},"merge","Use `assign`."),ua=1,va=/mobile|tablet|ip(ad|hone|od)|android/i,wa="ontouchstart"in a,xa=u(a,"PointerEvent")!==d,ya=wa&&va.test(navigator.userAgent),za="touch",Aa="pen",Ba="mouse",Ca="kinect",Da=25,Ea=1,Fa=2,Ga=4,Ha=8,Ia=1,Ja=2,Ka=4,La=8,Ma=16,Na=Ja|Ka,Oa=La|Ma,Pa=Na|Oa,Qa=["x","y"],Ra=["clientX","clientY"];x.prototype={handler:function(){},init:function(){this.evEl&&m(this.element,this.evEl,this.domHandler),this.evTarget&&m(this.target,this.evTarget,this.domHandler),this.evWin&&m(w(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(w(this.element),this.evWin,this.domHandler)}};var Sa={mousedown:Ea,mousemove:Fa,mouseup:Ga},Ta="mousedown",Ua="mousemove mouseup";i(L,x,{handler:function(a){var b=Sa[a.type];b&Ea&&0===a.button&&(this.pressed=!0),b&Fa&&1!==a.which&&(b=Ga),this.pressed&&(b&Ga&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:Ba,srcEvent:a}))}});var Va={pointerdown:Ea,pointermove:Fa,pointerup:Ga,pointercancel:Ha,pointerout:Ha},Wa={2:za,3:Aa,4:Ba,5:Ca},Xa="pointerdown",Ya="pointermove pointerup pointercancel";a.MSPointerEvent&&!a.PointerEvent&&(Xa="MSPointerDown",Ya="MSPointerMove MSPointerUp MSPointerCancel"),i(M,x,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Va[d],f=Wa[a.pointerType]||a.pointerType,g=f==za,h=r(b,a.pointerId,"pointerId");e&Ea&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ga|Ha)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Za={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},$a="touchstart",_a="touchstart touchmove touchend touchcancel";i(N,x,{handler:function(a){var b=Za[a.type];if(b===Ea&&(this.started=!0),this.started){var c=O.call(this,a,b);b&(Ga|Ha)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}}});var ab={touchstart:Ea,touchmove:Fa,touchend:Ga,touchcancel:Ha},bb="touchstart touchmove touchend touchcancel";i(P,x,{handler:function(a){var b=ab[a.type],c=Q.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:za,srcEvent:a})}});var cb=2500,db=25;i(R,x,{handler:function(a,b,c){var d=c.pointerType==za,e=c.pointerType==Ba;if(!(e&&c.sourceCapabilities&&c.sourceCapabilities.firesTouchEvents)){if(d)S.call(this,b,c);else if(e&&U.call(this,c))return;this.callback(a,b,c)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var eb=u(na.style,"touchAction"),fb=eb!==d,gb="compute",hb="auto",ib="manipulation",jb="none",kb="pan-x",lb="pan-y",mb=X();V.prototype={set:function(a){a==gb&&(a=this.compute()),fb&&this.manager.element.style&&mb[a]&&(this.manager.element.style[eb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){k(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),W(a.join(" "))},preventDefaults:function(a){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=p(d,jb)&&!mb[jb],f=p(d,lb)&&!mb[lb],g=p(d,kb)&&!mb[kb];if(e){var h=1===a.pointers.length,i=a.distance<2,j=a.deltaTime<250;if(h&&i&&j)return}return g&&f?void 0:e||f&&c&Na||g&&c&Oa?this.preventSrc(b):void 0},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var nb=1,ob=2,pb=4,qb=8,rb=qb,sb=16,tb=32;Y.prototype={defaults:{},set:function(a){return la(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=_(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=_(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=_(a,this),-1===r(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=_(a,this);var b=r(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(b,a)}var c=this,d=this.state;qb>d&&b(c.options.event+Z(d)),b(c.options.event),a.additionalEvent&&b(a.additionalEvent),d>=qb&&b(c.options.event+Z(d))},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=tb)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(tb|nb)))return!1;a++}return!0},recognize:function(a){var b=la({},a);return k(this.options.enable,[this,b])?(this.state&(rb|sb|tb)&&(this.state=nb),this.state=this.process(b),void(this.state&(ob|pb|qb|sb)&&this.tryEmit(b))):(this.reset(),void(this.state=tb))},process:function(a){},getTouchAction:function(){},reset:function(){}},i(aa,Y,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(ob|pb),e=this.attrTest(a);return d&&(c&Ha||!e)?b|sb:d||e?c&Ga?b|qb:b&ob?b|pb:ob:tb}}),i(ba,aa,{defaults:{event:"pan",threshold:10,pointers:1,direction:Pa},getTouchAction:function(){var a=this.options.direction,b=[];return a&Na&&b.push(lb),a&Oa&&b.push(kb),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Na?(e=0===f?Ia:0>f?Ja:Ka,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Ia:0>g?La:Ma,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return aa.prototype.attrTest.call(this,a)&&(this.state&ob||!(this.state&ob)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=$(a.direction);b&&(a.additionalEvent=this.options.event+b),this._super.emit.call(this,a)}}),i(ca,aa,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&ob)},emit:function(a){if(1!==a.scale){var b=a.scale<1?"in":"out";a.additionalEvent=this.options.event+b}this._super.emit.call(this,a)}}),i(da,Y,{defaults:{event:"press",pointers:1,time:251,threshold:9},getTouchAction:function(){return[hb]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ga|Ha)&&!f)this.reset();else if(a.eventType&Ea)this.reset(),this._timer=e(function(){this.state=rb,this.tryEmit()},b.time,this);else if(a.eventType&Ga)return rb;return tb},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===rb&&(a&&a.eventType&Ga?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=ra(),this.manager.emit(this.options.event,this._input)))}}),i(ea,aa,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[jb]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&ob)}}),i(fa,aa,{defaults:{event:"swipe",threshold:10,velocity:.3,direction:Na|Oa,pointers:1},getTouchAction:function(){return ba.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Na|Oa)?b=a.overallVelocity:c&Na?b=a.overallVelocityX:c&Oa&&(b=a.overallVelocityY),this._super.attrTest.call(this,a)&&c&a.offsetDirection&&a.distance>this.options.threshold&&a.maxPointers==this.options.pointers&&qa(b)>this.options.velocity&&a.eventType&Ga},emit:function(a){var b=$(a.offsetDirection);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),i(ga,Y,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[ib]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&Ea&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ga)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||H(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=rb,this.tryEmit()},b.interval,this),ob):rb}return tb},failTimeout:function(){return this._timer=e(function(){this.state=tb},this.options.interval,this),tb},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==rb&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),ha.VERSION="2.0.8",ha.defaults={domEvents:!1,touchAction:gb,enable:!0,inputTarget:null,inputClass:null,preset:[[ea,{enable:!1}],[ca,{enable:!1},["rotate"]],[fa,{direction:Na}],[ba,{direction:Na},["swipe"]],[ga],[ga,{event:"doubletap",taps:2},["tap"]],[da]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var ub=1,vb=2;ia.prototype={set:function(a){return la(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?vb:ub},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&rb)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===vb||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(ob|pb|qb)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof Y)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;if(a=this.get(a)){var b=this.recognizers,c=r(b,a);-1!==c&&(b.splice(c,1),this.touchAction.update())}return this},on:function(a,b){if(a!==d&&b!==d){var c=this.handlers;return g(q(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this}},off:function(a,b){if(a!==d){var c=this.handlers;return g(q(a),function(a){b?c[a]&&c[a].splice(r(c[a],b),1):delete c[a]}),this}},emit:function(a,b){this.options.domEvents&&ka(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&ja(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},la(ha,{INPUT_START:Ea,INPUT_MOVE:Fa,INPUT_END:Ga,INPUT_CANCEL:Ha,STATE_POSSIBLE:nb,STATE_BEGAN:ob,STATE_CHANGED:pb,STATE_ENDED:qb,STATE_RECOGNIZED:rb,STATE_CANCELLED:sb,STATE_FAILED:tb,DIRECTION_NONE:Ia,DIRECTION_LEFT:Ja,DIRECTION_RIGHT:Ka,DIRECTION_UP:La,DIRECTION_DOWN:Ma,DIRECTION_HORIZONTAL:Na,DIRECTION_VERTICAL:Oa,DIRECTION_ALL:Pa,Manager:ia,Input:x,TouchAction:V,TouchInput:P,MouseInput:L,PointerEventInput:M,TouchMouseInput:R,SingleTouchInput:N,Recognizer:Y,AttrRecognizer:aa,Tap:ga,Pan:ba,Swipe:fa,Pinch:ca,Rotate:ea,Press:da,on:m,off:n,each:g,merge:ta,extend:sa,assign:la,inherit:i,bindFn:j,prefixed:u});var wb="undefined"!=typeof a?a:"undefined"!=typeof self?self:{};wb.Hammer=ha,"function"==typeof define&&define.amd?define(function(){return ha}):"undefined"!=typeof module&&module.exports?module.exports=ha:a[c]=ha}(window,document,"Hammer");
//# sourceMappingURL=hammer.min.js.map
;/**
 * gs_utils - Common functions library
 *
 * Copyright (c) 2007, 2008, 2009 Glencoe Software, Inc. All rights reserved.
 * 
 * This software is distributed under the terms described by the LICENCE file
 * you can find at the root of the distribution bundle, which states you are
 * free to use it only for non commercial purposes.
 * If the file is missing please request a copy by contacting
 * jason@glencoesoftware.com.
 *
 * Author: Carlos Neves <carlos(at)glencoesoftware.com>
 */

var gs_static_location_prefix=''; //configure it to access static files, used with 3rdparty/jquery.blockUI-2.66.0.js

/**
 * Given a string that may contain an RGB, RRGGBB or the previous with a # prefix,
 * returns the #RRGGBB counterpart, or if the parse fails, the default value (or null if no default)
 */
function sanitizeHexColor (color, def) {
  color = toRGB(color, def);
  if (color === def || color === null) {
    return color;
  }
  return '#' + OME.rgbToHex(color);
}

/**
 * Converts a color into rgb(r,g,b) notation, right now only hex RGB or RRGGBB inputs.
 */
function toRGB (color, def) {
  if (color.substring(0,4) == 'rgb(') {
    return color;
  }
  if (color.substring(0,1) == '#') {
    color = color.substring(1);
  }
  var r,g,b;
  if (color.length == 3) {
    r = parseInt(color.substring(0,1), 16);
    g = parseInt(color.substring(1,2), 16);
    b = parseInt(color.substring(2,3), 16);
    r += r*0x10;
    g += g*0x10;
    b += b*0x10;
  } else if (color.length == 6) {
    r = parseInt(color.substring(0,2), 16);
    g = parseInt(color.substring(2,4), 16);
    b = parseInt(color.substring(4,6), 16);
  }
  if (r === undefined || isNaN(r) || isNaN(g) || isNaN(b)) {
    return def != undefined ? def : null;
  }
  return 'rgb('+r+','+g+','+b+')';
}

/**
 * parse the URL query string. Shamelessly stolen from thickbox.
 */
function parseQuery (q) {
  var query;
  if (q === undefined) {
    query = location.href.replace(/^[^\?]+\??/,'');
  } else {
    query = q.replace(/^\??/,'');
  }
  var Params = {};
  if ( ! query ) {return Params;}// return empty object
  var Pairs = query.split(/[;&]/);
  for ( var i = 0; i < Pairs.length; i++ ) {
    var KeyVal = Pairs[i].split('=');
    if ( ! KeyVal || KeyVal.length != 2 ) {continue;}
    var key = decodeURIComponent( KeyVal[0] );
    var val = decodeURIComponent( KeyVal[1] );
    val = val.replace(/\+/g, ' ');
    Params[key] = val;
  }
  return Params;
}

var gs_modalJson_cb;

/**
 * Lazy loader for the blockUI plugin.
 */

function gs_loadBlockUI (callback) {
  if (jQuery.blockUI === undefined) {
    jQuery.getScript(gs_static_location_prefix + '3rdparty/jquery.blockUI-2.66.0.js', callback);
    return false;
  }
  return true;
}

function gs_choiceModalDialog (message, choices, callback, blockui_opts, cancel_callback, _modal_cb) {
  if (!gs_loadBlockUI (function () {gs_choiceModalDialog(message, choices, callback, blockui_opts, cancel_callback,_modal_cb);})) {
    return;
  }
  if (_modal_cb) {
    gs_modal_cb = _modal_cb;
  } else {
    gs_modal_cb = function (idx) {
      jQuery.unblockUI();
      if (choices[idx].data != null) {
        callback(choices[idx].data);
      } else if (cancel_callback) {
        cancel_callback();
      }
      return false;
    }
  }
  for (var i=0; i < choices.length; i++) {
    message += '<input type="button" onclick="return gs_modal_cb('+i+');" value="'+choices[i].label+'" />'
  }
  if (!blockui_opts) {
    blockui_opts = {};
  }
  jQuery.blockUI({message: message, css: blockui_opts.css});
  return;
}

function gs_choiceModalJson (message, choices, callback, blockui_opts, cancel_callback) {
//  if (!gs_loadBlockUI (function () {gs_choiceModalJson(message, choices, callback, blockui_opts, cancel_callback);})) {
//    return;
//  }
  var gs_modalJson_cb = function (idx) {
    jQuery.unblockUI();
    if (choices[idx].url != null) {
      gs_modalJson(choices[idx].url, choices[idx].data, callback);
    } else if (cancel_callback) {
      cancel_callback();
    }
    return false;
  }
  return gs_choiceModalDialog(message,choices,callback,blockui_opts,cancel_callback,gs_modalJson_cb);
//  for (i in choices) {
//    message += '<input type="button" onclick="return gs_modalJson_cb('+i+');" value="'+choices[i].label+'" />'
//  }
//  if (!blockui_opts) {
//    blockui_opts = {};
//  }
//  jQuery.blockUI({message: message, css: blockui_opts.css});
//  return;
}

/**
 * Calls a jsonp url, just like $.getJson, but also looks out for errors.
 * The call is made in a make-believe synchronous fashion, by adding a semi-transparent overlay and disabling controls.
 */
function gs_modalJson (url, data, callback) {
  if (!gs_loadBlockUI (function () {gs_modalJson(url,data,callback);})) {
    return;
  }
  jQuery.blockUI();
  var cb = function (result, rv) {
    jQuery.unblockUI();
    if (callback) {
      callback(result, rv);
    }
  }
  gs_json (url, data, cb);
}

function gs_json (url, data, callback) {
  var cb = function (result) {
    return function (data, textStatus, errorThrown) {
      if (callback) {
        callback (result, result ? data : errorThrown || textStatus);
      }
    }
  }

  return jQuery.ajax({
      type: data ? "POST":"GET",
        url: url,
        data: data,
        success: cb(true),
        error: cb(false),
        dataType: "jsonp",
        traditional: true
        });
}

/**
 * Trims text to a maximum length, or up to the first line break optionally
 * hyst is an hysteresis value stating the minimum trimmed nr of chars for trimming to occur.
 */
function gs_text_trim (text, length, hyst, nobreakline, snl) {
  if (hyst === undefined) {
    hyst = 0;
  }
  var p = nobreakline && text.indexOf('\n') || -1;
  var trimmed = text;
  // Cut to newline?
  if (p>0 && p<length) {
    length = p;
  }
  // Enough gain to actually apply the trim?
  if (length+hyst < text.length) {
    text = text.substring(0, length) + '...';
  }

  return snl && text.replace(/\n/g, snl) || text;
}

/**
 * Grabs details for a specific image and prepares a bunch of links.
 */
function gs_getResultLineLinks (data, baseurl, renderurl) {
  if (data === null || data.datasetId === null || data.projectId === null) {
    return null;
  }
  if (renderurl == null) {
    renderurl = baseurl;
  }
    var figurl;
    var imgurl;
    if (data.screenId && data.screenId != 0) {
        figurl = baseurl+'browse/'+data.projectId+'/S'+data.screenId+'/P'+data.datasetId+'/'
        imgurl = baseurl+'browse/'+data.projectId+'/S'+data.screenId+'/'+data.imageId+'/';
    } else {
        figurl = baseurl+'browse/'+data.projectId+'/'+data.datasetId+'/'
	imgurl = baseurl+'browse/'+data.projectId+'/'+data.datasetId+'/'+data.imageId+'/';
    }
  return {
    figure: figurl,
    img: imgurl,
    thumb: renderurl+'render_thumbnail/'+data.imageId+'/',
    viewer: baseurl+'img_detail/'+data.imageId+'/'+data.datasetId+'/',
    paper: baseurl+'browse/'+data.projectId+'/',
    fv_click: function (did, iid) {
      return function () {
        gs_popViewer(did, iid, baseurl);
        return false;
      };
    }
    };
};
        
/**
 * Grabs details for a specific image and prepares add a DOM node and descendants for search results like l&f.
 */
function gs_showResultLine (container, data, baseurl, renderurl) {
  if (data === null || data.datasetId === null || data.projectId === null) {
    return null;
  }
  var result = jQuery('<div class="search-result">').appendTo(container);
  var head = jQuery('<div class="search-result-header">').appendTo(result);
  data['links'] = gs_getResultLineLinks(data, baseurl, renderurl);
  head.append('<a href="'+data.links.paper+'">- '+data.project+' -</a>');
  head.append('<div class="detail">'+gs_text_trim(data.projectDescription,100)+'</div>');
  head.append('<a href="'+data.links.img+'"><img src="'+data.links.thumb+'" /></a>');
  var detail = jQuery('<div class="search-result-detail">').appendTo(result);
  detail.append('<a href="'+data.links.img+'" alt="Open complete figure">'+data.dataset+' : '+data.name+'</a>');
  detail.append('<div class="detail">'+gs_text_trim(data.description,250,false,' ')+'</div>');
  var foot = jQuery('<div class="search-result-footnotes"><span> [ </span></div>').appendTo(result);
  var fv = jQuery('<a href="'+data.links.viewer+'" alt="Open Full Viewer">Full Viewer</a>').appendTo(foot);
  foot.append('&nbsp;<a href="'+data.links.paper+'" alt="Paper">Paper</a>&nbsp;');
  fv.on('click', data.links.fv_click(data.datasetId, data.imageId));
  foot.append('<a href="'+data.links.figure+'" alt="Figure">Figure</a>&nbsp;');
  foot.append('<span>] by <i>'+data.author+'</i> - <i>'+data.timestamp+'</i></span>');
  return result;
};
        
/**
 * Open the full viewer for a specific image.
 * Passing the dataset is needed to allow showing 'Figure List' on the viewer toolbar.
 */
function gs_popViewer (did, iid, baseurl) {
  if (iid == null) {
    return true;
  }
  if (did == null && typeof iid == 'string') {
    iid = iid.split('/');
    did = parseInt(iid[1]);
    iid = parseInt(iid[0]);
  }
  var w = window.open(baseurl+'img_detail/' + iid + '/' + did, '_blank',
              "toolbar=yes,location=yes,directories=yes,status=yes,menubar=yes, scrollbars=yes,resizable=yes,width=800,height=800");
  return false;
}


/**
 * Search images and fill in results.
 */
function gs_searchImgs (text, baseurl, renderurl, result_cb) {
  if (text.length > 0) {
    jQuery('#search-results-summary').removeClass('ajax-error').html('searching for "'+text+'"');
    jQuery('#search-results').html('<img src="../img/ajax-loader.gif" alt="loading..." />');
    if (renderurl == null) {
      renderurl = baseurl;
    }
    $.getJSON(baseurl+'search/', {text: text, ctx: 'imgs', grabData: true, key: 'meta'}, function(data) {
shown = 0;
      if (data.length) {
        jQuery('#search-results').html('');
        for (e in data) {
          var elm = gs_showResultLine(jQuery('#search-results'), data[e], baseurl, renderurl);
          if (elm != null) {
            result_cb && result_cb(data[e], elm);
            shown++;
          }
        }
      }
      if (shown == 0) {
        jQuery('#search-results').html('no results');
        jQuery('#search-results-summary').html('search for "'+text+'": no results.');
      } else {
        jQuery('#search-results-summary').html('search for "'+text+'":<br /> showing 1 to '+shown+' of '+shown+' total.');
      }
    });
  }
}

function downloadLandingDialog (anchor, msg, cb) {
    if (!msg) {
	msg = "<h2>Your download will start in a few moments</h2>";
    }
    var ccb = function (e) {
	cb && cb(e);
    }
    gs_choiceModalDialog(msg,
                         [{label: 'close', data: 1}],
			 ccb,
			 {css: {width: '50%', left: '25%'}}
			); 
    if (anchor) {
	var dliframe = $('iframe[name=dliframe]');
	if (!dliframe.length) {
	    dliframe = $('<iframe name="dliframe" width="0" height="0"></iframe>').appendTo('body');
	}
	dliframe.attr('src', $(anchor).attr('href'));
	//var w = window.open($(anchor).attr('href'));
	//location.href = $(anchor).attr('href');
    }
    return false;
}


;/**
 * jquery-plugin-viewportImage - Viewport Image plugin for JQuery.
 *
 * Depends on jquery
 *
 * Copyright (c) 2007-2014 Glencoe Software, Inc. All rights reserved.
 *
 * This software is distributed under the terms described by the LICENCE file
 * you can find at the root of the distribution bundle, which states you are
 * free to use it only for non commercial purposes.
 * If the file is missing please request a copy by contacting
 * jason@glencoesoftware.com.
 *
 * Author: Carlos Neves <carlos(at)glencoesoftware.com>
 */
 
 /*global InfoControl:true BisqueISPyramid:true PanoJS:true ROIControl:true */

jQuery.fn.viewportImage = function(options) {
  return this.each(function(){
    if (!this.id) {
      this.id = '' + (new Date()).getTime();
    }

    var self = this;
    var _this = this;
    var insideId = this.id + '-vpi';

    var image = jQuery(this);
    image.addClass('weblitz-viewport-img');
    image.wrap('<div id="'+insideId+'" style="display: inline; position: absolute;" class="draggable"></div>');
    var dragdiv = jQuery('#'+insideId);
    var dragdiv_dom = dragdiv.get(0);
    var wrapdiv = jQuery(dragdiv_dom.parentNode);
    var overlay = $('<img id="'+insideId+'-ovl">').appendTo(dragdiv);
    overlay.addClass('weblitz-viewport-img').hide();
    var zoomCenter = null;
    
    // big images
    var viewerBean = null;
    
    var panbars = options == null || options.panbars;
    var mediaroot = options == null ? null : options.mediaroot;
    mediaroot = mediaroot || '/appmedia';

    var $wb_zoomIn = $('<span class="wb_zoomIn" style="top: 10px;"><img src="'+mediaroot+'3rdparty/panojs-2.0.0/images/32px_plus.png" title="Zoom in" style="width: 20px;"></span>')
                      .prependTo(wrapdiv);
    var $wb_zoom11 = $('<span class="wb_zoom11" style="top: 40px;"><img src="'+mediaroot+'3rdparty/panojs-2.0.0/images/32px_11.png" title="Zoom 1:1" style="width: 20px;"></span>')
                      .prependTo(wrapdiv);
    var $wb_zoomOut = $('<span class="wb_zoomOut" style="top: 70px;"><img src="'+mediaroot+'3rdparty/panojs-2.0.0/images/32px_minus.png" title="Zoom out" style="width: 20px;"></span>')
                      .prependTo(wrapdiv);

    if (panbars) {
    /* Panning sides */
    var panleftId = this.id + '-panl';
    var panrightId = this.id + '-panr';
    var pantopId = this.id + '-pant';
    var panbottomId = this.id + '-panb';
    var side_styles = 'background-color: #ABC; filter:alpha(opacity=50); opacity: 0.5; z-index: 5; position: absolute; display: block;';
    var side_styles_h = side_styles+'height: 100%;';
    var side_styles_v = side_styles+'width: 100%; left: 0%;';
    wrapdiv.prepend('<div id="'+panleftId+'" style="'+ side_styles_h +'left: 0%;"><img src="'+mediaroot+'/webgateway/img/arrow_left.gif">');
    wrapdiv.prepend('<div id="'+panrightId+'" style="'+ side_styles_h +'right: 0px; _right: 0%;"><img src="'+mediaroot+'/webgateway/img/arrow_right.gif">');
    wrapdiv.prepend('<div id="'+pantopId+'" style="'+ side_styles_v +'top: 0%;"><img src="'+mediaroot+'/webgateway/img/arrow_up.gif">');
    wrapdiv.prepend('<div id="'+panbottomId+'" style="'+ side_styles_v +'bottom: 0%;"><img src="'+mediaroot+'/webgateway/img/arrow_down.gif">');
    var panleft = jQuery('#'+panleftId);
    var panright = jQuery('#'+panrightId);
    var pantop = jQuery('#'+pantopId);
    var panbottom = jQuery('#'+panbottomId);

    var panside_extend = function (e, min, max, mintm, maxtm, s) {
      var opt = {};
      var opt2 = {};
      opt[s] = opt2[s] = max;
      e.queue("fx", []);
      e.children().queue("fx", []);
      e.off("mouseover", e.do_extend)
      .on('mouseout', e.do_collapse)
      .animate(opt);
      opt2[s == 'width' && 'top' || 'left'] = e._img_pos_extended;
      e.children("img").animate(opt2);
    };

    var panside_collapse = function (e, min, max, mintm, maxtm, s) {
      var opt = {};
      var opt2 = {};
      opt[s] = opt2[s] = min;
      e.off("mouseout", e.do_collapse)
      .on('mouseover', e.do_extend)
      .animate(opt);
      opt2[s == 'width' && 'top' || 'left'] = e._img_pos_collapsed;
      e.children("img").animate(opt2);
    };

    var panside_prepare = function (e,x,y) {
      var img = e.children("img");
      var iw = img.width();
      var ih = img.height();
      var max, min, maxtm, mintm, side;
      wrapwidth = wrapdiv.width();
      wrapheight = wrapdiv.height();
      img.off('load');

      if (iw === 0 || iw === 0) {
        img.load(function() {panside_prepare(e,x,y);});
        e.center = function () {};
        e.display = function () {};
        return;
      }

      if (x === 0) {
        side = 'height';
        max = ih;
        //img.css('top', '50%');
        e.center = function () {
          e._img_pos_extended = parseInt((wrapwidth / 2) - (iw / 2), 10);
          e._img_pos_collapsed = parseInt((wrapwidth / 2) - (iw / 6), 10);
          img.css('left', e._img_pos_collapsed);
        };
      } else {
        side = 'width';
        max = iw;
        img.css('left', '0%');
        e.center = function () {
          e._img_pos_extended = parseInt((wrapheight / 2) - (ih / 2), 10);
          e._img_pos_collapsed = parseInt((wrapheight / 2) - (ih / 6), 10);
          img.css('top', e._img_pos_collapsed);
        };
      }
      e.center();
      img.css({display: 'block', position: 'absolute'});
      min = parseInt(max / 3, 10);
      maxtm = -parseInt(ih / 2, 10);
      mintm = parseInt(maxtm / 5, 10);
      e.do_extend = function () {panside_extend(e,min,max,mintm,maxtm,side);};
      e.do_collapse = function () {panside_collapse(e,min,max,mintm,maxtm,side);};
      e.do_collapse();
      //panside_collapse(e, min, max, mintm + 'px', maxtm+ 'px', side);
      e.on('mouseout', function() { e.removeClass('auto-val'); });
      e.on('mousedown', function () { e.addClass('auto-val'); self.doMove(x,y,1, function() {return e.is('.auto-val');}); return false;});
      e.on('mouseup', function() { e.removeClass('auto-val'); return false;});
      e.css({'cursor': 'pointer'});

      e.display = function (show) {
        if (show && this.css('display') == 'none') {
          panside_collapse(this, min, max, mintm, maxtm, side);
          this.show();
        }
        if (!show && this.css('display') != 'none') {
          this.removeClass('auto-val')
          .off("mouseout")
          .hide();
        }
      };
    };
    
    panside_prepare(panleft,50,0);
    panside_prepare(panright,-50,0);
    panside_prepare(pantop,0,50);
    panside_prepare(panbottom,0,-50);
    }

    /* These get recalculated on zoom and refresh() */
    var imagewidth = 0;
    var imageheight = 0;
    var wrapwidth = 0;
    var wrapheight = 0;

    //var centering  = function (x, y) {
    //  if (x == null && y == null) {
        /* Return current center */
        
   //   } else {
        /* move to center */
   //   }
   // };


    /**
     * Overlay control
     */

    this.showOverlay = function (url, cb, error_cb) {
      if (url) {
        overlay.addClass('loading').hide();
        var load = function () {overlay.off('error',error); overlay.removeClass('loading').show(); cb && cb();};
        var error = function () {overlay.off('load',load); overlay.removeClass('loading'); error_cb && error_cb();};
        overlay.one('load', load);
        overlay.one('error', error);
        overlay.attr('src', url);
      } else {
        overlay.show();
        cb && cb();
      }
    };

    this.hideOverlay = function () {
      overlay.hide();
    };

    this.overlayVisible = function () {
      return overlay.is(':visible') || overlay.is('.loading');
    };

    this.setPixelated = function (pixelated) {
      // Handle images for regular viewer and big image viewer
      var $tiledViewer = $(".viewer", wrapdiv);
      if (pixelated) {
        image.addClass("pixelated");
        $tiledViewer.addClass("pixelated");
      } else {
        image.removeClass("pixelated");
        $tiledViewer.removeClass("pixelated");
      }
    };

    /**
     * Pan the image within the viewport
     */

    this.doMove = function (deltax, deltay, smooth, auto_move_cb) {
      /* Image and wrapping div */
      var pos = dragdiv.offset();
      var rel = wrapdiv.offset();
      pos.left -= rel.left + parseInt($.css(wrapdiv[0], "borderLeftWidth", true), 10);
      pos.top -= rel.top + parseInt($.css(wrapdiv[0], "borderTopWidth", true), 10);
      var left = pos.left + deltax;
      var top = pos.top + deltay;
      var self = this;

      /* Is the viewport bigger than the image ? */
      if (imagewidth <= wrapwidth) {
        /* Viewport wider than image, center horizontally */
        left = (wrapwidth - imagewidth) / 2;
        panbars && panleft.display(false);
        panbars && panright.display(false);
      } else {
        /* Image wider than viewport... */
        if (left >= 0) {
          left = 0;
          panbars && panleft.display(false);
        } else {
          panbars && panleft.display(true);
        }
        if ((wrapwidth - imagewidth) >= left ) {
          left = wrapwidth - imagewidth;
          panbars && panright.display(false);
        } else {
          panbars && panright.display(true);
        }
      }
      if (imageheight <= wrapheight) {
        /* Viewport higher than image, center vertically */
        top = (wrapheight - imageheight) / 2;
        panbars && pantop.display(false);
        panbars && panbottom.display(false);
      } else {
        /* Image higher than viewport... */
        if (top >= 0) {
          top = 0;
          panbars && pantop.display(false);
        } else {
          panbars && pantop.display(true);
        }
        if ((wrapheight - imageheight) >= top ) {
          top = wrapheight - imageheight;
          panbars && panbottom.display(false);
        } else {
          panbars && panbottom.display(true);
        }
      }
      if (left == dragdiv_dom.offsetLeft && top == dragdiv_dom.offsetTop) {
        return;
      }

      if (smooth != null) {
        dragdiv.animate({left: left, top: top}, 'fast', 'linear', function () {
          if (auto_move_cb != null && auto_move_cb()) {
            self.doMove(deltax, deltay, smooth, auto_move_cb);
          }
        });
      } else {
        dragdiv.css({left: left, top: top});
      }
    };

    var cur_zoom = 100;
    var orig_width;
    var orig_height;
    var changing = null;

    this.getOrigWidth = function () { return orig_width; };
    this.getOrigHeight = function () { return orig_height; };

    this.getXOffset = function () {
      var offset = parseInt(dragdiv.css('left'), 10);
      return offset < 0 ? (-offset) : 0;
    };
    this.setXOffset = function (xoffset) {dragdiv.css('left', -xoffset); this.doMove(0,0);};
    this.getYOffset = function () {
      var offset = parseInt(dragdiv.css('top'), 10);
      return offset < 0 ? (-offset) : 0;
    };
    this.setYOffset = function (yoffset) {dragdiv.css('top', -yoffset); this.doMove(0,0);};

    this.getZoom = function () {
        return cur_zoom;
    };


    // setZoomCenter sets zoomCenter with a short timeout to reset to null
    var clearCenterTimeout;
    var setZoomCenter = function(center) {
      zoomCenter = zoomCenter || center;
      if (clearCenterTimeout) {
        clearTimeout(clearCenterTimeout);
      }
      clearCenterTimeout = setTimeout(function(){
        zoomCenter = null;
      }, 100);
    };
    var getZoomCenter = function() {
      return zoomCenter;
    };

    this.setZoom = function (val, width, height, center) {
      if (width != null && height != null) {
        orig_width = width;
        orig_height = height;
      }
      width = parseInt(orig_width*val/100, 10);
      height = parseInt(orig_height*val/100, 10);

      var left = parseInt(dragdiv.css('left'), 10),
          top = parseInt(dragdiv.css('top'), 10);

      // center is point in viewport - image should zoom on this spot
      if (!center) {
        center = {'x': wrapdiv.width()/2,   // pick middle by default
            'y': wrapdiv.height()/2};
      }
      // find point on image that must stay at viewport centre (as a fraction of w or h)
      var imgx = (center.x - left) / image.attr('width');
      var imgy = (center.y - top) / image.attr('height');

      // cache the viewport centre and image centre to re-use for a whole series of zoom events
      // only sets zoomCenter if expired (sets at start of new zoom)
      setZoomCenter({'vp':center, 'image':{'x':imgx, 'y':imgy}});

      var zc = getZoomCenter();
      if (zc) {
        imgx = zc.image.x;
        imgy = zc.image.y;
        var cx = zc.vp.x;
        var cy = zc.vp.y;
        // after the image is resized to width & height, need to re-calculate left & top
        var newleft = -parseInt((imgx * width) - cx, 10);
        var newtop = -parseInt((imgy * height) - cy, 10);
        dragdiv.css({'top': newtop+'px', 'left': newleft+'px'});
      }

      cur_zoom = val;
      imagewidth = width;
      imageheight = height;
      this.doMove(0, 0);
      if (!changing) {
          changing = setTimeout(function () {
          image.trigger("zoom", [cur_zoom]);
          changing = null;
        }, 20);
      }
      image.trigger("instant_zoom", [cur_zoom]);
      dragdiv.width(width);
      dragdiv.height(height);
      image.attr({width: width, height: height});
      overlay.attr({width: width, height: height});
     };

    this.setZoomToFit = function (only_shrink, width, height) {
      if (width != null && height != null) {
        orig_width = width;
        orig_height = height;
        cur_zoom = 100;
      }
      var ztf = Math.min(wrapwidth * 100.0 / orig_width, wrapheight * 100.0 / orig_height);
      if (only_shrink && ztf >= 100.0) {
        ztf = 100.0;
      }
      this.setZoom(parseInt(ztf, 10));
    };

    this.doZoom = function (increment, justDirection, center) {
      if (justDirection) {
        var t = Math.max(1,((imagewidth+3)*cur_zoom/imagewidth) - cur_zoom);
        increment = cur_zoom + (increment>0?t:-t);
      }
      this.setZoom(parseInt(increment, 10), null, null, center);
    };

    dragdiv.on('mousewheel', function (e, delta) {
      // calculate zoom point within viewport
       var o = wrapdiv.offset(),
          relX = e.pageX - o.left,
          relY = e.pageY - o.top,
          cxcy = {'x':relX,
              'y':relY};
      _this.doZoom(delta, true, cxcy);
      e.preventDefault();
    });

    /**
     * Handle panning by mouse drag
     */

    var ondrag = false;
    var clickinterval = null;
    var drag_px;
    var drag_py;
    dragdiv
      .on('click', function (e) {
          if (clickinterval != null) {
            clickinterval = null;
            image.trigger(e);
          }
        })
    .on('mousedown', function (e) {
      drag_px = e.screenX;
      drag_py = e.screenY;
      //jQuery(this).css('cursor', 'move');
      jQuery(this).addClass('ondrag');
      ondrag = true;
      if (clickinterval != null) {
        clearInterval(clickinterval);
      }
      clickinterval = setTimeout(function () {clearTimeout(clickinterval); clickinterval = null;}, 250);
      return false;
    })
    .on('mouseup', function (e) {
      if (ondrag) {
        ondrag = false;
        jQuery(this).removeClass('ondrag');
        return false;
        //jQuery(this).css('cursor', 'default');
      }
    })
    .on('mouseout', function (e) {
      if (ondrag) {
        ondrag = false;
        jQuery(this).removeClass('ondrag');
        return false;
        //jQuery(this).css('cursor', 'default');
      }
    })
    .on('mousemove', function (e) {
      if (ondrag) {
        self.doMove(e.screenX-drag_px, e.screenY-drag_py);
        drag_px = e.screenX;
        drag_py = e.screenY;
        return false;
      }
    });

    // If we're on a tablet, use hammer.js for gestures
    if (OME.isMobileDevice()) {
      var myElement = dragdiv.get(0);
      var mc = new Hammer(myElement);
      mc.get('pan').set({ direction: Hammer.DIRECTION_ALL });
      // "panstart" is not fired until after other pan events...
      mc.on("panleft panright panup pandown", function(event) {
          if (drag_px === undefined) {
            self.doMove(event.deltaX, event.deltaY);
          } else {
            self.doMove(event.center.x-drag_px, event.center.y-drag_py);
          }
          drag_px = event.center.x;
          drag_py = event.center.y;
      });
      // ...so we use "panend" instead to distinguish start/end
      mc.on("panend", function(event) {
        drag_px = undefined;
      });
    }


    // Handle zoom buttons
    $wb_zoomIn.on('click', function() {
      var zm = _this.getZoom();
      _this.setZoom(zm + 20);
    });
    $wb_zoomOut.on('click', function() {
      var zm = _this.getZoom();
      if (zm > 21) {
        _this.setZoom(zm - 20);
      } else if (zm > 11) {
        _this.setZoom(zm - 10);
      }
    });
    $wb_zoom11.on('click', function() {
      _this.setZoom(100);
    });

    this.getBigImageContainer = function () {
        return viewerBean;
    };
    
    this.setUpTiles = function (imagewidth, imageheight, xtilesize, ytilesize, init_zoom, levels, hrefProvider, thref, init_cx, init_cy, zoomLevelScaling, nominalMagnification) {
        InfoControl.prototype.viewerZoomed = function(e) {
            if (this.dom_info) {
                if (nominalMagnification && typeof nominalMagnification != "undefined") {
                    var scale = e.scale * nominalMagnification;
                    if (scale % 1 !== 0)
                    //smart float formatting
                        if (scale < 1)
                            scale = Math.round(scale*10)/10;
                        else
                            scale = Math.round(scale*100)/100;
                    this.dom_info.innerHTML = 'Magnification: '+ scale + 'x';
                } else {
                    var scale = e.scale * 100;
                    if (scale % 1 !== 0)
                        scale = scale.toFixed(2);
                    this.dom_info.innerHTML = 'Scale: '+ scale +'%';
                }
            }
        };
        
        var myPyramid = new BisqueISPyramid(
                imagewidth, imageheight, xtilesize, ytilesize, levels);
        var myProvider = new PanoJS.TileUrlProvider('','','');
        myProvider.assembleUrl = function(xIndex, yIndex, zoom) {
            var href = hrefProvider();
            return href+'&'+myPyramid.tile_filename( zoom, xIndex, yIndex );
            //return MY_URL + '/' + MY_PREFIX + myPyramid.tile_filename( zoom, xIndex, yIndex );
        };
        myProvider.thumbnailUrl = function (thref) {
            this.thumbnailUrl = thref;
        };
        myProvider.thumbnailUrl(thref);
        
        if (viewerBean == null) {
            var viewerBeanId = this.id + '-tiles';
            $('<div id="'+viewerBeanId+'" class="viewer" style="width: 100%; height: 100%;" ></div>').appendTo(wrapdiv);
            
            PanoJS.CREATE_CONTROL_MAXIMIZE = true;
            PanoJS.PRE_CACHE_AMOUNT = 2;
            PanoJS.USE_WHEEL_FOR_ZOOM = true;
            viewerBean = new PanoJS(viewerBeanId, {
                tileUrlProvider : myProvider,
                xTileSize       : myPyramid.xtilesize,
                yTileSize       : myPyramid.ytilesize,
                maxZoom         : myPyramid.getMaxLevel(),
                imageWidth      : myPyramid.width,
                imageHeight     : myPyramid.height,
                initialZoom     : init_zoom,
                staticBaseURL   : mediaroot+'3rdparty/panojs-2.0.0/images/',
                blankTile       : mediaroot+'3rdparty/panojs-2.0.0/images/blank.gif',
                loadingTile     : mediaroot+'3rdparty/panojs-2.0.0/images/blank.gif',
                zoomLevelScaling : zoomLevelScaling,
                delay           : 300
            });
            
            viewerBean.mouseReleasedHandler = function(e) {
                e = e ? e : window.event;
                if (!this.pressed) {
                    return false;
                }
                var coords = this.resolveCoordinates(e);
                if (e.type=='mouseout' &&
                    coords.x > 0 && coords.x < this.width &&
                    coords.y > 0 && coords.y < this.height) {
                    // on IE the mouseout event is triggered for every tile boundary,
                    // so make sure we have really crossed the viewport boudary
                    return false;
                }
                var motion = {
                    'x' : (coords.x - this.mark.x),
                    'y' : (coords.y - this.mark.y)
                };
                var moved = this.mouse_have_moved;
                this.release(coords);

                if (!moved) {
                    return false;
                }

                // only if there was little movement
                if (moved || motion.x>5 || motion.y>5) {
                    return false;
                }

                if (e.button == 2) {
                    this.blockPropagation(e);
                    this.zoom(-1);
                } else
                // move on one click
                if (e.button < 2) {
                    //if (!this.pointExceedsBoundaries(coords)) {
                        this.resetSlideMotion();
                        this.recenter(coords);
                    //}
                }

                return false;
            };
            
            // thumbnail url overwritten
            // bird-eye view cannot rely on levels in order to load thumbnail,
            // because of the way pyramid is generated.
            viewerBean.thumbnailURL = function() {
                return this.tileUrlProvider.thumbnailUrl;
            };
            
            viewerBean.update_url = function() {
                if (this.thumbnail_control) {
                    this.thumbnail_control.dom_image.src = this.thumbnailURL();
                }
                this.update();
            };
            
            PanoJS.MSG_BEYOND_MIN_ZOOM = null;
            PanoJS.MSG_BEYOND_MAX_ZOOM = null;
            viewerBean.init();
            if ((typeof init_cx != 'undefined') && (typeof init_cy != 'undefined')) {
                var scale = viewerBean.currentScale();
                viewerBean.recenter({
                    'x':parseInt(init_cx, 10)*scale,
                    'y':parseInt(init_cy, 10)*scale}, true, true);
                // Seems that if we're on the edge of image, blank tiles are not cleared...
                setTimeout(function() {
                  viewerBean.positionTiles();
                }, 5000);   // clear AFTER they have loaded (not ideal!)
            }
            if (viewerBean.thumbnail_control) {
                viewerBean.thumbnail_control.update();
            }
            if (!viewerBean.roi_control) {
                viewerBean.roi_control = new ROIControl(viewerBean);
            }
            if (!viewerBean.scalebar_control) {
                viewerBean.scalebar_control = new ScaleBarControl(viewerBean);
            }
            
            // not supported elements
            jQuery('#wblitz-zoom').parent().hide();
            jQuery('#wblitz-lp-enable').parent().hide();
            jQuery('.multiselect').hide();
            jQuery('#wblitz-invaxis').attr('disable', true);
        } else {
            viewerBean.tileUrlProvider = myProvider;
            viewerBean.update_url();
        }
        cur_zoom = viewerBean.currentScale() * 100;
    };

    // Simply causes all tiles to refresh their src
    this.refreshTiles = function () {
        if (viewerBean) {
            viewerBean.positionTiles();
        }
    };
    
    this.destroyTiles = function () {
        if (viewerBean) {
            viewerBean.clear()
            viewerBean.viewer.remove()
            viewerBean = null;
        }
    };

    this.refresh = function () {
        
      imagewidth = image.width();
      imageheight = image.height();
      wrapwidth = wrapdiv.width();
      wrapheight = wrapdiv.height();
      //orig_width = image.get(0).clientWidth;
      //orig_height = image.get(0).clientHeight;
      
      if (viewerBean != null) {
          viewerBean.resize();
      }
      
      if (panbars) {
      pantop.center();
      panbottom.center();
      panleft.center();
      panright.center();
      }
      self.doMove(0, 0);
    };

    //jQuery(window).resize(this.refresh);
  });
};


;/**
 * jquery-plugin-slider - Slider plugin for jQuery
 *
 * Depends on jquery
 *
 * Copyright (c) 2007, 2008, 2009 Glencoe Software, Inc. All rights reserved.
 * 
 * This software is distributed under the terms described by the LICENCE file
 * you can find at the root of the distribution bundle, which states you are
 * free to use it only for non commercial purposes.
 * If the file is missing please request a copy by contacting
 * jason@glencoesoftware.com.
 *
 * Author: Carlos Neves <carlos(at)glencoesoftware.com>
 */

/*
 * TODO: Make css classes configurable to avoid clashes.
 */

$.fn.gs_slider = function(cfg) {
  return this.each(function(){
      this.sliderCfg = {
        orientation: cfg && cfg.orientation == 'v' ? 'height' : 'width',
        anchor: cfg && cfg.orientation == 'v' ? 'top' : 'left',
        direction: cfg && cfg.orientation == 'v' ? -1 : 1,
        handleSize: cfg && cfg.handleSize ? cfg.handleSize : '10px',
        min: cfg && !isNaN(parseInt(cfg.min)) ? parseInt(cfg.min) : 0,
        max: cfg && !isNaN(parseInt(cfg.max)) ? parseInt(cfg.max) : 100,
        range: 0,
        repeatCallback: cfg && cfg.repeatCallback,
        tooltip_prefix: cfg && cfg.tooltip_prefix ? cfg.tooltip_prefix : ''
      };
	  this.pos = 0;
      this.sliderCfg.range = this.sliderCfg.max - this.sliderCfg.min + 1;
      if (!this.id) {
        this.id = '' + (new Date()).getTime();
      }

	  var handleId = this.id + '-shi';
	  var lineId = this.id + '-sli';
	  var btnUpId = this.id + '-bup';
	  var btnPlayUpId = this.id + '-bpup';
	  var btnDownId = this.id + '-bdn';
	  var btnPlayDownId = this.id + '-bpdn';

      var slider_container = jQuery(this);

      /* Are we horizontal or vertical? */
      if (this.sliderCfg.orientation == 'width') {
        slider_container.addClass('hslider');
      } else {
        slider_container.addClass('vslider');
      }

      /* Create the scale and handle */
      slider_container.append('<div id="'+handleId+'" class="slider-handle draggable"></div>');
      var handle = jQuery('#'+handleId);
      handle.wrap('<div id="'+lineId+'" class="slider-line"></div>');
      var handle_rel = 100.0 / this.sliderCfg.range;
      handle.css(this.sliderCfg.orientation, handle_rel + '%');
      if (handle_rel == 100) {
        handle.addClass('disabled');
      } else {
	handle.removeClass('disabled');
      }
      var slider = jQuery("#"+lineId);

      /* The buttons */
      slider.before('<div id="'+btnPlayUpId+'" class="slider-btn-playup"></div>');//&nbsp;</div>');
      slider.before('<div id="'+btnUpId+'" class="slider-btn-up"></div>');//&nbsp;</div>');
      var btnup = jQuery("#"+btnUpId);
      var btnplayup = jQuery("#"+btnPlayUpId);
      slider.after('<div id="'+btnDownId+'" class="slider-btn-down"></div>');//&nbsp;</div>');
      slider.after('<div id="'+btnPlayDownId+'" class="slider-btn-playdown"></div>');//&nbsp;</div>');
      var btndown = jQuery("#"+btnDownId);
      var btnplaydown = jQuery("#"+btnPlayDownId);

      /* Are we horizontal or vertical? */
      if (this.sliderCfg.orientation == 'width') {
        slider_container.addClass('hslider');
      } else {
        slider_container.addClass('vslider');
      }

      var self = this;

      /**
       * Gets an event (like a mouse click) and calculates the position within the slider set range.
       * Pos is relative (0..max-min-1)
       */
      var posFromEvent = function (e) {
        var xypos;
        if (self.sliderCfg.orientation == 'width') {
          xypos = e.pageX - slider.offset().left; // + (handle.get(0).clientWidth);
          xypos = xypos * 100.0 / slider.get(0).clientWidth;
        } else {
          xypos = e.pageY - slider.offset().top + (handle.get(0).clientHeight);
          xypos = xypos * 100.0 / slider.get(0).clientHeight ;
        }
        
        var pos = parseInt(xypos * (self.sliderCfg.range) / 100.0);
        if (self.sliderCfg.direction < 0) {
          pos = self.sliderCfg.range - pos;
        }
        return pos;
      };


      /**
       * Set the slider position: moves the handle and signals a 'change'.
       * The value 'pos' is expected within the allowed range set for the slider.
       * @param {Integer} pos The slider position to set.
       * @param {Tristate} trigger If null will trigger 'change' if changed. True forces the 'change' event, false inhibits it.
       */
      this.setSliderPos = function (pos, trigger) {
        var pos = Math.min(Math.max(pos, this.sliderCfg.min), this.sliderCfg.max) - this.sliderCfg.min;
        if (pos != this.pos || trigger) {
          this.pos = pos;
	  if (self.sliderCfg.range == 1) {
            handle.css(this.sliderCfg.anchor, '-1px');
	  } else if (self.sliderCfg.direction < 0) {
            handle.css(this.sliderCfg.anchor, (100.0-handle_rel-(this.pos*100.0/this.sliderCfg.range))+'%');
          } else {
            handle.css(this.sliderCfg.anchor, (this.pos*100.0/this.sliderCfg.range)+'%');
          }
	  if (trigger != false) {
	    slider_container.trigger('change', [this.sliderCfg.min + this.pos]);
	  }
	  return true;
        }
	return false;
        //handle.attr('title', this.pos + self.sliderCfg.min);
      };

      /**
       * Set the slider range and position.
       * The value 'current' is expected between the supplied 'min' and 'max'.
       * @param {Integer} min The minimal slider position to set.
       * @param {Integer} pos The maximum slider position to set.
       * @param {Integer} pos The slider position to set.
       * @param {Tristate} trigger If null will trigger 'change' if changed. True forces the 'change' event, false inhibits it.
       */
      this.setSliderRange = function (min, max, current, trigger) {
	this.sliderCfg.max = max;
	this.sliderCfg.min = min;
	this.sliderCfg.range = max - min + 1;
	handle_rel = 100.0 / this.sliderCfg.range;
	handle.css(this.sliderCfg.orientation, handle_rel + '%');
	if (handle_rel == 100) {
	  handle.addClass('disabled');
	} else {
	  handle.removeClass('disabled');
	}
	if (current != null) {
          this.setSliderPos(current, trigger);
	}
      };

      /************************/
      /* Event handling below */

      var handlesliderpos = function (e) {
        var rpos = posFromEvent(e);
        self.stoprepeat()
        self.setSliderPos(rpos+self.sliderCfg.min);
      }

      slider.on('click', handlesliderpos);

      var onrepeat = false;
      var repeat_timer;
      var ondrag = false;

      var startrepeat = function (additive) {
        onrepeat = true;
        self.setSliderPos(self.pos+self.sliderCfg.min+additive);
        var repeat_func = function (timeout) {
          repeat_timer = setTimeout(function () {
            if (onrepeat) {
              if (self.sliderCfg.repeatCallback != null && !self.sliderCfg.repeatCallback()) {
                /* The callback says we can't update to a new value yet... */
                repeat_func(20);
                return;
              }
              if (self.setSliderPos(self.pos+self.sliderCfg.min+additive)) {
                repeat_func(20);
	      } else {
		self.stoprepeat();
	      }
            }
          }, timeout);
        };
        repeat_func(500);
      }

      this.stoprepeat = function () {
        onrepeat = false;
        clearTimeout(repeat_timer);
        btnup.off('mouseout', self.stoprepeat);
        btnup.off('mouseup', self.stoprepeat);
        btndown.off('mouseout', self.stoprepeat);
        btndown.off('mouseup', self.stoprepeat);
	btnplayup.removeClass('onplay');
	btnplaydown.removeClass('onplay');
      }

      btnplayup.on('click', function () {
        var onplay = btnplayup.is('.onplay');
        self.stoprepeat();
  	if (!onplay) {
          btnplayup.toggleClass('onplay');
          startrepeat(-self.sliderCfg.direction);
	}
      });

      btnup.on('mousedown', function () {
	      self.stoprepeat();
        btnup.on('mouseup', self.stoprepeat);
        btnup.on('mouseout', self.stoprepeat);
        startrepeat(-self.sliderCfg.direction);
        return false;
      });


      btnplaydown.on('click', function () {
        var onplay = btnplaydown.is('.onplay');
        self.stoprepeat();
  	if (!onplay) {
          btnplaydown.toggleClass('onplay');
          startrepeat(self.sliderCfg.direction);
	}
      });

      btndown.on('mousedown', function () {
	self.stoprepeat();
        btndown.on('mouseup', self.stoprepeat);
        btndown.on('mouseout', self.stoprepeat);
        startrepeat(self.sliderCfg.direction);
        return false;
      });


      handle.on('mousedown', function (e) {
        /* Start handle drag */
        jQuery(document).on('mousemove', domove);
        jQuery(document).on('mouseup', stopdrag);
        ondrag = true;
        handle.addClass('ondrag');
        handle.removeClass('draggable');
        return false;
      });

      var stopdrag = function (e) {
        /* Stop handle drag */
        clearTimeout(repeat_timer);
        jQuery(document).off('mousemove', domove);
        jQuery(document).off('mouseup', stopdrag);
        ondrag = false;
        handle.addClass('draggable');
        handle.removeClass('ondrag');
	handlesliderpos(e);
      }

      var domove = function (e) {
        self.stoprepeat()
        if (ondrag) {
          var xypos, sliderSize;
          if (self.sliderCfg.orientation == 'width') {
            sliderSize = slider.get(0).clientWidth;
            xypos = e.pageX - slider.offset().left - (handle.get(0).clientWidth / 2);
          } else {
            sliderSize = slider.get(0).clientHeight;
            xypos = e.pageY - slider.offset().top - (handle.get(0).clientHeight / 2);
          }
          xypos = xypos * 100.0 / sliderSize ;
          handle.css(self.sliderCfg.anchor, Math.min(Math.max(0,xypos),(self.sliderCfg.range-1)*100.0/self.sliderCfg.range)+'%');
          //self.setSliderPos(posFromEvent(e));
        }
      };

      //jQuery(document).on('mousemove', domove);

      function follow_pos (e) {
        var pos = posFromEvent(e);
        if (pos>=0) {
          if (ondrag) {
            if (repeat_timer) {
              clearTimeout(repeat_timer);
            }
            repeat_timer = setTimeout(function () {self.setSliderPos(pos+1);}, 2000);
          }
          slider.attr('title', self.sliderCfg.tooltip_prefix + (pos+1));
        }
      }

      function ttshow (e) {
        slider.on('mousemove', follow_pos);
      }

      function tthide (e) {
        slider.off('mousemove', follow_pos);
      }

      slider.hover(ttshow, tthide);
  });
}

;/**
 * weblitz-thumbslider - Weblitz image viewport
 *
 * Depends on jquery, jquery-plugin-viewportImage, gs_utils, gs_slider
 * Uses weblitz.css
 *
 * Copyright (c) 2007-2014 Glencoe Software, Inc. All rights reserved.
 *
 * This software is distributed under the terms described by the LICENCE file
 * you can find at the root of the distribution bundle, which states you are
 * free to use it only for non commercial purposes.
 * If the file is missing please request a copy by contacting
 * jason@glencoesoftware.com.
 *
 * Author: Carlos Neves <carlos(at)glencoesoftware.com>
 */
 
 /*jshint bitwise:false */
 /*global parseQuery:true toRGB:true */

/* Public constructors */

if (!OME) {
  OME = {};
}

jQuery.fn.WeblitzViewport = function (server, options) {
  return this.each
  (
   function () {
     jQuery._WeblitzViewport (this, server, options);
   });
};

jQuery.WeblitzViewport = function (elm, server, options) {
  var container = jQuery(elm).get(0);
  var rv = container.WeblitzViewport || (container.WeblitzViewport = new jQuery._WeblitzViewport(container, server, options));
  return rv;
};

/* Helper objects */

var Metadata = function () {
  this._loaded = false;
  this.current = {};
  this.rdefs = {};
  this._load = function (data) {
    var i,j;
    var cached = {};
    if (!this._loaded) {
      this._loaded = true;
      cached.rdefs = this.rdefs;
    }
    for (i in data) {
      this[i] = data[i];
    }
    for (i in cached) {
      for (j in cached[i]) {
        this[i][j] = cached[i][j];
      }
    }
    // If a channel has 'lut', overwrite color
    this.channels = this.channels.map(function(ch){
      if (ch.lut) {
        ch.color = ch.lut;
      }
      return ch;
    });
    this.defaultZ = this.rdefs.defaultZ;
    this.current.z = this.rdefs.defaultZ;
    this.defaultT = this.rdefs.defaultT;
    this.current.t = this.rdefs.defaultT;
      if (this.rdefs.invertAxis) {
        var t = this.size.t;
        this.size.t = this.size.z;
        this.size.z = t;
      }
    this.current.zoom = 100;
  };
  
  this.hasSameSettings = function (other) {
    if (this.rdefs.model === other.rdefs.model) {
      for (var i in this.channels) {
        if (this.channels[i].active != other.channels[i].active ||
            OME.rgbToHex(this.channels[i].color) != OME.rgbToHex(other.channels[i].color) ||
            this.channels[i].emissionWave != other.channels[i].emissionWave ||
            this.channels[i].metalabel != other.channels[i].metalabel ||
            this.channels[i].window.end != other.channels[i].window.end ||
            this.channels[i].window.min != other.channels[i].window.min ||
            this.channels[i].window.max != other.channels[i].window.max ||
            this.channels[i].window.start != other.channels[i].window.start) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  return true;
};

/* (make believe) Private constructor */

/**
 * _WeblitzViewport class created in the jQuery namespace holds all logic for interfacing with the weblitz
 * viewport and ajax server.
 *
 * Own Events:
 *  - imageLoad: initial load of image data, before the actual image object is fetched (once per image id).
 *  - imageChange: image object loaded a specific image view.
 *  - channelChange:
 *  - modelChange:
 * Events Proxied from jquery-plugin-viewportImage:
 *
 *
 * @constructor
 */

String.prototype.endsWith = function(pattern) {
 var d = this.length - pattern.length;
 return d >= 0 && this.lastIndexOf(pattern) === d;
};

jQuery._WeblitzViewport = function (container, server, options) {
  if (server.endsWith("/")) {
    server = server.substring(0, server.length - 1);
  }
  this.viewport_server = server;
  this.self = jQuery(container);
  this.origHTML = this.self.html();
  this.self.html("");
  var _this = this;
  var thisid = this.self.attr('id');
  this.loadedImg = new Metadata();
  this.loadedImg_def = new Metadata();
  var topid = thisid + '-top';
  var zsliderid = thisid + '-zsl';
  var viewportid = thisid + '-vp';
  var viewportimgid = thisid + '-img';
  var viewportmsgid = thisid + '-msg';
  var bottomid = thisid + '-bot';
  var tsliderid = thisid + '-tsl';
  var ajaxTimeout;
  var tileHref;
  this.self.append('<div id="'+topid+'" id="'+topid+'" class="weblitz-viewport-top">');
  this.top = jQuery('#'+topid);
  this.top.append('<div id="'+zsliderid+'">');
  this.zslider = jQuery('#'+zsliderid);
  this.top.append('<div id="'+viewportid+'" class="weblitz-viewport-vp">');
  this.viewport = jQuery('#'+viewportid);
  this.viewport.append('<img id="'+viewportimgid+'">');
  this.viewportimg = jQuery('#'+viewportimgid);
  this.viewport.append('<div id="'+viewportmsgid+'" class="weblitz-viewport-msg"></div>');
  this.viewportmsg = jQuery('#'+viewportmsgid);
  this.self.append('<div id="'+bottomid+'" class="weblitz-viewport-bot">');
  this.bottom = jQuery('#'+bottomid);
  this.bottom.append('<div id="'+tsliderid+'">');
  this.tslider = jQuery('#'+tsliderid);

  var done_reload = function () {
    return _this.viewportmsg.is(':hidden');
  };

  this.viewportimg.viewportImage(options);
  this.viewportimg.on('zoom', function (e,z) { _this.loadedImg.current.zoom = z; });
  this.zslider.gs_slider({ orientation: 'v', min:0, max:0, tooltip_prefix: 'Z=', repeatCallback: done_reload });
  this.tslider.gs_slider({ tooltip_prefix: 'T=', min:0, max:0, repeatCallback: done_reload });
  this.viewportimg.css('overflow', 'hidden');
  this.zslider.on('change', function (e,pos) {
      if (_this.loadedImg.rdefs.invertAxis) {
	_this.loadedImg.current.t = pos-1;
      } else {
	_this.loadedImg.current.z = pos-1;
      }
        _load();
     });
  this.tslider.on('change', function (e,pos) {
      if (_this.loadedImg.rdefs.invertAxis) {
	_this.loadedImg.current.z = pos-1;
      } else {
	_this.loadedImg.current.t = pos-1;
      }
        _load();
     });
     
  
  // Sets the Z position (1-based index) of the image viewer by delegating to the slider.
  // Setting the slider should also result in the image plane changing.
  this.setZPos = function(pos) {
      if (this.getZPos() != pos) {  // don't reload etc if we don't have to
          if (_this.loadedImg.rdefs.invertAxis) {
              this.tslider.get(0).setSliderPos(pos);
          } else {
              this.zslider.get(0).setSliderPos(pos);
          }
      }
  };
  
  this.setTPos = function(pos) {
      if (this.getTPos() != pos) {
          if (_this.loadedImg.rdefs.invertAxis) {
              this.zslider.get(0).setSliderPos(pos);
          } else {
              this.tslider.get(0).setSliderPos(pos);
          }
      }
  };

  var after_img_load_cb = function (callback) {
    hideLoading();
    _this.viewportimg.show();
    
    _this.zslider.get(0).pos = -1;
    if (_this.loadedImg.rdefs.projection.toLowerCase().substring(3,0) == 'int') {
	_this.zslider.get(0).setSliderRange(1, 1, _this.getPos().z+1, false);
    } else {
	_this.zslider.get(0).setSliderRange(1, _this.getSizes().z, _this.getPos().z+1, false);
    }
      _this.tslider.get(0).setSliderRange(1, _this.getSizes().t, _this.getPos().t+1, false);
    if (callback) {
      callback();
    }
    if (_this.hasLinePlot()) {
      _this.viewportimg.one('zoom', function () {_this.refreshPlot();});
    }
  };
  
  var getSizeDict = function () {
    var size;
    if (_this.loadedImg.rdefs.projection.toLowerCase() == 'split') {
      if (_this.isGreyModel()) {
        size =  _this.loadedImg.split_channel.g;
      } else {
        size =  _this.loadedImg.split_channel.c;
      }
    } else {
      size =  _this.loadedImg.size;
    }
    return size;
  };

  /**
   * Initializes the data structures with the supplied data values.
   * Gets called as callback from the json AJAX fetching of image metadata.
   *
   * @param {Dict} data The image data from the server as a dictionary with the following keys:
   *                     {id, width, height, z_count, t_count, c_count,
   *                      rdefs:{model,},
   *                      channels:[{emissionWave,color,active},]}
   *  If a 'ConcurrencyException' is thrown, this key will be in the returned data
   */
  var _reset = function (data, textStatus) {
    hideLoading();
    clearTimeout(ajaxTimeout);
    if(!data) {
        loadError("No data received from the server.");
        return;
    }
    // If 'ConcurrencyException' we can't do anything else but notify user
    if (data["ConcurrencyException"] !== undefined) {
        /* //backOff is hardcoded on the server
        //there is no point to display it right now
        
        backOff = data["ConcurrencyException"]['backOff'];
        if (backOff != undefined || backOff != null){
            seconds = backOff/1000;
            hrs = parseInt(seconds / 3600, 10);
            mins = parseInt((seconds % 3600)/60, 10);
            secs = parseInt(seconds % (3600 * 60), 10);
            if (hrs > 0) {
                label = hrs + " hours " + mins + " minutes";
            } else if (mins > 0) {
                label = mins + " minutes";
            } else {
                label = secs + " seconds";
            }
        } */
        loadError('A "Pyramid" of zoom levels is currently being calculated for this image. Please try viewing again later.');
        return;
    } else if (data["Exception"] !== undefined) {
        loadError(data["Exception"]);
        return;
    }
    _this.loadedImg._load(data);
    _this.loadedImg_def = jQuery.extend(true, {}, _this.loadedImg);
    if (_this.loadedImg.current.query) {
      // setQuery expects 'maps' to be json
      var query_rdef = $.extend({}, _this.loadedImg.current.query);
      if (query_rdef.maps) {
        try {
          query_rdef.maps = JSON.parse(query_rdef.maps);
        } catch(err) {
          alert('maps query string is not valid json: ' + query_rdef.maps);
          query_rdef.maps = [];
        }
      }
      _this.setQuery(query_rdef);
    }
    // refresh allow_resize = true, seems to *prevent* resize (good) but don't fully understand
    _this.refresh(true);
    
    // Here we set up PanoJs Big image viewer...
    _this.viewportimg.get(0).destroyTiles();
    if (_this.loadedImg.tiles) {
        // This is called for every tile, each time they move
        var hrefProvider = function() {
          if (typeof tileHref == "undefined") {
            tileHref = server + '/render_image_region/' + _this.getRelUrl();
          }
          return tileHref;
        };
        // temporary solution for sharing. ShareId must me passed in a different way.
        thref = server + '/render_birds_eye_view/' + _this.loadedImg.id + "/";
        // if the url query had x and y, pass these to setUpTiles() so we can recenter
        var cx = _this.loadedImg.current.query.x,
          cy = _this.loadedImg.current.query.y,
          img_w = _this.loadedImg.size.width,
          img_h = _this.loadedImg.size.height,
          tile_w = _this.loadedImg.tile_size.width,
          tile_h = _this.loadedImg.tile_size.height,
          init_zoom = _this.loadedImg.init_zoom,
          zoom_levels = _this.loadedImg.levels,
          zoomLevelScaling = _this.loadedImg.zoomLevelScaling;  // may be 'undefined'
          nominalMagnification = _this.loadedImg.nominalMagnification;  // may be 'undefined'
          // If zm set in query, see if this is a supported zoom level
          if (typeof _this.loadedImg.query_zoom != "undefined") {
            var query_zm = _this.loadedImg.query_zoom / 100;
            for (var zm=0; zm<zoom_levels; zm++) {
              if (zoomLevelScaling[zm] == query_zm) {
                init_zoom = (zoom_levels-1) - zm;
                break;
              }
            }
          }
          // If init_zoom not defined, Zoom out until we fit in the viewport (window)
          if (typeof init_zoom === "undefined") {
            init_zoom = zoom_levels-1;   // fully zoomed in
            while (init_zoom > 0) {
              var omero_zm_index = (zoom_levels-1)-init_zoom,   // convert PanoJs to OMERO
                scale = zoomLevelScaling[omero_zm_index],
                scaled_w = img_w * scale,
                scaled_h = img_h * scale;
              if (scaled_w < (window.innerWidth-200) || scaled_h < (window.innerHeight-50)) {
                break;
              }
              init_zoom--;
            }
          }
        _this.viewportimg.get(0).setUpTiles(img_w, img_h, tile_w, tile_h, init_zoom, zoom_levels, hrefProvider, thref, cx, cy, zoomLevelScaling, nominalMagnification);
    }

    // Turn off interpolation if disabled
    if (!_this.loadedImg.interpolate) {
      _this.setPixelated(true);
    }
    
    _load(function () {
      //_this.refresh();
      if (!_this.loadedImg.current.query.zm && !_this.loadedImg.tiles) {
        var size = getSizeDict();
        _this.viewportimg.get(0).setZoomToFit(false, size.width, size.height);
      }
      if (_this.loadedImg.current.query.lp) {
        _this.refreshPlot();
      }
      _this.self.trigger('imageLoad', [_this]);
    });

    channels_undo_stack = [];
    channels_undo_stack_ptr = -1;
    channels_bookmark = null;
    _this.save_channels();
  };

  /**
   * Request a particular view of the current image from the server.
   * The definition of the view will be whatever is set in loadedImg at this point.
   *
   */
  var _load = function (callback) {
    if (_this.loadedImg._loaded) {
      var href, thref;
      if (_this.loadedImg.rdefs.projection.toLowerCase() != 'split') {
        href = server + '/render_image/' + _this.getRelUrl();
      } else {
        href = server + '/render_split_channel/' + _this.getRelUrl();
      }
      
      var rcb = function () {
        after_img_load_cb(callback);
        _this.viewportimg.off('load', rcb);
        _this.self.trigger('imageChange', [_this]);
      };
      
      if (_this.loadedImg.tiles) {
          // clear the cached tiles href
          tileHref = undefined;
          showLoading();
          rcb();
          _this.viewportimg.get(0).refreshTiles();
      } else {
    if (href != _this.viewportimg.attr('src')) {
          showLoading();
    }
          _this.viewportimg.on('load', rcb);
          _this.viewportimg.attr('src', href);
      }
    }
  };

  var loadError = function (msg) {
    if (_this.origHTML) {
      _this.self.replaceWith(_this.origHTML);
    }
    hideLoading();
    if (msg!=='null') {
      showLoading(msg, 5);
    } else {
      showLoading('Error loading image!', 5);
    }
  };

  /**
   * @param {Integer} iid The image id on the database.
   * @param {Integer} dsid The Dataset id this image belongs to, optional.
   */
  this.load = function(iid, dsid, query) {
    showLoading();
    linePlot = null;
    _this.refreshPlot();
    _this.loadedImg.current.datasetId = dsid;
    _this.loadedImg.current.query = parseQuery(query);
    //viewportimg.hide();
    ajaxTimeout = setTimeout(loadError, 10000);
    jQuery.getJSON(server+'/imgData/'+iid+'/?callback=?', _reset);
  };

  var loadingQ = 0;
  var showLoading = function (msg, time) {
    if (_this.viewportmsg.is(':hidden')) {
      loadingQ = 0;
    }
    if (msg === undefined) {
      msg = 'Loading...';
    }
    _this.viewportmsg.html(msg);
    loadingQ++;
    _this.viewportmsg.show();
    if (time) {
      setTimeout(function() { hideLoading(); }, time*1000);
    }
  };

  var hideLoading = function () {
    if (loadingQ > 0) {
      loadingQ--;
    }
    if (loadingQ < 1) {
      _this.viewportmsg.hide();
    }
  };

  /* Line Plot related funcs */

  var LinePlot = function (pos, direction) {
    this.position = parseInt(pos, 10);
    this._isHorizontal = direction.substring(0,1).toLowerCase() == 'h';
    this.isHorizontal = function () {
      return this._isHorizontal;
    };
    this.isVertical = function () {
      return !this._isHorizontal;
    };
    this.getUrl = function () {
      var append = this.position;//+'/'+parseInt(Math.max(1,100/_this.getZoom()*1.0), 10);
      return server+'/render_'+(this.isHorizontal()?'row':'col')+'_plot/' + _this.getRelUrl(append);
    };
  };

  var linePlot = null;

  this.hasLinePlot = function () {
    return _this.loadedImg.rdefs.projection.toLowerCase().substring(0,6) == 'normal' && _this.viewportimg.get(0).overlayVisible();
  };

  this.getLinePlot = function () {
    return linePlot;
  };

  this.prepareLinePlot = function (axis) {
    if (!linePlot || (axis == 'v' != linePlot.isVertical())) {
      linePlot = new LinePlot(0,axis,100, server, _this.getRelUrl);
    }
  };

  var pickPosHandler = function (e) {
    if (_this.getLinePlot()) {
      var pos;
      var targetpos = _this.viewportimg.offset();
      if (_this.getLinePlot().isVertical()) {
        pos = _this.loadedImg.size.width * (e.pageX - targetpos.left) / _this.viewportimg.width();
      } else {
        pos = _this.loadedImg.size.height * (e.pageY - targetpos.top) / _this.viewportimg.height();
      }
      _this.self.trigger('linePlotPos', [Math.round(pos)]);
    }
    //_this.viewportimg.removeClass('pick-pos');
  };

  this.startPickPos = function () {
    this.viewportimg.on('click', pickPosHandler);
    this.viewportimg.parent().addClass('pick-pos');
  };

  this.stopPickPos = function () {
    this.viewportimg.off('click', pickPosHandler);
    this.viewportimg.parent().removeClass('pick-pos');
  };

  this.loadPlot = function(pos) {
    linePlot.position = parseInt(pos, 10);
    this.refreshPlot();
  };

  /**
   * Loads a line plot for row {{ y }} as an image overlay.
   */
  this.loadRowPlot = function(y) {
    this.prepareLinePlot('h');
    linePlot.position = parseInt(y, 10);
    this.refreshPlot();
  };

  /**
   * Hide whatever overlay is showing.
   */
  this.hidePlot = function () {
    _this.viewportimg.get(0).hideOverlay();
  };

  /**
   * Request a refresh of the current plot.
   */
  this.refreshPlot = function (cb) {
    if (linePlot && linePlot.position <= (linePlot.isHorizontal() ? this.loadedImg.size.height : this.loadedImg.size.width)) {
      var _cb = function () {
        if (cb) {cb();}
        hideLoading();
      };
      var _error_cb = function () { hideLoading(); showLoading('Error loading line plot!', 5); };
      showLoading('Loading line plot...');
      this.viewportimg.get(0).showOverlay(linePlot.getUrl(), _cb, _error_cb);
    } else {
      this.hidePlot();
    }
    this.self.trigger('linePlotChange', [!!linePlot]);
  };

  var remember_allow_resize;
  /**
   * Recalculate GUI, useful in response to interface changes, like window resize.
   */
  this.refresh = function (allow_resize) {
    _this.viewportimg.get(0).refresh();
    var sli = jQuery('.slider-line', _this.tslider);
    var btn = jQuery('.slider-btn-up', _this.tslider);
    
    if (!(allow_resize || remember_allow_resize)) {
      var a1 = _this.self.height();
      var a2 = _this.self.width();
      var b1 = _this.top.height();
      var b2 = _this.viewport.width();
      if (a1 <= b1) {
        _this.top.css('height', _this.top.height()-_this.bottom.height());
      }
      if (a2 <= b2) {
        _this.viewport.css('width', _this.viewport.width() - _this.viewport.position().left - 3);
      }
    } else {
      remember_allow_resize = true;
    }
    _this.tslider.css('width', _this.viewport.width());
    sli.css('width', _this.tslider.width() - (parseInt(sli.css('left'), 10) *2) - 2);
    sli = jQuery('.slider-line', _this.zslider);
    btn = jQuery('.slider-btn-up', _this.zslider);
    sli.css('height', _this.top.height() - (parseInt(sli.css('top'), 10) *2) - 2);
    _this.viewport.css('height', _this.top.height() -3);
    _this.viewportimg.get(0).refresh();
  };

  /********************************************/
  /* Attribute getters/setters/wrappers below */

  this.getAuthor = function () {
    return _this.loadedImg.meta.author;
  };

  this.getChannels = function () {
    return _this.loadedImg.channels;
  };

  this.toggleChannel = function (idx) {
    this.setChannelActive(idx, !_this.loadedImg.channels[idx].active);
  };

  this.setChannelReverseIntensity = function (idx, reverse, noreload) {
    // Deprecated in OMERO 5.4.0
    console.log('setChannelReverseIntensity() Deprecated in OMERO 5.4.0. Use setChannelInverted()')
    this.setChannelInverted(idx, reverse, noreload)
  }

  this.setChannelInverted = function (idx, inverted, noreload) {
    if (_this.loadedImg.channels[idx].inverted !== inverted) {
      _this.loadedImg.channels[idx].inverted = inverted;
      _this.self.trigger('channelChange', [_this, idx, _this.loadedImg.channels[idx]]);
      if (!noreload) {
        _load();
      }
    }
  };

  this.getCCount = function () {
    return _this.loadedImg.size.c;
  };

  this.channelChange = function () {
    for (var i = 0; i < _this.loadedImg.channels.length; i++) {
      _this.self.trigger('channelChange', [_this, i, _this.loadedImg.channels[i]]);
    }
  };

  this.setChannelActive = function (idx, act, noreload) {
    // GreyModel only allows a single active channel, if not 'split' view
    if (this.isGreyModel() && this.getProjection() != 'split') {
      /* Only allow activation of channels, and disable all other */
      if (act) {
        // turn off other channels...
        for (var i = 0; i < _this.loadedImg.channels.length; i++) {
          if (i !== idx && _this.loadedImg.channels[i].active) {
            _this.loadedImg.channels[i].active = false;
            _this.self.trigger('channelChange', [_this, i, _this.loadedImg.channels[i]]);
          }
        }
        // ...then turn on active channel
        if (!_this.loadedImg.channels[idx].active) {
          _this.loadedImg.channels[idx].active = true;
        }
        // we always trigger, so last triggered channel is the active one
        _this.self.trigger('channelChange', [_this, idx, _this.loadedImg.channels[idx]]);
        _this.self.trigger('channelToggle', [_this, idx, _this.loadedImg.channels[idx]]);
        if (!noreload) {
          _load();
        }
      }
    } else {
      if (_this.loadedImg.channels[idx].active != act) {
        _this.loadedImg.channels[idx].active = act;
        _this.self.trigger('channelChange', [_this, idx, _this.loadedImg.channels[idx]]);
        if (!noreload) {
          _load();
        }
      }
    }
  };

  this.setChannelColor = function (idx, color, noreload) {
    if (color[0] === "#") color = color.replace("#", "");
    if (color !== _this.loadedImg.channels[idx].color) {
      _this.loadedImg.channels[idx].color = color;
      _this.self.trigger('channelChange', [_this, idx, _this.loadedImg.channels[idx]]);
      if (!noreload) {
        _load();
        // provide a more-granular trigger, E.g. for histogram to switch channel
        // Only do this on _load() to prevent firing on all channels E.g. in viewport.setQuery()
        _this.self.trigger('channelColorChange', [_this, idx, _this.loadedImg.channels[idx]]);
      }
    }
  };

  this.setChannelLabel = function (idx, label, noreload) {
    if (label !== _this.loadedImg.channels[idx].metalabel) {
      _this.loadedImg.channels[idx].metalabel = label;
      _this.self.trigger('channelChange', [_this, idx, _this.loadedImg.channels[idx]]);
      if (!noreload) {
        _load();
      }
    }
  };

  this.setChannelWindow = function (idx, start, end, noreload) {
    var channel = _this.loadedImg.channels[idx];
    start = parseFloat(start, 10);
    end = parseFloat(end, 10);
    if (start > end) {
      var t = start;
      start = end;
      end = t;
    }
    if (start < _this.loadedImg.pixel_range[0]) {
      start = _this.loadedImg.pixel_range[0];
    }
    if (end > _this.loadedImg.pixel_range[1]) {
      end = _this.loadedImg.pixel_range[1];
    }
    if (start !== channel.window.start || end !== channel.window.end) {
      channel.window.start = start;
      channel.window.end = end;
      _this.self.trigger('channelChange', [_this, idx, _this.loadedImg.channels[idx]]);
    }
    // Reload, e.g. after last channel changed in applyRDCW() (Even if last channel not changed)
    if (!noreload) {
      _load();
    }
  };

  this.setChannelMinMax = function () {
    var channels = _this.loadedImg.channels;
    for (var i=0; i < channels.length; i++) {
      this.setChannelWindow(i, channels[i].window.min, channels[i].window.max, true);
    }
    _load();
  };

  this.setChannelFullRange = function () {
    var channels = _this.loadedImg.channels,
      pixel_range = _this.loadedImg.pixel_range;
    for (var i=0; i < channels.length; i++) {
      this.setChannelWindow(i, pixel_range[0], pixel_range[1], true);
    }
    _load();
  };

  this.getMetadata = function () {
    return _this.loadedImg.meta;
  };

  this.getProjection = function () {
    return _this.loadedImg.rdefs.projection.toLowerCase();
  };

  this.setProjection = function (p, noreload) {
    p = p.toLowerCase();
    if (_this.loadedImg.rdefs.projection.toLowerCase() != p) {
      var was_split = _this.loadedImg.rdefs.projection.toLowerCase() == 'split',
          doReset = was_split ||  p == 'split';
      if (p.substring(3,0) == 'int' && _this.loadedImg.rdefs.invertAxis) {
        /* No intensity projections when axis are inverted */
        p = _this.loadedImg.rdefs.projection;
      } else {
        _this.loadedImg.rdefs.projection = p;
      }
      _this.self.trigger('projectionChange', [_this]);

      // if switching from 'split', and we're greyscale, need to check we only have 1 channel on
      if (was_split && this.isGreyModel()) {
        var found = false;
        for (var idx = 0; idx < _this.loadedImg.channels.length; idx++) {
          if (_this.loadedImg.channels[idx].active) {
            this.setChannelActive(idx, true, true);
            found = true;
            break;
          }
        }
        if (!found) {
          this.setChannelActive(0, true, true);
        }
      }

      if (!noreload) {
        _load(function () {
            if (doReset) {
              var size = getSizeDict();
              _this.viewportimg.get(0).setZoomToFit(true, size.width, size.height);
            }
          });
      }
    }
  };

  this.setInvertedAxis = function (p, noreload) {
    p = p=='1';
    if (_this.loadedImg.rdefs.invertAxis ^ p) {
      _this.loadedImg.rdefs.invertAxis = p;
      _this.self.trigger('invertAxis', [_this]);
	_this.loadedImg.current.query.ia = p ? "1":"0";
      if (!noreload) {
        _load(function () {
          });
      }
    }
  };

  this.setModel = function (m, noreload) {
    /* We only ever look at the first letter */
    m = m.toLowerCase().substring(0,1);
    if (_this.loadedImg.rdefs.model.toLowerCase().substring(0,1) != m) {
      _this.loadedImg.rdefs.model = m;
      //var lmc = _this.loadedImg.current.lastModelChannels;
      _this.loadedImg.current.lastModelChannels = [];
      for (var i in _this.loadedImg.channels) {
        _this.loadedImg.current.lastModelChannels.push(_this.loadedImg.channels[i].active);
      }
      ///* This is the last model state retrieval logic */
      //if (lmc) {
      //  for (i in lmc) {
      //    this.setChannelActive(i, lmc[i]);
      //  }
      //} else if (this.isGreyModel()) {
      //  this.setChannelActive(0, true);
      //}
      /* Alternative to the last model state, leftmost color going grey, selected channel only going color */
      if (this.isGreyModel()) {
        var found = false;
        for (var idx=0; idx < this.loadedImg.channels.length; idx++) {
          if (this.loadedImg.channels[idx].active) {
            this.setChannelActive(idx, true, true);
            found = true;
            break;
          }
        }
        if (!found) {
          this.setChannelActive(0, true, true);
        }
      }
      if (!noreload) {
        _load(function () {
            if (_this.loadedImg.rdefs.projection.toLowerCase() == 'split') {
              var size = getSizeDict();
              _this.viewportimg.get(0).setZoomToFit(true, size.width, size.height);
            }
          });
      }
      _this.self.trigger('modelChange', [_this]);
    }
  };

  this.getModel = function () {
    return _this.loadedImg.rdefs.model ? _this.loadedImg.rdefs.model.toLowerCase().substring(0,1) : null;
  };

  this.isGreyModel = function () {
    return _this.loadedImg.rdefs.model ? _this.loadedImg.rdefs.model.toLowerCase().substring(0,1) == 'g' : null;
  };

  this.getPixelSizes = function () {
    return _this.loadedImg.pixel_size;
  };

  this.setQuality = function (q, noreload) {
    q = parseFloat(q);
    if (q != _this.loadedImg.current.quality) {
      _this.loadedImg.current.quality = q;
      if (!noreload) {
	_load();
      }
    }
  };

  this.getQuality = function () {
    return _this.loadedImg.current.quality;
  };

  this.getServer = function () {
    return server;
  };

  this.getSizes = function () {
    var s = _this.loadedImg.size;
    var rv = {width: s.width,
        height: s.height,
        c: s.c};
    if (_this.loadedImg.rdefs.invertAxis) {
      rv.z= s.t;
      rv.t = s.z;
    } else {
      rv.z = s.z;
      rv.t = s.t;
    }
    return rv;
  };

  this.getTCount = function () {
    return _this.getSizes().t;
  };

  this.getPos = function () {
    var p = _this.loadedImg.current;
	var rv = {};
    if (_this.loadedImg.rdefs.invertAxis) {
      v.t = p.z;
      v.z = p.t;
    } else {
      rv.t = p.t;
      rv.z = p.z;
    }
    return rv;
  };

  this.getTPos = function () {
    return _this.getPos().t + 1;
  };

  this.getZCount = function () {
    return _this.getSizes().z;
  };

  this.getZPos = function () {
    return _this.getPos().z + 1;
  };

  this.setPixelated = function (pixelated) {
    _this.viewportimg.get(0).setPixelated(pixelated);
  };

  this.setZoom = function (z) {
    var size = getSizeDict();
    _this.viewportimg.get(0).setZoom(z, size.width, size.height);
  };

  this.getZoom = function () {
    if (_this.loadedImg.tiles) {
      var viewerBean = _this.viewportimg.get(0).getBigImageContainer();
      if (viewerBean) {
        return viewerBean.currentScale()*100;
      }
      return 100;
    }
    return _this.loadedImg.current.zoom;
  };

  this.setZoomToFit = function (only_shrink) {
    var size = getSizeDict();
    _this.viewportimg.get(0).setZoomToFit(only_shrink, size.width,size.height);
  };

  /*                       */
  /*************************/

  /**
   * Undo / Redo support
   */

  var channels_undo_stack = [];
  var channels_undo_stack_ptr = -1;
  var saved_undo_stack_ptr = 0;   // channels_undo_stack_ptr will start off here
  var channels_bookmark = null;

  var compare_stack_entries = function (e1, e2) {
    if (e1.model != e2.model) {
      return false;
    }
    for (var i=0; i<e1.channels.length; i++) {
      if (!(e1.channels[i].active == e2.channels[i].active &&
            e1.channels[i].color == e2.channels[i].color &&
            e1.channels[i].windowStart == e2.channels[i].windowStart &&
            e1.channels[i].windowEnd == e2.channels[i].windowEnd &&
            e1.channels[i].inverted == e2.channels[i].inverted &&
            e1.channels[i].metalabel == e2.channels[i].metalabel)) {
        return false;
      }
    }
    return true;
  };

  this.save_channels = function () {
    /* Store all useful information */
    var entry = {channels:[], model: this.getModel()};
    var channels = _this.loadedImg.channels;
    for (i=0; i<channels.length; i++) {
      var channel = {active: channels[i].active,
                     color: channels[i].color,
                     windowStart: channels[i].window.start,
                     windowEnd: channels[i].window.end,
                     inverted: channels[i].inverted,
                     metalabel: channels[i].metalabel};
      entry.channels.push(channel);
    }
    /* Trim stack to current position to dump potential redo information */
    if (channels_undo_stack_ptr == -1 || !compare_stack_entries(entry, channels_undo_stack[channels_undo_stack_ptr])) {
      channels_undo_stack_ptr++;
      channels_undo_stack.length = channels_undo_stack_ptr;
      channels_undo_stack.push(entry);
    }
  };

  this.undo_channels = function (redo) {
    if (channels_undo_stack_ptr >= 0) {
//      if (channels_undo_stack.length-1 == channels_undo_stack_ptr && !redo) {
//        /* Currently at the tip of the stack */
//        this.save_channels();
//      }
      channels_undo_stack_ptr--;
      var entry = channels_undo_stack[channels_undo_stack_ptr];
      this.setModel(entry.model);
      for (var i=0; i < entry.channels.length; i++) {
        this.setChannelWindow(i, entry.channels[i].windowStart, entry.channels[i].windowEnd, true);
        this.setChannelColor(i, entry.channels[i].color, true);
        this.setChannelActive(i, entry.channels[i].active, true);
        this.setChannelLabel(i, entry.channels[i].metalabel, true);
        this.setChannelInverted(i, entry.channels[i].inverted, true);
      }
      _load();
    }
  };

  // When we Save settings to the server, we can remember the point we saved.
  this.setSaved = function() {
    saved_undo_stack_ptr = channels_undo_stack_ptr;
    _this.loadedImg.defaultZ = this.getZPos()-1;
    _this.loadedImg.defaultT = this.getTPos()-1;
  };
  // Do we have any unsaved changes? (undo/redo since we last saved)
  this.getSaved = function() {
    var zSaved = _this.loadedImg.defaultZ === this.getZPos()-1;
    var tSaved = _this.loadedImg.defaultT === this.getTPos()-1;
    return (zSaved && tSaved && saved_undo_stack_ptr === channels_undo_stack_ptr);
  };

  this.doload = function(){
    _load();
  };

  this.has_channels_undo = function () {
    return channels_undo_stack_ptr > 0;
  };

  this.redo_channels = function () {
    if (channels_undo_stack_ptr > -1 && (channels_undo_stack.length-1 > channels_undo_stack_ptr)) {
      channels_undo_stack_ptr+=2;
      this.undo_channels(true);
    }
  };

  this.has_channels_redo = function () {
    return channels_undo_stack.length-1 > channels_undo_stack_ptr;
  };

  this.reset_channels = function () {
    if (channels_undo_stack.length > 0) {
      channels_undo_stack.length = 1;
      channels_undo_stack_ptr = 1;
      this.undo_channels(true);
    }
  };

  // bookmarks were previously set and used when rdef dialog
  // was hidden and show. Not used currently.
  this.bookmark_channels = function () {
    channels_bookmark = channels_undo_stack_ptr+1;
  };

  this.back_to_bookmarked_channels = function () {
    if (channels_bookmark) {
      channels_undo_stack_ptr = channels_bookmark;
      this.undo_channels(true);
    }
  };

  this.forget_bookmark_channels = function () {
    channels_bookmark = null;
  };


  /**
   * @return {String} The current query with state information.
   */
  this.getQuery = function (include_slider_pos, include_xy_pos, include_zoom) {
      
    var query = [];
    /* Channels (verbose as IE7 does not support Array.filter */
    var chs = [];
    var channels = this.loadedImg.channels;
    var maps_json = [];
    for (var i=0; i<channels.length; i++) {
      var ch = channels[i].active ? '' : '-';
      ch += parseInt(i, 10)+1;
      ch += '|' + channels[i].window.start + ':' + channels[i].window.end;
      ch += '$' + OME.rgbToHex(channels[i].color);
      chs.push(ch);
      maps_json.push({'inverted': {'enabled': channels[i].inverted}});
    }
    query.push('c=' + chs.join(','));
    /* Rendering Model */
    query.push('m=' + this.loadedImg.rdefs.model.toLowerCase().substring(0,1));
    /* Projection */
    query.push('p=' + this.loadedImg.rdefs.projection.toLowerCase());
    /* Inverted Axis */
    query.push('ia=' + (this.loadedImg.rdefs.invertAxis?1:0));
    /* Image Quality */
    if (this.loadedImg.current.quality) {
      query.push('q=' + this.loadedImg.current.quality);
    }
    /* Slider positions */
    if (include_slider_pos) {
      query.push('t=' + (this.loadedImg.current.t+1));
      query.push('z=' + (this.loadedImg.current.z+1));
    }
    if (include_zoom) {
        /* Zoom - getZoom() also handles big images */
        query.push('zm=' + this.getZoom());
    }
    /* Image offset */
    if (include_xy_pos) {
        if ((_this.loadedImg.tiles) && (_this.viewportimg.get(0).getBigImageContainer() )) {
            // if this is a 'big image', calculate the current center of the viewport
            var big_viewer = _this.viewportimg.get(0).getBigImageContainer();
            var big_x = big_viewer.x * -1;
            var big_y = big_viewer.y * -1;
            var big_w = big_viewer.width / 2;
            var big_h = big_viewer.height / 2;
            var big_scale = big_viewer.currentScale();
            var big_center_x = (big_x + big_w) / big_scale;
            var big_center_y = (big_y + big_h) / big_scale;
            query.push('x=' + big_center_x);
            query.push('y=' + big_center_y);
        } else {
            query.push('x=' + this.viewportimg.get(0).getXOffset());
            query.push('y=' + this.viewportimg.get(0).getYOffset());
        }
    }
    /* Line plot */
    if (this.hasLinePlot()) {
      query.push('lp=' + (linePlot.isHorizontal()?'h':'v') + linePlot.position);
    }
    if (this.loadedImg.current.query.debug !== undefined) {
      query.push('debug='+this.loadedImg.current.query.debug);
    }
    // We can 'stringify' json for url. Nicer if we remove all spaces
    query.push('maps=' + JSON.stringify(maps_json).replace(/ /g, ""));
    return query.join('&');
  };

  this.setQuery = function (query) {
    // setModel first since this affects channels we can have active
    if (query.m) this.setModel(query.m, true);
    if (query.c) {
      var chs = query.c.split(',');
      for (var j=0; j<chs.length; j++) {
        var t = chs[j].split('|');
        var idx;
        if (t[0].substring(0,1) == '-') {
          idx = parseInt(t[0].substring(1), 10)-1;
          this.setChannelActive(idx, false);
        } else {
          idx = parseInt(t[0], 10)-1;
          this.setChannelActive(idx, true);
        }
        if (t.length > 1) {
          t = t[1].split('$');
          if (t[0].endsWith('-r')) {
            this.setChannelInverted(idx, false, true);
          } else if (t[0].endsWith('r')) {
            this.setChannelInverted(idx, true, true);
          }
          t[0] = t[0].replace('-r', '').replace('r', '');  // remove 'r' if present
          var range = t[0].split(':');
          if (range.length == 2) {
            this.setChannelWindow(idx, parseFloat(range[0], 10), parseFloat(range[1], 10), true);
          }
        }
        if (t.length > 1) {
          this.setChannelColor(idx, t[1], true);
        }
      }
    }
    if (query.maps) {
      query.maps.map(function(m, idx){
        // Handle deprecated 'reverse' OR 'invert' codomain map
        if (m.reverse || m.inverted) {
          var enabled;
          if (m.inverted) {
            enabled = m.inverted.enabled;
          } else {
            enabled = m.reverse.enabled;
          }
          this.setChannelInverted(idx, enabled, true);
        }
      }.bind(this));
    }
    if (query.q) this.setQuality(query.q, true);
    if (query.p) this.setProjection(query.p, true);
    if (query.p) this.setInvertedAxis(query.ia, true);
    if (query.zm) {
      this.loadedImg.query_zoom = query.zm;  // for big images
      this.setZoom(parseInt(query.zm, 10));
    }
    if (query.t) {
      this.loadedImg.current.t = parseInt(query.t, 10)-1;
    }
    if (query.z) {
      this.loadedImg.current.z = parseInt(query.z, 10)-1;
    }
    if (query.x) this.viewportimg.get(0).setXOffset(parseInt(query.x, 10));
    if (query.y) this.viewportimg.get(0).setYOffset(parseInt(query.y, 10));
    if (query.lp) {
      this.prepareLinePlot(query.lp.substring(0,1));
      linePlot.position = parseInt(query.lp.substring(1), 10);
    }
  };

  this.getRelUrl = function (append) {
    append = append !== undefined ? '/'+append : '';
    return this.loadedImg.id + '/' + this.loadedImg.current.z + '/' + this.loadedImg.current.t + append + '/?' + this.getQuery();
  };

  this.getUrl = function (base) {
    var rv = server + '/' + base + '/' + this.getCurrentImgUrlPath();
    return rv + '?' + this.getQuery(true);
  };

  /**
   * Returns the image and optional dataset part of the url.
   */
  this.getCurrentImgUrlPath = function () {
    var rv = this.loadedImg.id + '/';
    if (this.loadedImg.current.datasetId) {
      rv += this.loadedImg.current.datasetId + '/';
    }
    return rv;
  };

  /**
   * Verifies if the image has suffered changes since it was first loaded.
   * Only changes that are related to the rendering settings are checked.
   * @return true if the rendering settings have changed, false otherwise
   */
  this.hasSettingsChanges = function () {
    return !_this.loadedImg.hasSameSettings(_this.loadedImg_def);
  };

  /**
   * Some events are handled by us, some are proxied to the viewport plugin.
   */
  this.bind = function (event, callback) {
    if (event == 'projectionChange' || event == 'modelChange' || event == 'channelChange' || event == 'channelSlide' ||
    event == 'imageChange' || event == 'imageLoad' || event == 'linePlotPos' || event == 'linePlotChange' ||
    event == 'channelToggle' || event == 'channelFocus' || event == 'channelColorChange') {
      _this.self.on(event, callback);
    } else {
      _this.viewportimg.on(event, callback);
    }
  };

  this.self.on('mousedown', function () {
    // Try to avoid selection on double click
    return false;
  });

//  this.refresh();

};


;


(function(){

    function show_change(obj, val, klass) {
        if (obj.value != val) {
            $(obj).addClass(klass);
        } else {
            $(obj).removeClass(klass);
        }
    }
    function hidePicker () {
        if ($(".picker").get(0) && $(".picker").get(0).hide_picker) {
            $(".picker").get(0).hide_picker();
        }
    }

    window.resetRDCW = function (viewport) {
        viewport.reset_channels();
        syncRDCW(viewport);
    };

    window.copyRdefs = function(viewport) {
        var rdefQry = viewport.getQuery();
        // also need pixelsType to know if we can manually paste to target
        var pr = viewport.loadedImg.pixel_range.join(":");
        rdefQry = rdefQry + "&pixel_range=" + pr;
        // Need imageId for 'apply to all'
        rdefQry = rdefQry + "&imageId=" + viewport.loadedImg.id;
        // save to session
        var jqxhr = $.getJSON(viewport.viewport_server + "/copyImgRDef/?" + rdefQry);
        jqxhr.always(function() {
            $("#rdef-paste-btn").prop('disabled', false).removeClass("button-disabled");

            // Optional : only present on webclient app
            if (window.WEBCLIENT) {
                WEBCLIENT.HAS_RDEF = true;
            }
        });
    };

    window.pasteRdefs = function (viewport) {

        var doPaste = function(data) {
            var channels = data.c.split(",");       // c=1|3336:38283$FF0000,2|1649:17015$00FF00
            if (channels.length != viewport.getChannels().length ||
                data.pixel_range != viewport.loadedImg.pixel_range.join(":")) {
                    // images are not compatible - just 'fail silently'
                    return;
            }
            // only pick what we need
            var pasteData = {'c': data.c,
                'm': data.m,
                'maps': data.maps};
            viewport.setQuery(pasteData);
            viewport.doload();        // loads image
            syncRDCW(viewport);       // update rdef table
            viewport.channelChange(); // triggers channel btn update

            // add to undo/redo queue and update undo/redo buttons.
            viewport.save_channels();
            updateUndoRedo(viewport);
        };

        // check session via /getImgRDef/ json call
        $.getJSON(viewport.viewport_server + "/getImgRDef/",
            function(data){
                if (data.rdef) {
                    doPaste(data.rdef);
                }
            }
        );
    };

    window.resetImageDefaults = function (viewport, obj, callback) {
        viewport.viewportmsg.html("Resetting...").show();
        $.getJSON(viewport.viewport_server + '/imgData/' + viewport.loadedImg.id + '/?getDefaults=true',
            function(data){
                viewport.viewportmsg.hide();
                viewport.loadedImg._load(data);

                // seems we need to do a lot of work to update UI
                viewport.doload();        // loads image
                syncRDCW(viewport);       // update rdef table
                viewport.channelChange(); // triggers channel btn update

                // add to undo/redo queue and update undo/redo buttons.
                viewport.save_channels();
                updateUndoRedo(viewport);

                if (callback) {
                    callback();
                }
            }
        );
    };

    window.setImageDefaults = function (viewport, obj, callback, skip_apply) {
        if (!skip_apply) applyRDCW(viewport);
        var old = $(obj).html();
        gs_modalJson(viewport.viewport_server + '/saveImgRDef/'+viewport.loadedImg.id+'/?'+viewport.getQuery(true),
            {},
            function(success, rv) {
                $(obj).html(old).prop('disabled', false);
                if (!(success && rv)) {
                    alert('Setting image defaults failed. Success: ' + success + ' Response: ' + rv);
                }
                if (callback) {
                    callback();
                }
                viewport.setSaved();
                updateUndoRedo(viewport);
            });
        return false;
    };

    window.zindex_automator = function(klass, basez, wspace) {
        if (!wspace) {
            wspace = $(klass);
        }
        var sorter = function (a,b) {
            return parseInt(a.css('z-index'), 10)-parseInt(b.css('z-index'), 10);
        };
        var tofront = function (e) {
            var self = this;
            var z = basez;
            var objs = [];
            $(klass).each(function () {
                if (this != self) {
                    objs.push($(this));
                }
            });
            $.each(objs.sort(sorter), function () {
                this.css('zIndex', z);
                z++;
            });
            $(self).css('zIndex', z);
        };
        $.each(wspace, function () {
            $(this).on('opening', tofront);
            $(this).on('mousedown', tofront);
        });
    };

    window.channelChange = function (ev, obj, idx, ch) {
        if (ch.active) {
            // similar buttons beside image and in rdef table
            $('#wblitz-ch'+idx).addClass('pressed');
            $('#rd-wblitz-ch'+idx).addClass('pressed');
        } else {
            $('#wblitz-ch'+idx).removeClass('pressed');
            $('#rd-wblitz-ch'+idx).removeClass('pressed');
        }
    };


    window.imageChange = function (viewport) {
        $('#wblitz-t-curr').html(viewport.getTPos());
        $('#wblitz-z-curr').html(viewport.getZPos());
        $('#wblitz-t-count').html(viewport.getTCount());
        $('#wblitz-z-count').html(viewport.getZCount());

        if (viewport.hasLinePlot() || $('#wblitz-lp-enable').prop('checked')) {
            viewport.refreshPlot();
        }
        // Z/T change update Save button
        updateUndoRedo(viewport);
    };

    window.syncChannelsActive = function(viewport) {
        var channels = viewport.getChannels();
        for (i=0; i<channels.length; i++) {
            var $chbx = $('#rd-wblitz-ch'+i);
            if ($chbx.length > 0) {     // in case this is called before UI is built
                $chbx.get(0).checked = channels[i].active;
            }
        }
    };

    function getLutIndex(lutName) {
      if (OME && OME.LUTS) {
        for (var l=0; l<OME.LUTS.length; l++) {
          if (OME.LUTS[l].name === lutName) {
            return OME.LUTS[l].png_index;
          }
        }
      }
      return -1;
    }

    function getLutBgPos(color, slider) {
        var png_height = OME.PNG_LUTS.length * 10;
        var style = {'background-size': '100% ' + (png_height * 3) + 'px'};
        var yoffset;
        if (color.endsWith('.lut')) {
            var lutIndex = getLutIndex(color);
            if (lutIndex > -1) {
                yoffset = '-' + (lutIndex * 30 + 7) + 'px';
            }
        } else {
            // Not found - show last bg (black -> transparent gradient)
            if (slider) {
                yoffset = '-' + ((OME.LUTS.length) * 30 + 7) + 'px';
            } else {
                // For buttons, hide by offsetting
                yoffset = '100px';
            }
        }
        style['background-position'] = '0px ' + yoffset;
        return style;
    }

    window.syncRDCW = function(viewport) {
        var cb, color;
        var channels = viewport.getChannels();
        var lutBgPos, sliderLutBgPos;
        for (i=0; i<channels.length; i++) {
            color = channels[i].color;
            lutBgStyle = getLutBgPos(color);
            sliderLutBgStyle = getLutBgPos(color, true);
            if (color.endsWith('.lut')) {
                color = 'EEEEEE';
            }
            // Button beside image in full viewer (not in Preview panel):
            $('#wblitz-ch' + i).css('background-color', '#' + color)
                .find('.lutBackground').css(lutBgStyle);
            // Slider background
            $('#wblitz-ch'+i+'-cwslider').find('.ui-slider-range').addClass('lutBackground')
                .css(sliderLutBgStyle)
                .css({'background-color': '#' + color,
                      'transform': channels[i].inverted ? 'scaleX(-1)' : ''});
            // Channel button beside slider
            $('#rd-wblitz-ch'+i)
                .css('background-color', '#' + color)
                .find('.lutBackground').css(lutBgStyle);
            var w = channels[i].window;
            $('#wblitz-ch'+i+'-cwslider')
                .slider( "option", "min", Math.min(w.min, w.start) )   // extend range if needed
                .slider( "option", "max", Math.max(w.max, w.end) );
            $('#wblitz-ch'+i+'-color').attr('data-color', channels[i].color);
            $('#wblitz-ch' + i + '-cw-start').val(channels[i].window.start).trigger('change');
            $('#wblitz-ch' + i + '-cw-end').val(channels[i].window.end).trigger('change');
        }
        // Colorpicker buttons store 'reverse-intensity' with .data() to populate colorbtn dialog
        $(".picker").each(function(i, pickerBtn) {
            $(pickerBtn).data('data-reverse-intensity', channels[i].inverted);
        });
        hidePicker();

        updateUndoRedo(viewport);
        $('#rd-wblitz-rmodel').prop('checked', viewport.isGreyModel());
        syncChannelsActive(viewport);
    };

    window.updateUndoRedo = function(viewport) {
        // update disabled status of undo/redo buttons
        if (viewport.has_channels_undo()) {
            $('#rdef-undo-btn').prop('disabled', false).removeClass("button-disabled");
        } else {
            $('#rdef-undo-btn').attr("disabled", "disabled").addClass("button-disabled");
        }
        if (viewport.has_channels_redo()) {
            $('#rdef-redo-btn').prop('disabled', false).removeClass("button-disabled");
        } else {
            $('#rdef-redo-btn').attr("disabled", "disabled").addClass("button-disabled");
        }
        var canSaveRdef = viewport.loadedImg.perms.canAnnotate;
        if (viewport.getSaved() || !canSaveRdef) {
            $("#rdef-setdef-btn").attr("disabled", "disabled").addClass("button-disabled");
        } else {
            $("#rdef-setdef-btn").prop('disabled', false).removeClass("button-disabled");
        }
    };

    var on_batchCopyRDefs = false;
    // TODO: try not to rely on global variables!
    window.applyRDCW = function(viewport, final) {
        if (on_batchCopyRDefs) {
            return batchCopyRDefs_action('ok');
        }
        var revInt, active;
        for (var i=0; i<viewport.getCCount(); i++) {
            active = $('#rd-wblitz-ch'+i).get(0).checked;
            if (active !== viewport.loadedImg.channels[i].active) {
                viewport.setChannelActive(i, active, true);
            }
            viewport.setChannelColor(i, $('#wblitz-ch'+i+'-color').attr('data-color'), true);
            revInt = $('#wblitz-ch'+i+'-color').data('data-reverse-intensity');
            if (revInt !== undefined) {viewport.setChannelInverted(i, revInt, true);}
            var noreload = ((i+1) < viewport.getCCount());    // prevent reload, except on the last loop
            viewport.setChannelWindow(i, $('#wblitz-ch'+i+'-cw-start').get(0).value, $('#wblitz-ch'+i+'-cw-end').get(0).value, noreload);
        }

        if (final) {
            viewport.forget_bookmark_channels();
            $('#rdef-postit').hide();
        }
        viewport.save_channels();
        syncRDCW(viewport);
    };


    window.setModel = function(viewport, model) {
        // this may turn channels on/off
        viewport.setModel(model);
        viewport.save_channels();
        syncRDCW(viewport);     // update undo/redo etc
    };


    // This is called on load of viewport in Image viewer, but not preview panel
    window._load_metadata = function(ev, viewport) {

        /* Image details */
        var tmp = viewport.getMetadata();
        $('#wblitz-image-name').html(tmp.imageName.escapeHTML());
        $('#wblitz-image-description-content').html(tmp.imageDescription.escapeHTML().replace(/\n/g, '<br />'));
        $('#wblitz-image-author').html(tmp.imageAuthor.escapeHTML());
        $('#wblitz-image-pub').html(tmp.projectName.escapeHTML());
        $('#wblitz-image-pubid').html(tmp.projectId);
        $('#wblitz-image-timestamp').html(tmp.imageTimestamp);

        $("#bulk-annotations").hide();
        $("#bulk-annotations").next().hide();
        if (tmp.wellId) {

            var wellsUrl = PLATE_WELLS_URL_999.replace('999', tmp.wellId),
                linksUrl = PLATE_LINKS_URL_999.replace('999', tmp.wellId);
            loadBulkAnnotations(wellsUrl, 'Well-' + tmp.wellId);
            loadBulkAnnotations(linksUrl, 'Well-' + tmp.wellId);
        }
    };


    // Used in the Image viewer and in metadata general panel
    window.loadBulkAnnotations = function(url, query, callback) {
        // Load bulk annotations for screen or plate
        $.getJSON(url + '?query=' + query + '&callback=?',
            function(result) {
                if (result.data && result.data.rows) {
                    var table = $("#bulk-annotations").show().next().show().children("table");
                    var html = result.data.columns.map(function(col, colIdx) {
                        var label = col.escapeHTML();
                        var values = result.data.rows.map(function(row){
                            return ("" + row[colIdx]).escapeHTML();
                        });
                        values = values.join('<br />');
                        var oddEvenClass = col % 2 == 1 ? 'odd' : 'even';
                        return '<tr><td class="title ' + oddEvenClass + '">' + label + ':&nbsp;</td><td>' + values + '</td></tr>';
                    });
                    table.html(html.join(""));
                }
                if (callback) {
                    callback(result);
                }
        });
    };

    /**
    * Gets called when an image is initially loaded.
    * This is the place to sync everything; rendering model, quality, channel buttons, etc.
    */
    window._refresh_cb = function (ev, viewport) {
        /* Sync inputs with initial values */

        $('#wblitz-rmodel').prop('checked', viewport.isGreyModel());
        $('#wblitz-invaxis').prop('checked', viewport.loadedImg.rdefs.invertAxis);

        var q = viewport.getQuality();
        if (q) {
            var qr = $('#wblitz-quality > option[value="' + q.toFixed(1) + '"]');
            if (qr.length) {
                qr.prop('selected',true);
            }
        }

        /* Prepare the channels box and the rendering definition for the channels */
        var box = $('#wblitz-channels-box');
        var channels = viewport.getChannels();
        box.empty();

        var doToggle = function(index) {
            return function() {
                viewport.toggleChannel(index);
                viewport.save_channels();
                updateUndoRedo(viewport);
                viewport.self.trigger('channelToggle', [viewport, index, viewport.loadedImg.channels[index]]);
            };
        };
        for (i=0; i<channels.length; i++) {
            $('<button id="wblitz-ch'+i+
                '" class="squared' + (channels[i].active?' pressed':'') +
                '" style="background-color: #'+ channels[i].color +
                '" title="' + channels[i].label.escapeHTML() +
                '"><div class="lutBackground"></div><div class="btnLabel">'+channels[i].label.escapeHTML()+'</div></button>')
            .appendTo(box)
            .on('click', doToggle(i));
        }

        // disable 'split' view for single channel images.
        if (channels.length < 2) {
            $("#wblitz input[value='split']").prop('disabled', true);
        }

        // TODO: this used anywhere?
        // {% block xtra_metadata %}{% endblock %}

        /*$('#wblitz-shortname').attr('title', tmp.imageName).html(gs_text_trim(tmp.imageName, 15, true));*/

        tmp = viewport.getSizes();
        $('#wblitz-image-width').html(tmp.width);
        $('#wblitz-image-height').html(tmp.height);
        $('#wblitz-image-z-count').html(tmp.z);
        $('#wblitz-image-t-count').html(tmp.t);
        tmp = viewport.getPixelSizes();
        $('#wblitz-image-pixel-size-x').html(tmp.x===null?'-':(tmp.x.lengthformat()));
        $('#wblitz-image-pixel-size-y').html(tmp.y===null?'-':(tmp.y.lengthformat()));
        $('#wblitz-image-pixel-size-z').html(tmp.z===null?'-':(tmp.z.lengthformat()));

        if (tmp.x!==0) {
            $("#wblitz-scalebar").prop("disabled", false);
        }
        /* Fill in the Rendering Details box */

        $(".picker").off('prepared').off('showing').off('hiding');
        // $('#rdef-postit ul').not('ul:last-child').remove();

        var template = '' +
          '<tr class="$cls rdef-window">' +
          '<td><button id="rd-wblitz-ch$idx0" class="rd-wblitz-ch squared $class" style="background-color: $col" ' +
            'title="$label"><div class="lutBackground"></div><div class="btnLabel">$l</div></button></td>' +
          '<td><table><tr id="wblitz-ch$idx0-cw" class="rangewidget"></tr></table></td>' +
          '<td><button id="wblitz-ch$idx0-color" class="picker squarred" title="Choose Color">&nbsp;</button></td>' +
          '</tr>';

        $('#rdef-postit table').on('focus', '.rangewidget input', function(){
            // id is wblitz-ch1-cw-start or wblitz-ch1-cw-end
            var chIdx = this.id.replace('wblitz-ch', '').split('-')[0];
            chIdx = parseInt(chIdx, 10);
            viewport.self.trigger('channelFocus', [viewport, chIdx, viewport.loadedImg.channels[i]]);
        });
        tmp = $('#rdef-postit table tr:first');
        tmp.siblings().remove();

        var start_cb = function (i) {
            return function (e) {
                var new_start = e.target.value,
                    $sl = $('#wblitz-ch'+i+'-cwslider'),
                    end = $sl.slider('values')[1],
                    min = $sl.slider( "option", "min" );
                $sl.slider('values', 0, Math.min(new_start, end));    // ensure start < end
                $sl.slider( "option", "min", Math.min(min, new_start) );   // extend range if needed
            };
        };
        var end_cb = function (i) {
            return function (e) {
                var new_end = e.target.value,
                    $sl = $('#wblitz-ch'+i+'-cwslider'),
                    start = $sl.slider('values')[0],
                    max = $sl.slider( "option", "max" );
                $sl.slider('values', 1, Math.max(new_end, start));    // ensure end > start
                $sl.slider( "option", "max", Math.max(max, new_end) );   // extend range if needed
            };
        };
        var slide_start_cb = function() {
            // Note starting values, so we can tell which handle/value changed
            // This is for floating point data where ui.values may not be what we set
            return function(event, ui) {
                $(this).data('channel_start', ui.values[0])
                    .data('channel_end', ui.values[1]);
            };
        };
        var slide_cb = function() {
            return function(event, ui) {
                // Only update the value that changed
                var s = $(this).data('channel_start');
                var e = $(this).data('channel_end');
                if (ui.values[0] !== s) {
                    $('#wblitz-ch' + $(event.target).data('channel-idx') + '-cw-start').val(ui.values[0]).trigger('change');
                } else if (ui.values[1] !== e) {
                    $('#wblitz-ch'+ $(event.target).data('channel-idx') + '-cw-end').val(ui.values[1]).trigger('change');
                }
                viewport.self.trigger("channelSlide", [viewport, $(event.target).data('channel-idx'), ui.values[0], ui.values[1]]);
            };
        };
        var stop_cb = function() {
            return function(event, ui) {
                applyRDCW(viewport);
            };
        };

        var keyup_cb = function() {
            return function(event){
                if (event.keyCode === 13){
                    applyRDCW(viewport);
                }
            };
        };

        var focusout_cb = function() {
            return function(event){
                applyRDCW(viewport);
            };
        };

        var init_ch_slider = function(i, channels) {
            var min = Math.min(channels[i].window.min, channels[i].window.start),  // range may extend outside min/max pixel
                max = Math.max(channels[i].window.max, channels[i].window.end),
                start = channels[i].window.start,
                end = channels[i].window.end,
                ptype = viewport.loadedImg.meta.pixelsType,
                step = 1;
            if (ptype == "float") {
                var STEPS = 100;
                step = (max - min) / STEPS;
            }

            $('#wblitz-ch'+i+'-cwslider').slider({
                range: true,
                step: step,
                min: min,
                max: max,
                values: [ start, end ],
                start: slide_start_cb(),
                slide: slide_cb(),
                stop: stop_cb(),
                }).data('channel-idx', i);
        };

        for (i=channels.length-1; i>=0; i--) {

            var btnClass = channels[i].active?'pressed':'';
            if (OME.isDark(channels[i].color)) {
                btnClass += " fontWhite";
            }

            var lbl = channels[i].label;
            if (lbl.length > 7) {
                lbl = lbl.slice(0, 5) + "...";
            }
            tmp.after(template
                .replace(/\$class/g, btnClass)
                .replace(/\$col/g, '#' + channels[i].color)
                .replace(/\$label/g, channels[i].label.escapeHTML())
                .replace(/\$l/g, lbl.escapeHTML())
                .replace(/\$idx0/g, i) // Channel Index, 0 based
                .replace(/\$idx1/g, i+1) // Channel Index, 1 based
                .replace(/\$cwl/g, channels[i].label.escapeHTML()) // Wavelength
                .replace(/\$cls/g, i/2!=parseInt(i/2, 10)?'even':'odd') // class
            );

            $('#wblitz-ch'+(i)+'-cw').append('<td width="10%"><span class="min" title="min: ' + channels[i].window.min + '"><input type="text" id="wblitz-ch' + i + '-cw-start" /></span></td><td><div class="rangeslider" id="wblitz-ch' + i + '-cwslider"></div></td> <td width="10%"><span class="max" title="max: ' + channels[i].window.max + '"><input type="text" id="wblitz-ch' + i + '-cw-end" /></span></td>');
            init_ch_slider(i, channels);
            $('#wblitz-ch'+i+'-cw-start').val(channels[i].window.start).off('change').on('change', start_cb(i));
            $('#wblitz-ch'+i+'-cw-start').on('keyup', keyup_cb()).on('focusout', focusout_cb());
            $('#wblitz-ch'+i+'-cw-end').val(channels[i].window.end).off('change').on('change', end_cb(i));
            $('#wblitz-ch'+i+'-cw-end').on('keyup', keyup_cb()).on('focusout', focusout_cb());
        }

        // bind clicking on channel checkboxes
        $(".rd-wblitz-ch").each(function(i){
            $(this).on('click', doToggle(i));
        });


        /* Prepare color picker buttons */
        $(".picker").each(function(i, pickerBtn) {
            $(pickerBtn).data('data-reverse-intensity', channels[i].inverted);
        });
        $(".picker")
            .colorbtn({'server': viewport.viewport_server})
            .on('showing', function () {
                var t = $(this).parents('.postit'),
                    offset;
                if (t.length) {
                  offset = t.offset();
                  offset.left += t.width();
                } else {
                  offset = {'top':'300px', 'left': window.innerWidth-250+'px'};
                }
                $('#cbpicker-box').css(offset);
                $('.picker-selected').html('&nbsp;');
                $(this).parent().siblings('.picker-selected').html('&gt;');
            })
            .on('hiding', function () {$(this).parent().siblings('.picker-selected').html('&nbsp;');})
            .on('prepared', function () {
                zindex_automator('.postit', 210, $('#cbpicker-box'));
            })
            .on('changed', function () {
                applyRDCW(viewport);
            });

        // Don't see any obvious bugs when these are removed.
        // They are both bound to appropriate triggers on viewport.
        //projectionChange(null,null, true);
        //modelChange();

        syncRDCW(viewport);

        $('#wblitz-workarea > .box > div.row').show();
    };

}());

;/**
*  plugin for displaying ROIs over an image canvas *
*  Requires Raphael      http://raphaeljs.com/
*  and scale.raphael.js  http://shapevent.com/scaleraphael/
*/

$.fn.roi_display = function(options) {
    return this.each(function(){

        var self = this;
        var viewerId = this.id;

        var $viewportimg = $(this);
        var width = $viewportimg.attr('width');   // 0 initially
        var height = $viewportimg.attr('height');

        var tiles =  (options.tiles ? options.tiles : false);

        var canvas_class = (options.canvas_class ? options.canvas_class : 'weblitz-viewport-roi');

        if (!tiles) {
            // add our ROI canvas as a sibling to the image plane. Parent is the 'draggable' div
            var $dragdiv = $viewportimg.parent();
            var canvas_name = (options.canvas_name ? options.canvas_name : viewerId + '-roi');
            var $canvas =   $('<div id="'+canvas_name+'" class="'+canvas_class+'">').appendTo($dragdiv);
        } else {
            var canvas_name = (options.canvas_name ? options.canvas_name : viewerId + '-tiles-roi');
            var $canvas = $('#'+viewerId + '-tiles-roi')
        }

        if (options != null) {
            var orig_width = options.width;
            var orig_height = options.height;
            var webgateway_index = options.webgateway_index;    // base url
            var json_url = options.json_url;
        }

        var roi_json = null;              // load ROI data as json when needed
        var active_rois = {};             // show only the active ROIs
        var external_rois = null;          // ROIs specified using an external software
        var original_shapes_backup = {};  // backup of the original configuration of shapes
        this.theZ = null;
        this.theT = null;
        var rois_displayed = false;         // flag to toggle visability.
        var roi_label_displayed = true;     // show/hide labels within shapes

        var selected_shape_id = null;  // html page is kept in sync with this
        var selectedClone = null;      // a highlighted shape cloned from currently selected shape

        // for keeping track of objects - E.g. de-select all.
        var shape_objects = new Array();

        // Creates Raphael canvas. Uses scale.raphael.js to provide paper.scaleAll(ratio);
        var paper = new ScaleRaphael(canvas_name, orig_width, orig_height);

        // convert given id to a number if possible
        var resolve_id = function(id) {
            if(isNaN(parseInt(id)))
                return id;
            else
                return parseInt(id);
        };

        // break long labels into multiple lines
        var formatShapeText = function(text_string) {
            var rows = parseInt(Math.sqrt(text_string.length / 6));     // rough ratio: cols = rows * 6
            var cols = parseInt(text_string.length/rows) + 1;
            if (text_string.length > cols) {
                var lines = [];
                var full_words = text_string.split(" ");
                var words = [];
                // first handle any words that are too long
                for (var w=0; w<full_words.length; w++) {
                    var full_word = full_words[w];
                    while (full_word.length > cols) {
                        words.push(full_word.substring(0, cols));
                        full_word = full_word.substring(cols);
                    }
                    words.push(full_word);
                }
                // now stitch words back into lines
                var line = "";
                for (var w=0; w<words.length; w++) {
                    var word = words[w];
                    if (line.length == 0) {
                        line = word;
                    }
                    else if (word.length + line.length > cols) {
                        lines.push(line);
                        line = word;
                    }
                    else {
                        line += (" " + word);
                    }
                }
                // handle the tail end
                if (line.length > 0)
                    lines.push(line);
                return lines.join("\n");
            }
            return text_string;
        };

        var getArrowPath = function getArrowPath(shape) {

            // We want the arrow tip to be precisely at x2, y2, so we
            // can't have a fat line at x2, y2. Instead we need to
            // trace the whole outline of the arrow with a thin line
            var x1 = shape['x1'],
                y1 = shape['y1'],
                x2 = shape['x2'],
                y2 = shape['y2'],
                w = shape['strokeWidth'] || 1;
            w = w * 0.5;

            var arrowStart = shape.markerStart === "Arrow";
            var arrowEnd = shape.markerEnd === "Arrow";

            var headSize = (w * 12) + 9,
                dx = x2 - x1,
                dy = y2 - y1;

            var lineAngle = Math.atan(dx / dy);
            var f = (dy < 0 ? 1 : -1);

            // We calculate the 4 corners of the Line (without arrow heads)
            var lineOffsetX = f * Math.cos(lineAngle) * w,
                lineOffsetY = f * Math.sin(lineAngle) * w,
                startLeftX = x1 - lineOffsetX,
                startLeftY = y1 + lineOffsetY,
                startRightX = x1 + lineOffsetX,
                startRightY = y1 - lineOffsetY,
                endLeftX = x2 - lineOffsetX,
                endLeftY = y2 + lineOffsetY,
                endRightX = x2 + lineOffsetX,
                endRightY = y2 - lineOffsetY;

            var arrowPath = "";
            var arrowPoint1x, arrowPoint1y, arrowPoint2x, arrowPoint2y;
            // if line starts with arrow...
            var arrowAngle1 = lineAngle - 0.35;
            var arrowAngle2 = lineAngle + 0.35;
            if (arrowStart) {
                arrowPoint1x = x1 - (f * Math.sin(arrowAngle1) * headSize);
                arrowPoint1y = y1 - (f * Math.cos(arrowAngle1) * headSize);
                arrowPoint2x = x1 - (f * Math.sin(arrowAngle2) * headSize);
                arrowPoint2y = y1 - (f * Math.cos(arrowAngle2) * headSize);
                var startArrowPointMidx = (arrowPoint1x + arrowPoint2x) / 2,
                    startArrowPointMidy = (arrowPoint1y + arrowPoint2y) / 2;
                startLeftX = startArrowPointMidx - lineOffsetX;
                startLeftY = startArrowPointMidy + lineOffsetY;
                startRightX = startArrowPointMidx + lineOffsetX;
                startRightY = startArrowPointMidy - lineOffsetY;
                // start line with Start Arrow head
                arrowPath += " M" + startRightX + " " + startRightY;
                arrowPath += " L" + arrowPoint1x + " " + arrowPoint1y + " L" + x1 + " " + y1;
                arrowPath += " L" + arrowPoint2x + " " + arrowPoint2y;
                arrowPath += " L" + startLeftX + " " + startLeftY;
            } else {
                // ...otherwise, start with plain end of line
                arrowPath += " M" + startRightX + " " + startRightY;
                arrowPath += " L" + startLeftX + " " + startLeftY;
            }

            // if line ends with arrow, line end is within arrow point
            if (arrowEnd) {
                arrowPoint1x = x2 + (f * Math.sin(arrowAngle1) * headSize);
                arrowPoint1y = y2 + (f * Math.cos(arrowAngle1) * headSize);
                arrowPoint2x = x2 + (f * Math.sin(arrowAngle2) * headSize);
                arrowPoint2y = y2 + (f * Math.cos(arrowAngle2) * headSize);
                var endArrowPointMidx = (arrowPoint1x + arrowPoint2x) / 2,
                    endArrowPointMidy = (arrowPoint1y + arrowPoint2y) / 2;
                endLeftX = endArrowPointMidx - lineOffsetX;
                endLeftY = endArrowPointMidy + lineOffsetY;
                endRightX = endArrowPointMidx + lineOffsetX;
                endRightY = endArrowPointMidy - lineOffsetY;
                // End line with End Arrow Head
                arrowPath += " L" + endLeftX + " " + endLeftY;
                arrowPath += " L" + arrowPoint1x + " " + arrowPoint1y + " L" + x2 + " " + y2;
                arrowPath += " L" + arrowPoint2x + " " + arrowPoint2y;
                arrowPath += " L" + endRightX + " " + endRightY;
            } else {
                // ...otherwise simple line end
                arrowPath += " L" + endLeftX + " " + endLeftY;
                arrowPath += " L" + endRightX + " " + endRightY;
            }

            // ...and back to start point
            arrowPath += " L" + startRightX + " " + startRightY;

            return arrowPath;
        };


        var draw_shape = function(shape) {
            console.log(shape['type']);
            var newShape = null;
            if (shape['type'] == 'Mask') {
              var src = webgateway_index + 'render_shape_mask/' + shape['id'] + '/';
              newShape = paper.image(src, shape['x'], shape['y'], shape['width'], shape['height']);
            }
            if (shape['type'] == 'Ellipse') {
              newShape = paper.ellipse(shape['x'], shape['y'], shape['radiusX'], shape['radiusY']);
            }
            else if (shape['type'] == 'Rectangle') {
              newShape = paper.rect(shape['x'], shape['y'], shape['width'], shape['height']);
            }
            else if (shape['type'] == 'Point') {
              newShape = paper.ellipse( shape['x'], shape['y'], 2, 2);
            }
            else if (shape['type'] == 'Line') {
              // define line as 'path': Move then Line: E.g. "M10 10L90 90"

              if (shape.markerStart || shape.markerEnd) {
                var arrowPath = getArrowPath(shape);

                newShape = paper.path(arrowPath);
                newShape.attr({'stroke-width': 0});
                // We don't want to apply strokeWidth later
                shape['strokeWidth'] = 0;
                shape['fillColor'] = shape['strokeColor'];
                shape['fillAlpha'] = shape['strokeAlpha'];
              } else {
                newShape = paper.path("M"+ shape['x1'] +" "+ shape['y1'] +"L"+ shape['x2'] +" "+ shape['y2'] );
              }

            }
            else if (shape['type'] == 'PolyLine') {
              newShape = paper.path( shape['points'] );
            }
            else if (shape['type'] == 'Polygon') {
              newShape = paper.path( shape['points'] );
            }
            else if (shape['type'] == 'Label') {
              if (shape['textValue']) {
                  newShape = paper.text(shape['x'], shape['y'], shape['textValue'].escapeHTML()).attr({'text-anchor':'start'});
              }
            }
            // handle transforms. Insight supports: translate(354.05 83.01) and rotate(0 407.0 79.0)
            if (shape['transform']) {
                if (shape['transform'].substr(0, 'translate'.length) === 'translate'){
                    var tt = shape['transform'].replace('translate(', '').replace(')', '').split(" ");
                    var tx = parseInt(tt[0]);   // only int is supported by Raphael
                    var ty = parseInt(tt[1]);
                    newShape.translate(tx,ty);
                }
                else if (shape['transform'].substr(0, 'rotate'.length) === 'rotate'){
                    var tt = shape['transform'].replace('rotate(', '').replace(')', '').split(" ");
                    var deg = parseFloat(tt[0]);
                    var rotx = parseFloat(tt[1]);
                    var roty = parseFloat(tt[2]);
                    newShape.rotate(deg, rotx, roty);
                }
                else if (shape['transform'].substr(0, 'matrix'.length) === 'matrix'){
                    var tt = shape['transform'].replace('matrix(', '').replace(')', '').split(" ");
                    var a1 = parseFloat(tt[0]);
                    var a2 = parseFloat(tt[1]);
                    var b1 = parseFloat(tt[2]);
                    var b2 = parseFloat(tt[3]);
                    var c1 = parseFloat(tt[4]);
                    var c2 = parseFloat(tt[5]);
                    var tmatrix = "m"+a1+","+a2+","+b1+","+b2+","+c1+","+c2;
                    newShape.transform(tmatrix);
                }
            }
            return newShape;
        }

        var get_tool_tip = function(shape) {
            var toolTip = "";
            if (shape['type'] == 'Ellipse') {
              toolTip = "x:"+ shape['x'] +" y:"+ shape['y'] +" radiusX:"+ shape['radiusX'] + " radiusY: "+  shape['radiusY'];
            }
            else if (shape['type'] == 'Rectangle') {
              toolTip = "x:"+ shape['x'] +" y:"+ shape['y'] +
                " width:"+ shape['width'] + " height: "+  shape['height'];
            }
            else if (shape['type'] == 'Point') {
              toolTip = "x:"+ shape['x'] +" y:"+ shape['y'];
            }
            else if (shape['type'] == 'Line') {
              toolTip = "x1:"+ shape['x1'] +" y1:"+ shape['y1'] +" x2:"+ shape['x2'] +" y2:"+ shape['y2'];
            }
            else if (shape['type'] == 'PolyLine') {
            }
            else if (shape['type'] == 'Polygon') {
            }
            else if (shape['type'] == 'Label') {
            }
            return toolTip;
        }

        // if the currently selected shape is visible - highlight it
        display_selected = function() {
            // *NB: For some reason, can't overlay text with selectedClone.
            // So, for text shapes, we highlight by editing attributes instead.
            if ((selectedClone != null) && (selectedClone.type != 'text')) {
                if (selectedClone.node.parentNode.parentNode) selectedClone.remove();
            }
            if (selected_shape_id == null) return;

            selectedClone = null;
            for (var i=0; i<shape_objects.length; i++) {
                var s = shape_objects[i];
                var shape_id = resolve_id(s.id);
                if (shape_id == selected_shape_id) {
                    if (s.type == 'text') {
                        selectedClone = null;
                        strokeWidth = Math.ceil(s.attr('font-size')/10);
                        s.attr({'stroke': '#00a8ff', 'stroke-width': strokeWidth});
                    } else {
                        strokeWidth = (s.attr('stroke-width') > 0) ? Math.ceil(s.attr('stroke-width')/2) : 1;
                        selectedClone = s.clone();
                        selectedClone.attr({'stroke': '#00a8ff', 'stroke-width': strokeWidth,
                                            'fill-opacity': 0});
                    }
                } else {
                    if (s.type == 'text') {
                        s.attr({'stroke': null, 'stroke-width': null}); // remove stroke
                    }
                }
            }
            return selectedClone;
        }

        this.set_selected_shape = function(shape_id) {
            selected_shape_id = shape_id;
            $viewportimg.trigger("shape_click", [shape_id]);
            var sel_shape = display_selected();
            var sel_x;
            var sel_y;
            // we will only get the shape if currently displayed (current Z/T section)
            if (sel_shape===null) {
                // otherwise we have to work it out by drawing it
                var bb = null;
                for (var r=0; r<roi_json.length; r++) {
                    if (bb != null)   break;
                    var roi = roi_json[r];
                    var shapes = roi['shapes'];
                    var shape = null;
                    for (var s=0; s<shapes.length; s++) {
                        shape = shapes[s];
                        if (shape['id'] == selected_shape_id) {
                            var newShape = draw_shape(shape);
                            bb = newShape.getBBox();
                            newShape.remove();
                            if (shape['type'] == 'Label'){
                                // bug in BBox for text
                                sel_x = shape['x'] + (bb.width/2);
                                sel_y = shape['y'] + (bb.height/2);
                            } else {
                                sel_x = bb.x + (bb.width/2);
                                sel_y = bb.y + (bb.height/2);
                            }
                        }
                    }
                }
            } else {
                var bb = sel_shape.getBBox();
                sel_x = bb.x + (bb.width/2);
                sel_y = bb.y + (bb.height/2);
            }
            return {'x':sel_x, 'y':sel_y};
        }

        // called when user clicks on ROI
        handle_shape_click = function(event) {
            var shape = this;
            var shape_id = resolve_id(shape.id);
            self.set_selected_shape(shape_id);
        }

        // load the ROIs from json call and display
        load_rois = function(display_rois, filter, callback) {
            if (json_url == undefined) return;

            $.getJSON(json_url+'?callback=?', function(data) {
                roi_json = data;

                // plot the rois
                if (display_rois) {
                  rois_displayed = true;
                  refresh_rois(undefined, undefined, filter);
                }
                $viewportimg.trigger("rois_loaded");

                if (callback) {
                    callback();
                }
            });
        }

        /*
        If filter is not 'undefined' use the given ROI and shape IDs to build the list of active
        elements that will be shown by the web viewer.
        Filter is an associative array like
          {
           12: [1,2,3],
           13: []
          }
        where keys are the ID of the ROIs and values lists with IDs of the selected shapes for
        the given ROIs. If the value of a key is an empty list, all shapes related to that ROI
        will be considered as active.
        If the filter is 'undefined' set all ROIs and shapes coming from the DB as active.
        The active_rois object will be used to determinate which shapes will be displayed by the
        user interface when a change on the viewport occurs (like changing the Z or the T value).
         */
        filter_rois = function (filter) {
            var global_rois = [];
            $.merge(global_rois, roi_json);
            if (external_rois)
                $.merge(global_rois, external_rois);

            if (filter != undefined) {
                for (var r=0; r<global_rois.length; r++) {
                    // check if ROI is in filter
                    if (filter.hasOwnProperty(global_rois[r].id)) {
                        if (!active_rois.hasOwnProperty(global_rois[r].id))
                            active_rois[global_rois[r].id] = [];
                        // check if one or more shapes of the current ROI are in filter
                        var shapes = global_rois[r]['shapes'];
                        for (s=0; s<shapes.length; s++) {
                            if (filter[global_rois[r].id].indexOf(shapes[s].id) != -1 &&
                                active_rois[global_rois[r].id].indexOf(shapes[s].id) == -1) {
                                active_rois[global_rois[r].id].push(shapes[s].id);
                            }
                        }
                    }
                }
            } else {
                for (var r=0; r<global_rois.length; r++) {
                    if (!active_rois.hasOwnProperty(global_rois[r].id)) {
                        active_rois[global_rois[r].id] = [];
                    }
                    var shapes = global_rois[r]['shapes'];
                    for (s=0; s<shapes.length; s++) {
                        if (active_rois[global_rois[r].id].indexOf(shapes[s].id) == -1)
                            active_rois[global_rois[r].id].push(shapes[s].id);
                    }
                }
            }
        }

        /*
        Use active_rois to actually filter and retrieve ROIs and shapes that are going to be
        visualized in the viewport from the list of ROIs retrieved from the server.
        The list of ROIs coming from the server, referenced as 'roi_json', won't be modified.
         */
        get_active_rois = function () {
            var act_rois = [];

            // merge ROIs coming from OMERO server and external ROIs
            var global_rois = [];
            $.merge(global_rois, roi_json);
            if (external_rois)
                $.merge(global_rois, external_rois);
            for (var r=0; r<global_rois.length; r++) {
                if (active_rois.hasOwnProperty(global_rois[r].id)) {
                    var roi = {"id": global_rois[r].id};
                    var shapes = global_rois[r].shapes;
                    if (active_rois[global_rois[r].id].length == 0) {
                        // No filter for the shapes, append all of them
                        roi['shapes'] = shapes;
                        // Update filter as well, this will make possible to selectively disable shapes
                        for (s = 0; s < shapes.length; s++) {
                            active_rois[global_rois[r].id].push(shapes[s].id);
                        }
                    }
                    else {
                        roi['shapes'] = [];
                        for (s=0; s<shapes.length; s++) {
                            // Add only active shapes
                            if (active_rois[global_rois[r].id].indexOf(shapes[s].id) != -1) {
                                roi['shapes'].push(shapes[s]);
                            }
                        }
                    }
                    act_rois.push(roi);
                }
            }
            return act_rois;
        }

        // get the filter that describes currently active ROIs and shapes
        this.get_current_rois_filter = function() {
            if (typeof active_rois != "undefined") {
                if (Object.keys(active_rois).length == 0) {
                    return undefined;
                } else {
                    return active_rois;
                }
            } else {
                return undefined;
            }
        }

        // activate ROI with ID 'roi_id' and its related shapes
        this.activate_roi = function (roi_id) {
            var roi_id = resolve_id(roi_id);
            if (!active_rois.hasOwnProperty(roi_id)) {
                active_rois[roi_id] = [];
            }
        }

        // deactivate ROI with ID 'roi_id' and its related shapes
        this.deactivate_roi = function (roi_id) {
            var roi_id = resolve_id(roi_id);
            if (active_rois.hasOwnProperty(roi_id)) {
                delete active_rois[roi_id];
            }
        }

        // activate shape with ID 'shape_id' related to ROI with ID 'roi_id'
        this.activate_shape = function (roi_id, shape_id) {
            var roi_id = resolve_id(roi_id);
            var shape_id = resolve_id(shape_id);
            if (active_rois.hasOwnProperty(roi_id)) {
                if (active_rois[roi_id].indexOf(shape_id) == -1)
                    active_rois[roi_id].push(shape_id);
            } else {
                this.activate_roi(roi_id);
                this.activate_shape(roi_id, shape_id);
            }
        }

        // deactivate shape with ID 'shape_id' related to ROI with ID 'roi_id'
        this.deactivate_shape = function(roi_id, shape_id) {
            var roi_id = resolve_id(roi_id);
            var shape_id = resolve_id(shape_id);
            if (active_rois.hasOwnProperty(roi_id)) {
                if (active_rois[roi_id].indexOf(shape_id) != -1) {
                    active_rois[roi_id].splice(active_rois[roi_id].indexOf(shape_id), 1);
                }
                // If no shape remains, delete the ROI from active_rois list
                if (active_rois[roi_id].length == 0) {
                    this.deactivate_roi(roi_id);
                }
            }
        }

        // returns the ROI data as json. May be null if not yet loaded!
        this.get_roi_json = function() {
            return roi_json;
        }

        // return the data of external ROI as json. May be null if not loaded!
        this.get_external_rois_json = function() {
            return external_rois;
        }

        // get json of all ROI, OME ones and external ones, as a unique list
        this.get_full_roi_json = function() {
            if (!roi_json && !external_rois)
                return null;
            else if (roi_json && external_rois)
                return $.merge(roi_json, external_rois);
            else if (roi_json && !external_rois)
                return roi_json;
            else if (!roi_json && external_rois)
                return external_rois;
        }

        /*
        Check if given ROI and SHAPE ID can be used to define a new external ROI.
        ROI ID is valid if it is not alredy in use by an OME ROI.
        SHAPE ID is valid if it is not alredy in use by another shape for external ROI with given ROI ID.
         */
        var check_ext_shape_id = function(roi_id, shape_id) {
            // check if ROI ID is already used by one on OMERO's ROIs...
            for (var rx=0; rx<roi_json.length; rx++) {
                if (roi_json[rx]["id"] == roi_id) {
                    console.error("ID " + roi_id + " already used by one of OMERO ROIs");
                    return false;
                }
            }
            // ... if roi_id is used by an external ROI, check shape_id
            for (var rx=0; rx<external_rois.length; rx++) {
                if (external_rois[rx]["id"] == roi_id) {
                    var shapes = external_rois[rx]["shapes"];
                    for (var sx=0; sx<shapes.length; sx++) {
                        if (shapes[sx]["id"] == shape_id) {
                            console.error("Shape ID " + shape_id + " already in use for ROI " + roi_id);
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // Check if there is another shape with on the same Z and T planes for this ROI
        var check_ext_shape_planes = function(roi_id, shape_z, shape_t) {
            for (var rx=0; rx<external_rois.length; rx++) {
                if (external_rois[rx]["id"] == roi_id) {
                    var shapes = external_rois[rx]["shapes"];
                    for(var sx=0; sx<shapes.length; sx++) {
                        if (shapes[sx]["theZ"] == shape_z && shapes[sx]["theT"] == shape_t) {
                            console.error("Z plane " + shape_z + " and T plane " + shape_t + " already used");
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // configure a shape obtained using function in ome.roiutils.js as a proper shape for OMERO.web viewer
        var configure_shape = function(shape_id, shape_config) {
            shape_config["id"] = shape_id;
        }

        // build a proper ROI definition that can be used by OMERO.web viewer
        var build_roi_description = function(roi_id, shapes) {
            return {
                "id": roi_id,
                "shapes": typeof shapes !== "undefined" ? shapes : []
            };
        }

        // append a shape to ROI with ID roi_id
        var append_shape = function(roi_id, shape_config, rois_collection) {
            for (var x=0; x<rois_collection.length; x++) {
                if (rois_collection[x]["id"] == roi_id) {
                    // ROI with ID roi_id already exists, append shape
                    rois_collection[x]["shapes"].push(shape_config);
                    return;
                }
            }
            var roi = build_roi_description(roi_id, [shape_config]);
            rois_collection.push(roi);
        };

        /*
        Add a SHAPE definition to OMERO.web viewer. Shape will be associated to ROI with ID roi_id
        and will obtain ID shape_id. Shape is described using shape_config dictionary.
        If refresh_rois is TRUE, automatically refresh viewport.
        If hide_ome_rois is TRUE, hide OME ROI when refreshing viewport.
         */
        this.add_external_shape = function(roi_id, shape_id, shape_config, refresh_rois, hide_ome_rois) {
            if (roi_json == null) {
                load_rois(false, undefined, function() {
                    $viewportimg.trigger("add_external_shape",
                        [roi_id, shape_id, shape_config, refresh_rois, hide_ome_rois]);
                });
            } else {
                $viewportimg.trigger("add_external_shape", [roi_id, shape_id, shape_config, refresh_rois,
                    hide_ome_rois]);
            }
        };

        $viewportimg.on("add_external_shape", function (event, roi_id, shape_id, shape_config,
                                                        refresh_rois, hide_ome_rois) {
            var roi_id = resolve_id(roi_id);
            var shape_id = resolve_id(shape_id);

            // initialize external_rois when used for the first time
            if (!external_rois) {
                external_rois = [];
            }

            var check_shape_id = check_ext_shape_id(roi_id, shape_id);
            var check_shape_planes = check_ext_shape_planes(roi_id, shape_config['theZ'],
                shape_config['theT']);

            if (check_shape_id && check_shape_planes) {
                // add ID to the shape
                configure_shape(shape_id, shape_config);
                // append shape to proper ROI
                append_shape(roi_id, shape_config, external_rois);
                this.activate_roi(roi_id);
            }

            // refresh current ROIs (False by default)
            var refresh = typeof refresh_rois !== "undefined" ? refresh_rois : false;
            if (refresh) {
                // if hide_ome_rois is true, deactivate all ROIs coming from OMERO before refresh
                var hide_oroi = typeof hide_ome_rois !== "undefined" ? hide_ome_rois : false;
                if (hide_oroi && active_rois) {
                    for (var r = 0; r < roi_json.length; r++) {
                        this.deactivate_roi(roi_json[r]["id"]);
                    }
                }
                this.refresh_active_rois();
            }
        });

        /*
        Remove SHAPE with ID shape_id from ROI with ID roi_id from external ROI list.
        If refresh is TRUE, automatically refresh viewport.
         */
        this.remove_external_shape = function(roi_id, shape_id, refresh) {
            if (! external_rois) {
                console.warn("There are no external ROIs, nothing to do");
                return;
            }
            for(var r=0; r<external_rois.length; r++) {
                var roi = external_rois[r];
                if (roi["id"] == resolve_id(roi_id)) {
                    for(var s=0; s<roi["shapes"].length; s++) {
                        var shape = roi["shapes"][s];
                        if (shape["id"] == resolve_id(shape_id)) {
                            roi["shapes"].splice(roi["shapes"].indexOf(shape), 1);

                            // If it was the last shape for the current ROI, delete the ROI as well
                            if(roi["shapes"].length == 0) {
                                console.warn("No shape connected, removing ROI " + roi_id);
                                this.remove_roi(roi_id, refresh);
                            } else {
                                // refresh ROIs, if needed
                                var refresh = typeof refresh_rois !== "undefined" ? refresh_rois : false;
                                if (refresh)
                                    this.refresh_active_rois();

                                return;
                            }
                        }
                    }
                    console.warn("There is no Shape with ID " + shape_id + " for ROI " + roi_id);
                    return;
                }
            }
            console.warn("There is no ROI with ID " + roi_id);
        };
        /*
        Remove ROI with ID roi_id from external ROI list.
        If refresh is TRUE, automatically refresh viewport.
         */
        this.remove_external_roi = function(roi_id, refresh) {
            if (! external_rois) {
                console.warn("There are no external ROIs, nothing to do");
                return;
            }
            for (var r=0; r<external_rois.length; r++) {
                var roi = external_rois[r];
                if (roi["id"] == resolve_id(roi_id)) {
                    external_rois.splice(external_rois.indexOf(roi), 1);
                    this.deactivate_roi(resolve_id(roi_id));

                    var refresh = typeof refresh !== "undefined" ? refresh : false;
                    if (refresh) {
                        if (Object.keys(active_rois).length != 0) {
                            this.refresh_active_rois();
                        } else {
                            this.hide_rois();
                        }
                    }
                    return;
                }
            }
            console.warn("There is no ROI with ID " + roi_id);
        }

        /*
        Clears paper and draws ROIs (if rois_displayed) for the given T and Z. NB: indexes are 1-based.
        Only shapes in 'active_rois' are going to be displayed.
        */
        this.refresh_rois = function(theZ, theT, rois_filter) {

            if (typeof theZ != 'undefined') this.theZ = theZ;
            if (typeof theT != 'undefined') this.theT = theT;

            paper.clear();
            shape_objects.length = 0;
            if (!rois_displayed) return;
            // build the filter for active ROIs and shapes
            filter_rois(rois_filter);
            // apply the filter and get the description of ROIs and shapes that will be displayed
            var rois = get_active_rois();
            if (rois == null) return;

            for (var r=0; r<rois.length; r++) {
                var roi = rois[r];
                var shapes = roi['shapes'];
                var shape = null;
                for (var s=0; s<shapes.length; s++) {
                    shape = shapes[s];
                    if (((shape.theT == this.theT-1)
                         || typeof shape.theT === "undefined")
                        && ((shape.theZ == this.theZ-1)
                            || typeof shape.theZ === "undefined")) {
                        var newShape = draw_shape(shape);
                        var toolTip = get_tool_tip(shape);
                        // Add text - NB: text is not 'attached' to shape in any way.
                        if (newShape != null) {
                            if (shape['type'] == 'PolyLine') {
                                newShape.attr({'fill-opacity': 0});
                            }
                            if ((shape['textValue'] != null) && (shape['textValue'].length > 0)) {
                                // Show text
                                if (shape['type'] == 'Label') {
                                    var txt = newShape; // if shape is label itself, use it
                                    if (shape['strokeColor']) txt.attr({'fill': shape['strokeColor']}); // this is Insight's behavior
                                    txt.attr({'stroke': null });
                                } else if (roi_label_displayed) {
                                    // otherwise, add a new label in the centre of the shape.
                                    var bb = newShape.getBBox();
                                    var textx = bb.x + (bb.width/2);
                                    var texty = bb.y + (bb.height/2);
                                    var text_string = formatShapeText(shape['textValue'])
                                    var txt = paper.text(textx, texty, text_string);    // draw a 'dummy' paragraph to work out it's dimensions
                                    var newY = (texty-txt.getBBox().height/2)+9;
                                    // moving the existing text to newY doesn't seem to work - instead, remove and draw a new one
                                    txt.remove();
                                    txt = paper.text(textx, newY, formatShapeText(shape['textValue']))
                                               .attr({'cursor':'default', 'fill': shape['strokeColor']}); // this is Insight's behavior
                                    txt_box = txt.getBBox();
                                    var txt_w = txt_box.width*1.3;
                                    var txt_h = txt_box.height*1.3;
                                    txt.toFront();
                                    // clicking the text should do the same as clicking the shape
                                    txt.id = shape['id'] + "_shape_text";
                                    txt.click(handle_shape_click);

                                }

                                // handle other text-specific attributes...
                                var txtAttr = {};
                                if (shape['fontFamily']) {  // model: serif, sans-serif, cursive, fantasy, monospace. #5072
                                    // raphael supports all these exactly - so we can pass directly.
                                    txtAttr['font-family'] = shape['fontFamily'];
                                }
                                if (shape['fontSize']) {
                                    txtAttr['font-size'] = shape['fontSize'];
                                }
                                if (shape['fontStyle']) { // model: Normal, Italic, Bold, Bolditalic
                                    var fs = shape['fontStyle'];
                                    if ((fs == 'Bold') || (fs == 'BoldItalic')) {
                                        txtAttr['font-weight'] = 'bold';
                                    }
                                    if ((fs == 'Italic') || (fs == 'BoldItalic')) {
                                        txtAttr['font-style'] = 'italic';
                                    }
                                }
                                if (txt) txt.attr(txtAttr);
                            }
                            if (shape['type'] != 'Label') {
                                // these shape attributes are not applied to text
                                if (shape['fillColor'] && shape['type'] != 'PolyLine') {
                                    // don't show fills on PolyLines
                                    newShape.attr({'fill': shape['fillColor']});
                                    if (shape['fillAlpha']) { newShape.attr({'fill-opacity': shape['fillAlpha']})}
                                }
                                else {
                                    // need *some* fill so that shape is clickable
                                    newShape.attr({'fill':'#000', 'fill-opacity': 0.01 });
                                }
                                if (shape['strokeAlpha']) { newShape.attr({'stroke-opacity': shape['strokeAlpha']}); }
                                if (shape['strokeColor']) { newShape.attr({'stroke': shape['strokeColor']}); }
                                else { newShape.attr({'stroke': '#ffffff'}); }  // white is default
                            }
                            newShape.attr({'cursor':'default'});
                            if (shape['strokeWidth']) { newShape.attr({'stroke-width': shape['strokeWidth']}); }
                            newShape.click(handle_shape_click);
                            newShape.attr({ title: toolTip });
                            newShape.id = shape['id'] + "_shape";
                            shape_objects.push(newShape);
                        }

                    }
                }
            }
            // if the new display includes selected-shape - show it
            display_selected();
        }

        // refresh the viewport using 'active_rois' as filter
        this.refresh_active_rois = function (theZ, theT) {
            rois_displayed = true;
            refresh_rois(theZ, theT, active_rois);
        }

        // loads the ROIs if needed and displays them
        this.show_rois = function(theZ, theT, filter) {
            this.theZ = theZ;
            this.theT = theT;
          if (roi_json == null) {
              load_rois(true, filter);      // load and display
          } else {
              rois_displayed = true;
              this.refresh_rois(undefined, undefined, filter);
          }
        }

        // hides the ROIs from display
        this.hide_rois = function(hide_ome_rois, hide_external_rois) {
            var hide_ome_rois = typeof hide_ome_rois !== "undefined" ? hide_ome_rois : true;
            var hide_external_rois = typeof hide_external_rois !== "undefined" ? hide_external_rois : true;

            if (!hide_ome_rois && !hide_external_rois) {
                console.warn("HIDE_OME_ROIS and HIDE_EXTERNAL_ROIS are False, nothing to do");
                return;
            }

            if (hide_ome_rois && hide_external_rois) {
                rois_displayed = false;
                active_rois = {};
                this.refresh_rois();
            } else {
                if (!hide_ome_rois) {
                    for (var r = 0; r < external_rois.length; r++) {
                        delete(active_rois[external_rois[r].id]);
                    }
                }
                else if (!hide_external_rois) {
                    for (var r = 0; r < roi_json.length; r++) {
                        delete(active_rois[roi_json[r].id]);
                    }
                }
                if (Object.keys(active_rois).length == 0) {
                    rois_displayed = false;
                    this.refresh_rois();
                }
                else {
                    this.refresh_active_rois();
                }
            }
        }

        // Retrieve shape with ID shape_id from ROI with ID roi_di from roi_list
        get_shape = function(roi_id, shape_id, roi_list) {
            for (var rx=0; rx<roi_list.length; rx++) {
                if (roi_list[rx].id == roi_id) {
                    var shapes = roi_list[rx].shapes;
                    for (var sx=0; sx<shapes.length; sx++) {
                        if (shapes[sx].id == shape_id)
                            return shapes[sx];
                    }
                    console.error("ROI with ID " + roi_id + "has no shape with ID " + shape_id);
                }
            }
            return null;
        }

        // Get backup key for given roi_id and shape_id
        get_backup_key = function(roi_id, shape_id) {
            return roi_id + "::" + shape_id;
        }

        /*
        Save a backup copy of shape_config using shape_id and roi_id to build backup key.
        If a backup for given shape_id and roi_id already exists, do nothing.
         */
        backup_shape = function(roi_id, shape_id, shape_conf) {
            var backup_key = get_backup_key(roi_id, shape_id);
            if (!(backup_key in original_shapes_backup)) {
                // clone the shape_conf object as "original" and keep a reference to updated object (used to restore)
                original_shapes_backup[backup_key] = $.extend({}, shape_conf);
            }
        }

        /*
        Restore from backup SHAPE with ID shape_id for ROI with id roi_id.
        If refresh_view is TRUE, automatically refresh viewport.
         */
        this.restore_shape = function(roi_id, shape_id, refresh_view) {
            var refresh_view = typeof refresh_view !== "undefined" ? refresh_view : true;
            var backup_key = get_backup_key(roi_id, shape_id);
            if (backup_key in original_shapes_backup) {
                var original_shape = original_shapes_backup[backup_key];
                this.update_shape_text(roi_id, shape_id, original_shape.textValue, original_shape.fontFamily,
                    original_shape.fontSize, original_shape.fontStyle, false);
                this.update_shape_config(roi_id, shape_id, original_shape.strokeColor, original_shape.strokeAlpha,
                    original_shape.strokeWidth, original_shape.fillColor, original_shape.fillAlpha, false);
                delete original_shapes_backup[backup_key];

                if (refresh_view) {
                    this.refresh_active_rois();
                }
            }
        }

        // Restore all shapes with a backup
        this.restore_shapes = function(refresh_view) {
            var refresh_view = typeof refresh_view !== "undefined" ? refresh_view : true;

            for (var bk_key in original_shapes_backup) {
                var sh_id = bk_key.split("::");
                this.restore_shape(sh_id[0], sh_id[1], false);
            }

            if (refresh_view) {
                this.refresh_active_rois();
            }
        }

        /*
        Update text for SHAPE with ID shape_id related to ROI with ID roi_id.
        Only input values that are not "undefined" will be updated, previuos value will be kept
        for all values passed as "undefined".
         */
        this.update_shape_text = function (roi_id, shape_id, text_value, font_family, font_size, font_style,
                                           refresh_view) {
            var refresh_view = typeof refresh_view !== "undefined" ? refresh_view : true;

            // look for shape in OME ROIs and external ones
            var sh = get_shape(roi_id, shape_id, roi_json);
            if (!sh)
                sh = get_shape(roi_id, shape_id, external_rois);

            if (sh) {
                backup_shape(roi_id, shape_id, sh);

                sh.textValue = typeof text_value !== "undefined" ? text_value : sh.textValue;
                sh.fontFamily = typeof font_family !== "undefined" ? font_family : sh.fontFamily;
                sh.fontSize = typeof font_size !== "undefined" ? font_size : sh.fontSize;
                sh.fontStyle = typeof font_style !== "undefined" ? font_style : sh.fontStyle;

                if(refresh_view) {
                    this.refresh_active_rois();
                }
            } else {
                console.error("Unable to find a shape for ROI ID " + roi_id + " and SHAPE ID " + shape_id);
            }
        }

        /*
        Update shape configuration for SHAPE with ID shape_id related to ROI with ID roi_id.
        Only input values that are not "undefined" will be updated, previuos value will be kept
        for all values passed as "undefined".
         */
        this.update_shape_config = function(roi_id, shape_id, stroke_color, stroke_alpha,
                                            stroke_width, fill_color, fill_alpha, refresh_view) {
            var refresh_view = typeof refresh_view !== "undefined" ? refresh_view : true;

            // look for shape in OME ROIs and external ones
            var sh = get_shape(roi_id, shape_id, roi_json);
            if (!sh)
                sh = get_shape(roi_id, shape_id, external_rois);

            if (sh) {
                backup_shape(roi_id, shape_id, sh);

                sh.strokeWidth = typeof stroke_width !== "undefined" ? stroke_width : sh.strokeWidth;
                sh.strokeAlpha = typeof stroke_alpha !== "undefined" ? stroke_alpha : sh.strokeAlpha;
                sh.strokeColor = typeof stroke_color !== "undefined" ? stroke_color : sh.strokeColor;
                sh.fillAlpha = typeof fill_alpha !== "undefined" ? fill_alpha : sh.fillAlpha;
                sh.fillColor = typeof fill_color !== "undefined" ? fill_color : sh.fillColor;

                if(refresh_view) {
                    this.refresh_active_rois();
                }
            } else {
                console.error("Unable to find a shape for ROI ID " + roi_id + " and SHAPE ID " + shape_id);
            }
        }

        this.show_labels = function(visible, filter) {
            roi_label_displayed = visible;
            this.refresh_rois(undefined, undefined, filter);
        }

        // sets the Zoom of the ROI paper (canvas)
        this.setRoiZoom = function(percent) {
            paper.scaleAll(percent/100);
        }

    });

}

;/**
*  plugin for displaying Scalebar over an image *
*/

$.fn.scalebar_display = function(options) {
    return this.each(function(){

        var viewerId = this.id;
        var $viewportimg = $(this);

        var tiles =  (options.tiles ? options.tiles : false);
        var pixSizeX =  (options.pixSizeX ? options.pixSizeX : 0);
        var imageWidth =  (options.imageWidth ? options.imageWidth : 0);

        var scalebar_displayed = false;   // flag to toggle visability.

        var scalebar_class = (options.scalebar_class ? options.scalebar_class : 'weblitz-viewport-scalebar');

        if (!tiles) {
            // add our ROI canvas as a sibling to the image plane. Parent is the 'draggable' div
            var $dragdiv = $viewportimg.parent().parent();
            var scalebar_name = (options.scalebar_name ? options.scalebar_name : viewerId + '-scalebar');
            var $scalebar =   $('<div id="'+scalebar_name+'" class="'+scalebar_class+'">').appendTo($dragdiv);
        } else {
            var scalebar_name = (options.scalebar_name ? options.scalebar_name : viewerId + '-tiles-scalebar');
            var $scalebar = $('#'+viewerId + '-tiles-scalebar')
        }
        
        // loads the Scalebar if needed and displays them
        this.show_scalebar = function(theZ, theT) {
            scalebar_displayed = true;
            $scalebar.show()
        }

        // hides the Scalebar from display
        this.hide_scalebar = function() {
            scalebar_displayed = false;
            $scalebar.hide()
        }

        this.setScalebarZoom = function(zoom) {
            var width = 100;

            function round(x) {
                if (x > 10) {
                    var num = Math.floor(x);
                    var factor = Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
                    var unit = factor * Math.ceil(num/factor);
                    return unit;
                } else {

                    function power(n) {
                        p = 1;
                        while(n < 10) {
                            n = n*1000;
                            p++;
                        }
                        return p;
                    }
                    p = Math.pow(1000, power(x))

                    var num = Math.floor(x* p);
                    var factor = Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
                    var unit = factor * Math.ceil(num/factor) / p;
                    return unit;

                }
            }

            unit = round(width * pixSizeX / zoom);
            scalebar_width = Math.round(unit/pixSizeX * zoom)
            $scalebar.width(scalebar_width);
            $scalebar.html((unit).lengthformat(0));

        }

    });

}
;/**
 * (somewhat) Smart(er) Dialog plugin for JQuery.
 *
 * Todo: better documentation and example usage.
 *
 * Depends on jquery
 *
 * Author: C. Neves <carlos@glencoesoftware.com>
 *
 * Copyright (c) 2008 Glencoe Software, Inc. All rights reserved.
 * 
 * This software is distributed under the terms described by the LICENCE file
 * you can find at the root of the distribution bundle, which states you are
 * free to use it only for non commercial purposes.
 * If the file is missing please request a copy by contacting
 * jason@glencoesoftware.com.
 *
 */

$.fn.sdialog = function(cfg) {
  return this.each(function(){
    /* The basic setup */
    var self = jQuery(this);

    var dragbar = self.find('h1:first');
    var other = dragbar.siblings();
    other.remove();
    dragbar.after('<div class="sdialog-content">');
    var content = self.find('.sdialog-content').append(other);
    self
      //.append('<div class="sdialog-resize-bar">')
      .addClass('sdialog');

    this.recalcSize = function (xtra_height) {
      var internsize = dragbar.height()+(xtra_height || 0);// + self.find('.sdialog-resize-bar').height();
      var contentsize=self.height()-internsize;
      if (contentsize < 0) {
        self.css('height', internsize);
        contentsize = 0;
      }
      content.css('height', contentsize);
    };

    this.placeAround = function (elm, xoffset, yoffset) {
      var epos = $(elm).offset();
      var left = epos.left;
      var size = {w: self.width(), h: self.height()};
      var wsize = {w: $(window).width(), h: $(window).height()};
      if (wsize.w < size.w) {
        size.w = wsize.w;
        self.css('width', size.w);
      }
      left -= (size.w/2) - ($(elm).width() / 2);
      if (left + size.w > wsize.w) {
        left = wsize.w - size.w - 10;
      }
      
      if (xoffset) {
        left -= xoffset;
      }
      if (yoffset) {
        size.h -= yoffset;
      }
      self.css({top: epos.top - size.h, left: left});
      this.recalcSize();
    }

    var _showdelay = null;
    var _hidedelay = null;
    this.delayedShow = function (delay, func) {
      if (_hidedelay != null) {
        clearTimeout(_hidedelay);
        _hidedelay = null;
      } else if (_showdelay == null) {
        _showdelay = setTimeout(function () {
            func && func(self.get(0)) || self.show();
            _showdelay = null;
          }, delay);
        return true;
      }
      return false;
    }

    this.delayedHide = function (delay, func) {
      if (_showdelay != null) {
        clearTimeout(_showdelay);
        _showdelay = null;
      } else if (_hidedelay == null) {
        _hidedelay = setTimeout(function () {
            func && func(self.get(0)) || self.hide();
            _hidedelay = null;
          }, delay);
        return true;
      }
      return false;
    }

  });
}


;// get a shape configuration described as a dictionary compatible with OMERO.web viewer
$.fn.get_shape_config = function(stroke_width, stroke_alpha, stroke_color, fill_alpha, fill_color) {
    // default configuration for shape config
    var stroke_width = typeof stroke_width !== "undefined" ? stroke_width : 1.0;
    var stroke_alpha = typeof stroke_alpha !== "undefined" ? stroke_alpha : 0.765625;
    var stroke_color = typeof stroke_color !== "undefined" ? stroke_color : "#c4c4c4";
    var fill_alpha = typeof fill_alpha !== "undefined" ? fill_alpha : 0.25;
    var fill_color = typeof fill_color !== "undefined" ? fill_color : "#000000";

    return {
        "strokeWidth": stroke_width,
        "strokeAlpha": stroke_alpha,
        "strokeColor": stroke_color,
        "fillAlpha": fill_alpha,
        "fillColor": fill_color
    };
}

// generic shape configuration: Z, T, transform and shape type
$.fn.get_generic_shape = function(transform, z_plane, t_plane, shape_type) {
    return {
        "transform": typeof transform !== "undefined" ? transform : "none",
        "theZ": z_plane,
        "theT": t_plane,
        "type": shape_type
    };
}

// utility function to get default font size based on image's width and height
$.fn.get_font_size = function(img_width, img_height) {
    var max_font_size = 512;
    var default_font_size = 12

    if (img_width && img_height) {
        if (img_width <= max_font_size && img_height <= max_font_size)
            return default_font_size;
        var rx = default_font_size*(img_width/max_font_size);
        var ry = default_font_size*(img_height/max_font_size);

        return Math.floor(Math.max(rx, ry));
    } else {
        return default_font_size;
    }
}

// generic text configuration: text value, font family, font size and style
$.fn.get_text_config = function(text_value, font_family, font_size, font_style) {
    // default font family and font_style
    var ffamily = typeof font_family !== "undefined" ? font_family : "sans-serif";
    var fstyle = typeof font_style !== "undefined" ? font_style : "Normal";
    var fsize = typeof font_size !== "undefined" ? font_size : $.fn.get_font_size();
    return {
        "fontFamily": ffamily,
        "fontStyle": fstyle,
        "fontSize": fsize,
        "textValue": text_value
    };
}

// add a dictionary with a text definition to given shape
$.fn.add_text_to_shape = function(shape_conf, text_conf) {
    $.extend(shape_conf, text_conf);
    return shape_conf;
}

// get a rectangle configuration described as a dictionary compatible with OMERO.web viewer
$.fn.get_ome_rectangle = function(x, y, height, width, z_plane, t_plane, transform, shape_config) {
    // if no shape_config was given, use the default one
    var shape_config = typeof shape_config !== "undefined" ? shape_config : $.fn.get_shape_config();

    var rect_conf = {
        "x": x,
        "y": y,
        "height": height,
        "width": width
    };

    $.extend(rect_conf, $.fn.get_generic_shape(transform, z_plane, t_plane, "Rectangle"));
    $.extend(rect_conf, shape_config);

    return rect_conf;
}

// get a point configuration described as a dictionary compatible with OMERO.web viewer
$.fn.get_ome_point = function(center_x, center_y, z_plane, t_plane, transform, shape_config) {
    // if no shape_config was given, use the default one
    var shape_config = typeof shape_config !== "undefined" ? shape_config : $.fn.get_shape_config();

    var point_conf = {
        "x": center_x,
        "y": center_y
    };

    $.extend(point_conf, $.fn.get_generic_shape(transform, z_plane, t_plane, "Point"));
    $.extend(point_conf, shape_config);

    return point_conf;
}

// get an ellipse configuration described as a dictionary compatible with OMERO.web viewer
$.fn.get_ome_ellipse = function(center_x, center_y, radius_x, radius_y, z_plane, t_plane,
                         transform, shape_config) {
    // if no shape_config was given, use the default one
    var shape_config = typeof shape_config !== "undefined" ? shape_config : $.fn.get_shape_config();

    var ellipse_conf = {
        "radiusX": radius_x,
        "radiusY": radius_y
    };

    $.extend(ellipse_conf, $.fn.get_ome_point(center_x, center_y, z_plane, t_plane,
        transform, shape_config));
    ellipse_conf.type = "Ellipse";

    return ellipse_conf;
}

// get a line configuration described as a dictionary compatible with OMERO.web viewer
$.fn.get_ome_line = function(x1, y1, x2, y2, z_plane, t_plane, transform, shape_config) {
    // if no shape_config was given, use the default one
    var shape_config = typeof shape_config !== "undefined" ? shape_config : $.fn.get_shape_config();

    var line_conf = {
        "x1": x1,
        "y1": y1,
        "x2": x2,
        "y2": y2
    };

    $.extend(line_conf, $.fn.get_generic_shape(transform, z_plane, t_plane, "Line"));
    $.extend(line_conf, shape_config);

    return line_conf;
}

// get a label configuration described as a dictionary compatible with OMERO.web viewer
$.fn.get_ome_label = function(x, y, text_value, z_plane, t_plane, transform,
                              font_family, font_size, font_style, shape_config) {
    // if no shape_config was given, use the default one
    var shape_config = typeof shape_config !== "undefined" ? shape_config : $.fn.get_shape_config();

    var text_conf = $.fn.get_text_config(text_value, font_family, font_size, font_style);

    var label_conf = {
        "x": x,
        "y": y
    };

    $.extend(label_conf, $.fn.get_generic_shape(transform, z_plane, t_plane, "Label"));
    $.extend(label_conf, shape_config);
    label_conf = $.fn.add_text_to_shape(label_conf, text_conf);

    return label_conf;
}

// get a polygon configuration described as a dictionary compatible with OMERO.web viewer
$.fn.get_ome_polygon = function(points, z_plane, t_plane, transform, shape_config) {
    // if no shape_config was given, use the default one
    var shape_config = typeof shape_config !== "undefined" ? shape_config : $.fn.get_shape_config();

    var polygon_conf = {
        "point": points
    };

    $.extend(polygon_conf, $.fn.get_generic_shape(transform, z_plane, t_plane, "Polygon"));
    $.extend(polygon_conf, shape_config);

    return polygon_conf;
}
;/* SpinButton control
 *
 * Adds bells and whistles to any ordinary textbox to
 * make it look and feel like a SpinButton Control.
 *
 * Originally written by George Adamson, Software Unity (george.jquery@softwareunity.com) August 2006.
 * - Added min/max options
 * - Added step size option
 * - Added bigStep (page up/down) option
 *
 * Modifications made by Mark Gibson, (mgibson@designlinks.net) September 2006:
 * - Converted to jQuery plugin
 * - Allow limited or unlimited min/max values
 * - Allow custom class names, and add class to input element
 * - Removed global vars
 * - Reset (to original or through config) when invalid value entered
 * - Repeat whilst holding mouse button down (with initial pause, like keyboard repeat)
 * - Support mouse wheel in Firefox
 * - Fix double click in IE
 * - Refactored some code and renamed some vars
 *
 * Tested in IE6, Opera9, Firefox 1.5
 * v1.0  11 Aug 2006 - George Adamson	- First release
 * v1.1     Aug 2006 - George Adamson	- Minor enhancements
 * v1.2  27 Sep 2006 - Mark Gibson		- Major enhancements
 * v1.3a 28 Sep 2006 - George Adamson	- Minor enhancements
 
 Sample usage:
 
	// Create group of settings to initialise spinbutton(s). (Optional)
	var myOptions = {
					min: 0,						// Set lower limit.
					max: 100,					// Set upper limit.
					step: 1,					// Set increment size.
					spinClass: mySpinBtnClass,	// CSS class to style the spinbutton. (Class also specifies url of the up/down button image.)
					upClass: mySpinUpClass,		// CSS class for style when mouse over up button.
					downClass: mySpinDnClass	// CSS class for style when mouse over down button.
					}
 
	$(document).ready(function(){

		// Initialise INPUT element(s) as SpinButtons: (passing options if desired)
		$("#myInputElement").SpinButton(myOptions);

	});
 
 */
$.fn.SpinButton = function(cfg){
	return this.each(function(){

		// Apply specified options or defaults:
		// (Ought to refactor this some day to use $.extend() instead)
		this.spinCfg = {
			//min: cfg && cfg.min ? Number(cfg.min) : null,
			//max: cfg && cfg.max ? Number(cfg.max) : null,
			min: cfg && !isNaN(parseFloat(cfg.min)) ? Number(cfg.min) : null,	// Fixes bug with min:0
			max: cfg && !isNaN(parseFloat(cfg.max)) ? Number(cfg.max) : null,
			step: cfg && cfg.step ? Number(cfg.step) : 1,
			page: cfg && cfg.page ? Number(cfg.page) : 10,
			upClass: cfg && cfg.upClass ? cfg.upClass : 'up',
			downClass: cfg && cfg.downClass ? cfg.downClass : 'down',
			reset: cfg && cfg.reset ? cfg.reset : this.value,
			delay: cfg && cfg.delay ? Number(cfg.delay) : 500,
			interval: cfg && cfg.interval ? Number(cfg.interval) : 100,
			_btn_width: 20,
			_btn_height: 12,
			_direction: null,
			_delay: null,
			_repeat: null
		};
		
		this.adjustValue = function(i){
			var v = (isNaN(this.value) ? this.spinCfg.reset : Number(this.value)) + Number(i);
			if (this.spinCfg.min !== null) v = Math.max(v, this.spinCfg.min);
			if (this.spinCfg.max !== null) v = Math.min(v, this.spinCfg.max);
			this.value = v;
            jQuery(this).trigger('change');
		};
		
		$(this)
		.addClass(cfg && cfg.spinClass ? cfg.spinClass : 'spin-button')
		
		.mousemove(function(e){
			// Determine which button mouse is over, or not (spin direction):
			var x = e.pageX || e.x;
			var y = e.pageY || e.y;
			var el = e.target || e.srcElement;
			var direction = 
				(x > coord(el,'offsetLeft') + el.offsetWidth - this.spinCfg._btn_width)
				? ((y < coord(el,'offsetTop') + this.spinCfg._btn_height) ? 1 : -1) : 0;
			
			if (direction !== this.spinCfg._direction) {
				// Style up/down buttons:
				switch(direction){
					case 1: // Up arrow:
						$(this).removeClass(this.spinCfg.downClass).addClass(this.spinCfg.upClass);
						break;
					case -1: // Down arrow:
						$(this).removeClass(this.spinCfg.upClass).addClass(this.spinCfg.downClass);
						break;
					default: // Mouse is elsewhere in the textbox
						$(this).removeClass(this.spinCfg.upClass).removeClass(this.spinCfg.downClass);
				}
				
				// Set spin direction:
				this.spinCfg._direction = direction;
			}
		})
		
		.on('mouseout', function(){
			// Reset up/down buttons to their normal appearance when mouse moves away:
			$(this).removeClass(this.spinCfg.upClass).removeClass(this.spinCfg.downClass);
			this.spinCfg._direction = null;
		})
		
		.on('mousedown', function(e){
			if (this.spinCfg._direction != 0) {
				// Respond to click on one of the buttons:
				var self = this;
				var adjust = function() {
					self.adjustValue(self.spinCfg._direction * self.spinCfg.step);
				};
			
				adjust();
				
				// Initial delay before repeating adjustment
				self.spinCfg._delay = window.setTimeout(function() {
					adjust();
					// Repeat adjust at regular intervals
					self.spinCfg._repeat = window.setInterval(adjust, self.spinCfg.interval);
				}, self.spinCfg.delay);
			}
		})
		
		.on('mouseup', function(e){
			// Cancel repeating adjustment
			window.clearInterval(this.spinCfg._repeat);
			window.clearTimeout(this.spinCfg._delay);
		})
		
		.on('dblclick', function(e) {
			if ($.browser.msie)
				this.adjustValue(this.spinCfg._direction * this.spinCfg.step);
		})
		
		.keydown(function(e){
			// Respond to up/down arrow keys.
			switch(e.keyCode){
				case 38: this.adjustValue(this.spinCfg.step);  break; // Up
				case 40: this.adjustValue(-this.spinCfg.step); break; // Down
				case 33: this.adjustValue(this.spinCfg.page);  break; // PageUp
				case 34: this.adjustValue(-this.spinCfg.page); break; // PageDown
				case 13: jQuery(this).trigger('change'); break; // Enter
			}
		})

		.bind("mousewheel", function(e){
			// Respond to mouse wheel in IE. (It returns up/dn motion in multiples of 120)
			if (e.wheelDelta >= 120)
				this.adjustValue(this.spinCfg.step);
			else if (e.wheelDelta <= -120)
				this.adjustValue(-this.spinCfg.step);
			
			e.preventDefault();
		})

		if (this.addEventListener) {
			// Respond to mouse wheel in Firefox
			this.addEventListener('DOMMouseScroll', function(e) {
				if (e.detail > 0)
					this.adjustValue(-this.spinCfg.step);
				else if (e.detail < 0)
					this.adjustValue(this.spinCfg.step);
				
				e.preventDefault();
			}, false);
		}
	});
	
	function coord(el,prop) {
      if (prop.indexOf('offset')==0) {
        return jQuery(el).offset()[prop.substr(6).toLowerCase()];
      }
		var c = el[prop], b = document.body;
		
		while ((el = el.offsetParent) && (el != b)) {
			if (!$.browser.msie || (el.currentStyle.position != 'relative'))
				c += el[prop];
		}
		
		return c;
	}
};

;/**
 * Colored button triggering a color picker plugin for JQuery.
 *
 * Todo: better documentation and example usage.
 *
 * Depends on jquery, farbtastic, jquery-plugin-postit
 *
 * Author: C. Neves <carlos@glencoesoftware.com>
 *
 * Copyright (c) 2007, 2008 Glencoe Software, Inc. All rights reserved.
 * 
 * This software is distributed under the terms described by the LICENCE file
 * you can find at the root of the distribution bundle, which states you are
 * free to use it only for non commercial purposes.
 * If the file is missing please request a copy by contacting
 * jason@glencoesoftware.com.
 *
 */

$.fn.colorbtn = function(cfg) {
  return this.each(function(){
    this.cfg = {
      prefix: cfg && cfg.prefix ? cfg.prefix : "cbpicker"
    };
    var that = this;

    var colors = ["FF0000", "00FF00", "0000FF", "FFFFFF", "FFFF00", "EE00EE", "00FFFF"];
    var colorNames = ["red", "green", "blue", "white", "yellow", "magenta", "cyan"];
    var picker = null;

    /* The basic setup */
    var self = jQuery(this);

    var callback = function (color) {
      self.attr('data-picked-color', color);
      jQuery('input#'+self[0].cfg.prefix+'-tb').val(color.substring(1).toUpperCase());
    };

    var ok_callback = function () {
      // On 'OK' we get the color saved by 'callback' above and apply it to the color-btn, then trigger
      var data_color = self.attr('data-picked-color');
      var reverse_intensity = self.data('data-reverse-intensity');
      // data_color could be 'FF0000' or 'cool.lut'
      if (data_color) {
        self.attr('data-color', data_color);
        self.trigger('changed');
      } else if (reverse_intensity !== undefined) {
        self.data('data-reverse-intensity', reverse_intensity);
        self.trigger('changed');
      }
    };

    var null_cb = function (color) {};

    this._prepare_picker = function () {
      jQuery("body").prepend('<div class="'+this.cfg.prefix+'" id="'+this.cfg.prefix+'-box"></div>');
      var box = jQuery("#"+this.cfg.prefix+"-box").append('<h1>Choose color</h1>');
      box.postit();

      var invertHtml = '<div><input id="invert" type="checkbox" style="width:20px"></input>';
          invertHtml += '<label for="invert" style="font-size:15px; font-weight: normal;">Invert</label></div>';
          invertHtml += '<div style="clear:both"></div>';
      $(invertHtml).appendTo(box);

      // Add Lookup Table list - gets populated in show_picker() below.
      var $luts = $('<div id="' + this.cfg.prefix + '-luts" class="lutpicker"></div>').appendTo(box);

      // Colorpicker - uses farbtastic.js
      var $showColorPicker = $("<h1 style='font-size:1.5em' class='showColorPicker'><a href='#'>Show Color Picker</a></h1>").appendTo(box);
      var $cpickerPane = $("<div class='cpickerPane'></div>").appendTo(box);
      $('<div id="'+this.cfg.prefix+'"></div>').appendTo($cpickerPane);
      $cpickerPane.append('<div style="text-align: center;">Hex RGB <input type="text" id="'+this.cfg.prefix+'-tb" /></div>');
      $('<button id="cbpicker-OK-btn" style="float:right">OK</button>').appendTo($cpickerPane);
      $('<button style="float:right">Cancel</button>').appendTo($cpickerPane).on('click', function(){
        jQuery("#"+that.cfg.prefix+"-box").hide();
      });
      $('a', $showColorPicker).on('click', function(event){
        event.preventDefault();
        $cpickerPane.toggle();
        $luts.toggle();
        if ($cpickerPane.is(':visible')) {
          $(this).html('Hide Color Picker');
        } else {
          $(this).html('Show Color Picker');
        }
      });
      // Don't show Color-picker initially
      $cpickerPane.hide();

      self.trigger('prepared');
      picker = jQuery.farbtastic("#"+this.cfg.prefix);
      jQuery('input#'+this.cfg.prefix+'-tb').on('change', function () {
          var new_color = sanitizeHexColor(jQuery('input#'+self[0].cfg.prefix+'-tb').val());
          if (new_color !== null) {
            picker.setColor(new_color);
            jQuery(this).val(new_color.substring(1).toUpperCase());
          } else {
            jQuery(this).val(picker.pack(picker.rgb).substring(1).toUpperCase());
          }
        });
    };

    function getLutIndex(lutName) {
      if (OME && OME.LUTS) {
        for (var l=0; l<OME.LUTS.length; l++) {
          if (OME.LUTS[l].name === lutName) {
            return OME.LUTS[l].png_index;
          }
        }
      }
      return -1;
    }

    function getLutPngHeight() {
      // png contains list of LUTS, 10 pixels high
      return (OME.PNG_LUTS.length) * 10;
    }

    this.show_picker = function () {
      // 'data-reverse-intensity' is a string in template, not boolean.
      var reverse_intensity = self.data('data-reverse-intensity');
      if (!picker) {
        if (jQuery('#'+this.cfg.prefix+'-box').length === 0) {
          this._prepare_picker();
        } else {
          picker = jQuery.farbtastic("#"+this.cfg.prefix);
        }
      }
      var currColor = self.attr('data-color');

      // lookup LUTs & build list with other colors
      var $luts = $("#" + this.cfg.prefix + "-luts");
      if ($luts.is(':empty')) {
          var colorRows = [];
          for (var e=0; e<colors.length; e++) {
            var c = colors[e],
              n = colorNames[e];
            colorRows.push('<div><input id="' + c + '" type="radio" name="lut" value="' + c + '"><label for="' + c + '"><span style="background: #' + c + '"> &nbsp</span>' + n + '</label></div>');
          }
          var lutRows = OME.LUTS.map(function(lut){
            var idx = getLutIndex(lut.name);
            var png_height = getLutPngHeight();
            var preview = '';
            // background image is luts_10.png which is 10 pixels per lut(row) but size is set to 300% so each row is 30 pixels
            if (idx > -1) {
              preview = 'class="lutBackground" style="background-position: 0 -' + (idx * 30 + 7) + 'px;';
              preview += ' background-size: 100% ' + (png_height * 3) + 'px"';
            }
            var lutHtml = '<div><input id="' + lut.name + '" type="radio" name="lut" value="' + lut.name + '">';
            lutHtml += '<label for="' + lut.name + '">';
            lutHtml += '<span ' + preview + '> &nbsp</span>';
            lutHtml += (lut.name.replace('.lut', '')) + '</label></div>';
            return lutHtml;
          });
          var html = '<div>' + colorRows.join("") + lutRows.join("") + '</div>';
          $luts.html(html);
          $("label[for='" + currColor + "']").css('background', '#cddcfc');
      }

      // reset showing of LUTs and hiding of colorpicker
      $('.cpickerPane').hide();
      $luts.show();
      $('.showColorPicker a').html('Show Color Picker');
      $('#invert').prop('checked', reverse_intensity);
      // Highlight current color/lut
      $("label", $luts).css('background', 'none');
      $("label[for='" + currColor + "']", $luts).css('background', '#cddcfc')

      // unbind and re-bind appropriate handler (wraps ref to button)
      $("#cbpicker-OK-btn").off('click').on('click', ok_callback)
        .on('click',function(){
          jQuery("#"+that.cfg.prefix+"-box").hide();
        });
      $('#' + this.cfg.prefix + '-luts').off("click").on( "click", "input", function() {
        self.attr('data-picked-color', this.value);
        ok_callback();
      });
      $("#invert").off('click').on('click', function(){
        self.data('data-reverse-intensity', this.checked);
        ok_callback();
      });
      self.removeAttr('data-picked-color');

      var oldColor = self.attr("data-color"),
        color = '#' + OME.rgbToHex(oldColor);
      if (oldColor.endsWith('.lut')){
        color = '#FF0000';
      }
      picker.linkTo(null_cb).setColor(color).linkTo(callback);
      jQuery("#"+this.cfg.prefix+"-tb").val(color.substring(1).toUpperCase());
      jQuery("#"+this.cfg.prefix+"-defc").css("background-color", self.css("background-color"));
      jQuery("#" + this.cfg.prefix + "-box").on('mousedown', function () {self.trigger('mousedown');}).show();
      jQuery("#"+this.cfg.prefix+"-box").off('closed').on('closed', function () {self.trigger('hiding');});
      self.trigger('showing');
      //self.addClass('picking');
    };

    this.hide_picker = function () {
      jQuery("#"+this.cfg.prefix+"-box").hide();
      //self.removeClass('picking');
    };

    /* Event handlers */
    self.on('click', this.show_picker);
  });
};

;/**
 * Post-it plugin for JQuery.
 *
 * Called on a container, creates a post-it like thingy
 *
 * Todo: better documentation and example usage.
 *
 * Depends on jquery, jquery-ui, aop, jquery-plugin-smartdialog.js
 *
 * Author: C. Neves <carlos@glencoesoftware.com>
 *
 * Copyright (c) 2007, 2008 Glencoe Software, Inc. All rights reserved.
 * 
 * This software is distributed under the terms described by the LICENCE file
 * you can find at the root of the distribution bundle, which states you are
 * free to use it only for non commercial purposes.
 * If the file is missing please request a copy by contacting
 * jason@glencoesoftware.com.
 *
 */

var aop_handler = function (meth) {
  return function () {
    if (this.get(0) && typeof this.get(0)[meth] == 'function') {
        return this.get(0)[meth]();
    }
      return this;
  };
};

jQuery.aop.before( {target: jQuery, method: 'show'}, aop_handler('postit_open_handler'));
jQuery.aop.after( {target: jQuery.fn, method: 'hide'}, aop_handler('postit_close_handler'));

$.fn.postit = function(cfg) {
  this.sdialog();
  return this.each(function(){
    /* The basic setup */
    var self = jQuery(this);
    this.postit_open_handler = function () {
      self.trigger('opening');
        return this;
    };
    this.postit_close_handler = function () {
      self.trigger('closed');
        return this;
    };
    /* Some extra details on the dragbar */
    var dragbar = self.find('h1:first');
    dragbar.on('dblclick', function(e) { self.toggleClass('collapsed'); });

    if (dragbar.get(0).addEventListener) {
      // Respond to mouse wheel in Firefox
      dragbar.get(0).addEventListener('DOMMouseScroll', function(e) { 
      if (e.detail > 0)
        self.removeClass('collapsed');
      else if (e.detail < 0)
        self.addClass('collapsed');
      e.preventDefault();
      }, false);
    }

    self
      .append('<div class="postit-toggle-btn">')
      .append('<div class="postit-close-btn">')
      .append('<div class="postit-resize-bar">')
      .addClass('postit')
      .removeClass('sdialog');
    /* The buttons */
    self.find('.postit-toggle-btn').on('click', function(e) { self.toggleClass('collapsed'); });
    self.find('.postit-close-btn').on('click', function(e) { self.hide(); });
    self.find('.sdialog-content').removeClass('sdialog-content').addClass('postit-content');
    if (cfg && !cfg.noResize) {
      var target;
      if (cfg && cfg.resizeTarget) {
        target = $(cfg.resizeTarget, self);
          target.resizable({minHeight: 200, minWidth: 200, containment: 'document'});
      } else {
        target = self;
          target.resizable({minHeight: 40, minWidth: 40});
      }
    }

    /* We're done, make it draggable */
    var dropEvent = function (e) {
      var viewport = {width: $('body').width(), height: $('body').height()};
      var boundaries = self.position();
      boundaries.right = boundaries.left + self.width();
      boundaries.bottom = boundaries.top + self.height();
      if (boundaries.left < 0) {
        self.css('left', 0);
      } else if (boundaries.right > viewport.width) {
        self.css('left', viewport.width - self.width());
      }
      if (boundaries.top < 0) {
        self.css('top', 0);
      } else if (boundaries.bottom > viewport.height) {
        var top = Math.max(viewport.height - self.height(), 0);
        self.css('top', top);
      }
    };
      self.draggable({handle: 'h1:first', scroll: false, containment: 'document'});
    self.find('h1:first').on('mouseup', dropEvent)
  });
}

;/*
 *
 * Copyright (c) 2006-2010 Sam Collett (http://www.texotela.co.uk)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * Version 2.2.6
 * Demo: http://www.texotela.co.uk/code/jquery/select/
 *
 *
 */
 
;(function($) {
 
/**
 * Adds (single/multiple) options to a select box (or series of select boxes)
 *
 * @name     addOption
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @type     jQuery
 * @example  $("#myselect").addOption("Value", "Text"); // add single value (will be selected)
 * @example  $("#myselect").addOption("Value 2", "Text 2", false); // add single value (won't be selected)
 * @example  $("#myselect").addOption({"foo":"bar","bar":"baz"}, false); // add multiple values, but don't select
 *
 */
$.fn.addOption = function()
{
	var add = function(el, v, t, sO, index)
	{
		var option = document.createElement("option");
		option.value = v, option.text = t;
		// get options
		var o = el.options;
		// get number of options
		var oL = o.length;
		if(!el.cache)
		{
			el.cache = {};
			// loop through existing options, adding to cache
			for(var i = 0; i < oL; i++)
			{
				el.cache[o[i].value] = i;
			}
		}
		if (index || index == 0)
		{
 			// we're going to insert these starting  at a specific index...
			// this has the side effect of el.cache[v] being the 
			// correct value for the typeof check below
			var ti = option;
			for(var ii =index; ii <= oL; ii++)
			{
				var tmp = el.options[ii];
				el.options[ii] = ti;
				o[ii] = ti;
				el.cache[o[ii].value] = ii;
				ti = tmp;
			}
		}
    
		// add to cache if it isn't already
		if(typeof el.cache[v] == "undefined") el.cache[v] = oL;
		el.options[el.cache[v]] = option;
		if(sO)
		{
			option.selected = true;
		}
	};
	
	var a = arguments;
	if(a.length == 0) return this;
	// select option when added? default is true
	var sO = true;
	// multiple items
	var m = false;
	// other variables
	var items, v, t, startindex = 0;
	if(typeof(a[0]) == "object")
	{
		m = true;
		items = a[0];
	}
	if(a.length >= 2)
	{
		if(typeof(a[1]) == "boolean")
		{
			sO = a[1];
			startindex = a[2];
		}
		else if(typeof(a[2]) == "boolean")
		{
			sO = a[2];
			startindex = a[1];
		}
		else
		{
			startindex = a[1];
		}
		if(!m)
		{
			v = a[0];
			t = a[1];
		}
	}
	this.each(
		function()
		{
			if(this.nodeName.toLowerCase() != "select") return;
			if(m)
			{
				for(var item in items)
				{
					add(this, item, items[item], sO, startindex);
					startindex += 1;
				}
			}
			else
			{
				add(this, v, t, sO, startindex);
			}
		}
	);
	return this;
};

/**
 * Add options via ajax
 *
 * @name     ajaxAddOption
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @type     jQuery
 * @param    String url      Page to get options from (must be valid JSON)
 * @param    Object params   (optional) Any parameters to send with the request
 * @param    Boolean select  (optional) Select the added options, default true
 * @param    Function fn     (optional) Call this function with the select object as param after completion
 * @param    Array args      (optional) Array with params to pass to the function afterwards
 * @example  $("#myselect").ajaxAddOption("myoptions.php");
 * @example  $("#myselect").ajaxAddOption("myoptions.php", {"code" : "007"});
 * @example  $("#myselect").ajaxAddOption("myoptions.php", {"code" : "007"}, false, sortoptions, [{"dir": "desc"}]);
 *
 */
$.fn.ajaxAddOption = function(url, params, select, fn, args)
{
	if(typeof(url) != "string") return this;
	if(typeof(params) != "object") params = {};
	if(typeof(select) != "boolean") select = true;
	this.each(
		function()
		{
			var el = this;
			$.getJSON(url,
				params,
				function(r)
				{
					$(el).addOption(r, select);
					if(typeof fn == "function")
					{
						if(typeof args == "object")
						{
							fn.apply(el, args);
						} 
						else
						{
							fn.call(el);
						}
					}
				}
			);
		}
	);
	return this;
};

/**
 * Removes an option (by value or index) from a select box (or series of select boxes)
 *
 * @name     removeOption
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @type     jQuery
 * @param    String|RegExp|Number what  Option to remove
 * @param    Boolean selectedOnly       (optional) Remove only if it has been selected (default false)   
 * @example  $("#myselect").removeOption("Value"); // remove by value
 * @example  $("#myselect").removeOption(/^val/i); // remove options with a value starting with 'val'
 * @example  $("#myselect").removeOption(/./); // remove all options
 * @example  $("#myselect").removeOption(/./, true); // remove all options that have been selected
 * @example  $("#myselect").removeOption(0); // remove by index
 * @example  $("#myselect").removeOption(["myselect_1","myselect_2"]); // values contained in passed array
 *
 */
$.fn.removeOption = function()
{
	var a = arguments;
	if(a.length == 0) return this;
	var ta = typeof(a[0]);
	var v, index;
	// has to be a string or regular expression (object in IE, function in Firefox)
	if(ta == "string" || ta == "object" || ta == "function" )
	{
		v = a[0];
		// if an array, remove items
		if(v.constructor == Array)
		{
			var l = v.length;
			for(var i = 0; i<l; i++)
			{
				this.removeOption(v[i], a[1]); 
			}
			return this;
		}
	}
	else if(ta == "number") index = a[0];
	else return this;
	this.each(
		function()
		{
			if(this.nodeName.toLowerCase() != "select") return;
			// clear cache
			if(this.cache) this.cache = null;
			// does the option need to be removed?
			var remove = false;
			// get options
			var o = this.options;
			if(!!v)
			{
				// get number of options
				var oL = o.length;
				for(var i=oL-1; i>=0; i--)
				{
					if(v.constructor == RegExp)
					{
						if(o[i].value.match(v))
						{
							remove = true;
						}
					}
					else if(o[i].value == v)
					{
						remove = true;
					}
					// if the option is only to be removed if selected
					if(remove && a[1] === true) remove = o[i].selected;
					if(remove)
					{
						o[i] = null;
					}
					remove = false;
				}
			}
			else
			{
				// only remove if selected?
				if(a[1] === true)
				{
					remove = o[index].selected;
				}
				else
				{
					remove = true;
				}
				if(remove)
				{
					this.remove(index);
				}
			}
		}
	);
	return this;
};

/**
 * Sort options (ascending or descending) in a select box (or series of select boxes)
 *
 * @name     sortOptions
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @type     jQuery
 * @param    Boolean ascending   (optional) Sort ascending (true/undefined), or descending (false)
 * @example  // ascending
 * $("#myselect").sortOptions(); // or $("#myselect").sortOptions(true);
 * @example  // descending
 * $("#myselect").sortOptions(false);
 *
 */
$.fn.sortOptions = function(ascending)
{
	// get selected values first
	var sel = $(this).selectedValues();
	var a = typeof(ascending) == "undefined" ? true : !!ascending;
	this.each(
		function()
		{
			if(this.nodeName.toLowerCase() != "select") return;
			// get options
			var o = this.options;
			// get number of options
			var oL = o.length;
			// create an array for sorting
			var sA = [];
			// loop through options, adding to sort array
			for(var i = 0; i<oL; i++)
			{
				sA[i] = {
					v: o[i].value,
					t: o[i].text
				}
			}
			// sort items in array
			sA.sort(
				function(o1, o2)
				{
					// option text is made lowercase for case insensitive sorting
					o1t = o1.t.toLowerCase(), o2t = o2.t.toLowerCase();
					// if options are the same, no sorting is needed
					if(o1t == o2t) return 0;
					if(a)
					{
						return o1t < o2t ? -1 : 1;
					}
					else
					{
						return o1t > o2t ? -1 : 1;
					}
				}
			);
			// change the options to match the sort array
			for(var i = 0; i<oL; i++)
			{
				o[i].text = sA[i].t;
				o[i].value = sA[i].v;
			}
		}
	).selectOptions(sel, true); // select values, clearing existing ones
	return this;
};
/**
 * Selects an option by value
 *
 * @name     selectOptions
 * @author   Mathias Bank (http://www.mathias-bank.de), original function
 * @author   Sam Collett (http://www.texotela.co.uk), addition of regular expression matching
 * @type     jQuery
 * @param    String|RegExp|Array value  Which options should be selected
 * can be a string or regular expression, or an array of strings / regular expressions
 * @param    Boolean clear  Clear existing selected options, default false
 * @example  $("#myselect").selectOptions("val1"); // with the value 'val1'
 * @example  $("#myselect").selectOptions(["val1","val2","val3"]); // with the values 'val1' 'val2' 'val3'
 * @example  $("#myselect").selectOptions(/^val/i); // with the value starting with 'val', case insensitive
 *
 */
$.fn.selectOptions = function(value, clear)
{
	var v = value;
	var vT = typeof(value);
	// handle arrays
	if(vT == "object" && v.constructor == Array)
	{
		var $this = this;
		$.each(v, function()
			{
      				$this.selectOptions(this, clear);
    			}
		);
	};
	var c = clear || false;
	// has to be a string or regular expression (object in IE, function in Firefox)
	if(vT != "string" && vT != "function" && vT != "object") return this;
	this.each(
		function()
		{
			if(this.nodeName.toLowerCase() != "select") return this;
			// get options
			var o = this.options;
			// get number of options
			var oL = o.length;
			for(var i = 0; i<oL; i++)
			{
				if(v.constructor == RegExp)
				{
					if(o[i].value.match(v))
					{
						o[i].selected = true;
					}
					else if(c)
					{
						o[i].selected = false;
					}
				}
				else
				{
					if(o[i].value == v)
					{
						o[i].selected = true;
					}
					else if(c)
					{
						o[i].selected = false;
					}
				}
			}
		}
	);
	return this;
};

/**
 * Copy options to another select
 *
 * @name     copyOptions
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @type     jQuery
 * @param    String to  Element to copy to
 * @param    String which  (optional) Specifies which options should be copied - 'all' or 'selected'. Default is 'selected'
 * @example  $("#myselect").copyOptions("#myselect2"); // copy selected options from 'myselect' to 'myselect2'
 * @example  $("#myselect").copyOptions("#myselect2","selected"); // same as above
 * @example  $("#myselect").copyOptions("#myselect2","all"); // copy all options from 'myselect' to 'myselect2'
 *
 */
$.fn.copyOptions = function(to, which)
{
	var w = which || "selected";
	if($(to).size() == 0) return this;
	this.each(
		function()
		{
			if(this.nodeName.toLowerCase() != "select") return this;
			// get options
			var o = this.options;
			// get number of options
			var oL = o.length;
			for(var i = 0; i<oL; i++)
			{
				if(w == "all" || (w == "selected" && o[i].selected))
				{
					$(to).addOption(o[i].value, o[i].text);
				}
			}
		}
	);
	return this;
};

/**
 * Checks if a select box has an option with the supplied value
 *
 * @name     containsOption
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @type     Boolean|jQuery
 * @param    String|RegExp value  Which value to check for. Can be a string or regular expression
 * @param    Function fn          (optional) Function to apply if an option with the given value is found.
 * Use this if you don't want to break the chaining
 * @example  if($("#myselect").containsOption("val1")) alert("Has an option with the value 'val1'");
 * @example  if($("#myselect").containsOption(/^val/i)) alert("Has an option with the value starting with 'val'");
 * @example  $("#myselect").containsOption("val1", copyoption).doSomethingElseWithSelect(); // calls copyoption (user defined function) for any options found, chain is continued
 *
 */
$.fn.containsOption = function(value, fn)
{
	var found = false;
	var v = value;
	var vT = typeof(v);
	var fT = typeof(fn);
	// has to be a string or regular expression (object in IE, function in Firefox)
	if(vT != "string" && vT != "function" && vT != "object") return fT == "function" ? this: found;
	this.each(
		function()
		{
			if(this.nodeName.toLowerCase() != "select") return this;
			// option already found
			if(found && fT != "function") return false;
			// get options
			var o = this.options;
			// get number of options
			var oL = o.length;
			for(var i = 0; i<oL; i++)
			{
				if(v.constructor == RegExp)
				{
					if (o[i].value.match(v))
					{
						found = true;
						if(fT == "function") fn.call(o[i], i);
					}
				}
				else
				{
					if (o[i].value == v)
					{
						found = true;
						if(fT == "function") fn.call(o[i], i);
					}
				}
			}
		}
	);
	return fT == "function" ? this : found;
};

/**
 * Returns values which have been selected
 *
 * @name     selectedValues
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @type     Array
 * @example  $("#myselect").selectedValues();
 *
 */
$.fn.selectedValues = function()
{
	var v = [];
	this.selectedOptions().each(
		function()
		{
			v[v.length] = this.value;
		}
	);
	return v;
};

/**
 * Returns text which has been selected
 *
 * @name     selectedTexts
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @type     Array
 * @example  $("#myselect").selectedTexts();
 *
 */
$.fn.selectedTexts = function()
{
	var t = [];
	this.selectedOptions().each(
		function()
		{
			t[t.length] = this.text;
		}
	);
	return t;
};

/**
 * Returns options which have been selected
 *
 * @name     selectedOptions
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @type     jQuery
 * @example  $("#myselect").selectedOptions();
 *
 */
$.fn.selectedOptions = function()
{
	return this.find("option:selected");
};

})(jQuery);
;// $Id: farbtastic.js,v 1.2 2007/01/08 22:53:01 unconed Exp $
// Farbtastic 1.2

jQuery.fn.farbtastic = function (callback) {
  $.farbtastic(this, callback);
  return this;
};

jQuery.farbtastic = function (container, callback) {
  var container = $(container).get(0);
  return container.farbtastic || (container.farbtastic = new jQuery._farbtastic(container, callback));
}

jQuery._farbtastic = function (container, callback) {
  // Store farbtastic object
  var fb = this;

  // Insert markup
  $(container).html('<div class="farbtastic"><div class="color"></div><div class="wheel"></div><div class="overlay"></div><div class="h-marker marker"></div><div class="sl-marker marker"></div></div>');
  var e = $('.farbtastic', container);
  fb.wheel = $('.wheel', container).get(0);
  // Dimensions
  fb.radius = 84;
  fb.square = 100;
  fb.width = 194;

  // Fix background PNGs in IE6
  if (navigator.appVersion.match(/MSIE [0-6]\./)) {
    $('*', e).each(function () {
      if (this.currentStyle.backgroundImage != 'none') {
        var image = this.currentStyle.backgroundImage;
        image = this.currentStyle.backgroundImage.substring(5, image.length - 2);
        $(this).css({
          'backgroundImage': 'none',
          'filter': "progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=true, sizingMethod=crop, src='" + image + "')"
        });
      }
    });
  }

  /**
   * Link to the given element(s) or callback.
   */
  fb.linkTo = function (callback) {
    // Unbind previous nodes
    if (typeof fb.callback == 'object') {
      $(fb.callback).off('keyup', fb.updateValue);
    }

    // Reset color
    fb.color = null;

    // Bind callback or elements
    if (typeof callback == 'function') {
      fb.callback = callback;
    }
    else if (typeof callback == 'object' || typeof callback == 'string') {
      fb.callback = $(callback);
      fb.callback.on('keyup', fb.updateValue);
      if (fb.callback.get(0).value) {
        fb.setColor(fb.callback.get(0).value);
      }
    }
    return this;
  }
  fb.updateValue = function (event) {
    if (this.value && this.value != fb.color) {
      fb.setColor(this.value);
    }
  }

  /**
   * Change color with HTML syntax #123456
   */
  fb.setColor = function (color) {
    var unpack = fb.unpack(color);
    if (fb.color != color && unpack) {
      fb.color = color;
      fb.rgb = unpack;
      fb.hsl = fb.RGBToHSL(fb.rgb);
      fb.updateDisplay();
    }
    return this;
  }

  /**
   * Change color with HSL triplet [0..1, 0..1, 0..1]
   */
  fb.setHSL = function (hsl) {
    fb.hsl = hsl;
    fb.rgb = fb.HSLToRGB(hsl);
    fb.color = fb.pack(fb.rgb);
    fb.updateDisplay();
    return this;
  }

  /////////////////////////////////////////////////////

  /**
   * Retrieve the coordinates of the given event relative to the center
   * of the widget.
   */
  fb.widgetCoords = function (event) {
    var x, y;
    var el = event.target || event.srcElement;
    var reference = fb.wheel;

    if (typeof event.offsetX != 'undefined') {
      // Use offset coordinates and find common offsetParent
      var pos = { x: event.offsetX, y: event.offsetY };

      // Send the coordinates upwards through the offsetParent chain.
      var e = el;
      while (e) {
        e.mouseX = pos.x;
        e.mouseY = pos.y;
        pos.x += e.offsetLeft;
        pos.y += e.offsetTop;
        e = e.offsetParent;
      }

      // Look for the coordinates starting from the wheel widget.
      var e = reference;
      var offset = { x: 0, y: 0 }
      while (e) {
        if (typeof e.mouseX != 'undefined') {
          x = e.mouseX - offset.x;
          y = e.mouseY - offset.y;
          break;
        }
        offset.x += e.offsetLeft;
        offset.y += e.offsetTop;
        e = e.offsetParent;
      }

      // Reset stored coordinates
      e = el;
      while (e) {
        e.mouseX = undefined;
        e.mouseY = undefined;
        e = e.offsetParent;
      }
    }
    else {
      // Use absolute coordinates
      var pos = fb.absolutePosition(reference);
      x = (event.pageX || 0*(event.clientX + $('html').get(0).scrollLeft)) - pos.x;
      y = (event.pageY || 0*(event.clientY + $('html').get(0).scrollTop)) - pos.y;
    }
    // Subtract distance to middle
    return { x: x - fb.width / 2, y: y - fb.width / 2 };
  }

  /**
   * Mousedown handler
   */
  fb.mousedown = function (event) {
    // Capture mouse
    if (!document.dragging) {
      $(document).on('mousemove', fb.mousemove).on('mouseup', fb.mouseup);
      document.dragging = true;
    }

    // Check which area is being dragged
    var pos = fb.widgetCoords(event);
    fb.circleDrag = Math.max(Math.abs(pos.x), Math.abs(pos.y)) * 2 > fb.square;

    // Process
    fb.mousemove(event);
    return false;
  }

  /**
   * Mousemove handler
   */
  fb.mousemove = function (event) {
    // Get coordinates relative to color picker center
    var pos = fb.widgetCoords(event);

    // Set new HSL parameters
    if (fb.circleDrag) {
      var hue = Math.atan2(pos.x, -pos.y) / 6.28;
      if (hue < 0) hue += 1;
      fb.setHSL([hue, fb.hsl[1], fb.hsl[2]]);
    }
    else {
      var sat = Math.max(0, Math.min(1, -(pos.x / fb.square) + .5));
      var lum = Math.max(0, Math.min(1, -(pos.y / fb.square) + .5));
      fb.setHSL([fb.hsl[0], sat, lum]);
    }
    return false;
  }

  /**
   * Mouseup handler
   */
  fb.mouseup = function () {
    // Uncapture mouse
    $(document).off('mousemove', fb.mousemove);
    $(document).off('mouseup', fb.mouseup);
    document.dragging = false;
  }

  /**
   * Update the markers and styles
   */
  fb.updateDisplay = function () {
    // Markers
    var angle = fb.hsl[0] * 6.28;
    $('.h-marker', e).css({
      left: Math.round(Math.sin(angle) * fb.radius + fb.width / 2) + 'px',
      top: Math.round(-Math.cos(angle) * fb.radius + fb.width / 2) + 'px'
    });

    $('.sl-marker', e).css({
      left: Math.round(fb.square * (.5 - fb.hsl[1]) + fb.width / 2) + 'px',
      top: Math.round(fb.square * (.5 - fb.hsl[2]) + fb.width / 2) + 'px'
    });

    // Saturation/Luminance gradient
    $('.color', e).css('backgroundColor', fb.pack(fb.HSLToRGB([fb.hsl[0], 1, 0.5])));

    // Linked elements or callback
    if (typeof fb.callback == 'object') {
      // Set background/foreground color
      $(fb.callback).css({
        backgroundColor: fb.color,
        color: fb.hsl[2] > 0.5 ? '#000' : '#fff'
      });

      // Change linked value
      $(fb.callback).each(function() {
        if (this.value && this.value != fb.color) {
          this.value = fb.color;
        }
      });
    }
    else if (typeof fb.callback == 'function') {
      fb.callback.call(fb, fb.color);
    }
  }

  /**
   * Get absolute position of element
   */
  fb.absolutePosition = function (el) {
    var r = { x: el.offsetLeft, y: el.offsetTop };
    // Resolve relative to offsetParent
    if (el.offsetParent) {
      var tmp = fb.absolutePosition(el.offsetParent);
      r.x += tmp.x;
      r.y += tmp.y;
    }
    return r;
  };

  /* Various color utility functions */
  fb.pack = function (rgb) {
    var r = Math.round(rgb[0] * 255);
    var g = Math.round(rgb[1] * 255);
    var b = Math.round(rgb[2] * 255);
    return '#' + (r < 16 ? '0' : '') + r.toString(16) +
           (g < 16 ? '0' : '') + g.toString(16) +
           (b < 16 ? '0' : '') + b.toString(16);
  }

  fb.unpack = function (color) {
    if (color.length == 7) {
      return [parseInt('0x' + color.substring(1, 3)) / 255,
        parseInt('0x' + color.substring(3, 5)) / 255,
        parseInt('0x' + color.substring(5, 7)) / 255];
    }
    else if (color.length == 4) {
      return [parseInt('0x' + color.substring(1, 2)) / 15,
        parseInt('0x' + color.substring(2, 3)) / 15,
        parseInt('0x' + color.substring(3, 4)) / 15];
    }
  }

  fb.HSLToRGB = function (hsl) {
    var m1, m2, r, g, b;
    var h = hsl[0], s = hsl[1], l = hsl[2];
    m2 = (l <= 0.5) ? l * (s + 1) : l + s - l*s;
    m1 = l * 2 - m2;
    return [this.hueToRGB(m1, m2, h+0.33333),
        this.hueToRGB(m1, m2, h),
        this.hueToRGB(m1, m2, h-0.33333)];
  }

  fb.hueToRGB = function (m1, m2, h) {
    h = (h < 0) ? h + 1 : ((h > 1) ? h - 1 : h);
    if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
    if (h * 2 < 1) return m2;
    if (h * 3 < 2) return m1 + (m2 - m1) * (0.66666 - h) * 6;
    return m1;
  }

  fb.RGBToHSL = function (rgb) {
    var min, max, delta, h, s, l;
    var r = rgb[0], g = rgb[1], b = rgb[2];
    min = Math.min(r, Math.min(g, b));
    max = Math.max(r, Math.max(g, b));
    delta = max - min;
    l = (min + max) / 2;
    s = 0;
    if (l > 0 && l < 1) {
      s = delta / (l < 0.5 ? (2 * l) : (2 - 2 * l));
    }
    h = 0;
    if (delta > 0) {
      if (max == r && max != g) h += (g - b) / delta;
      if (max == g && max != b) h += (2 + (b - r) / delta);
      if (max == b && max != r) h += (4 + (r - g) / delta);
      h /= 6;
    }
    return [h, s, l];
  }

  // Install mousedown handler (the others are set on the document on-demand)
  $('*', e).on('mousedown', fb.mousedown);

    // Init color
  fb.setColor('#000000');

  // Set linked elements/callback
  if (callback) {
    fb.linkTo(callback);
  }
}
;/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));
}).call(this);